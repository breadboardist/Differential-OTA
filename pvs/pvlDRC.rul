
// Sample runset for 45 nm
// technology
// PVS(r) version 8.0 DRC file
// generated by GTE Version: MAIN  Build: @1187 (20090703210056) on Jul 8, 2009

// --------------------------------------------------------------------------------
// VERSION v0.1 (initial version)
// --------------------------------------------------------------------------------
// Initial Version -  PVL DRC 

layout_path "CELLNAME.gds" gdsii;
layout_primary "CELLNAME";
results_db -drc "CELLNAME.db" -ascii;

input_scale 2000;
grid 5;
unit -length u;
text_depth -primary;

flag -nonsimple yes;

rule offgrid_check {
    caption Grid violation;
    layout_input -offgrid;
}

rule ortho_45_check {
    caption Orthogonal and 45 degree violation;
    layout_input -skew;
}

rule acute_check {
    caption Acute angle  violation;
    layout_input -acute;
}

layer_def empty 999;

layer_def Bondpad 1000;
layer_map 36 -datatype 0 1000;

layer_def CapMetal 1001;
layer_map 14 -datatype 0 1001;

layer_def Cont 1002;
layer_map 6 -datatype 0 1002;

layer_def ESDdummy 1003;
layer_map 74 -datatype 0 1003;

layer_def INDdummy 1004;
layer_map 16 -datatype 0 1004;

layer_def M1Resdum 1005;
layer_map 75 -datatype 0 1005;

layer_def M2Resdum 1006;
layer_map 76 -datatype 0 1006;

layer_def M3Resdum 1007;
layer_map 77 -datatype 0 1007;

layer_def M4Resdum 1008;
layer_map 78 -datatype 0 1008;

layer_def M5Resdum 1009;
layer_map 79 -datatype 0 1009;

layer_def M6Resdum 1010;
layer_map 80 -datatype 0 1010;

layer_def M7Resdum 1011;
layer_map 81 -datatype 0 1011;

layer_def M8Resdum 1012;
layer_map 82 -datatype 0 1012;

layer_def M9Resdum 1013;
layer_map 83 -datatype 0 1013;

layer_def M10Resdum 1014;
layer_map 93 -datatype 0 1014;

layer_def M11Resdum 1015;
layer_map 103 -datatype 0 1015;

layer_def Metal1 1016;
layer_map 7 -datatype 0 1016;

layer_def Metal2 1017;
layer_map 9 -datatype 0 1017;

layer_def Metal3 1018;
layer_map 11 -datatype 0 1018;

layer_def Metal4 1019;
layer_map 31 -datatype 0 1019;

layer_def Metal5 1020;
layer_map 33 -datatype 0 1020;

layer_def Metal6 1021;
layer_map 35 -datatype 0 1021;

layer_def Metal7 1022;
layer_map 38 -datatype 0 1022;

layer_def Metal8 1023;
layer_map 40 -datatype 0 1023;

layer_def Metal9 1024;
layer_map 42 -datatype 0 1024;

layer_def Metal10 1025;
layer_map 152 -datatype 0 1025;

layer_def Metal11 1026;
layer_map 162 -datatype 0 1026;

layer_def NPNdummy 1027;
layer_map 20 -datatype 0 1027;

layer_def Nburied 1028;
layer_map 19 -datatype 0 1028;

layer_def Nhvt 1029;
layer_map 18 -datatype 0 1029;

layer_def Nimp 1030;
layer_map 4 -datatype 0 1030;

layer_def Nlvt 1031;
layer_map 26 -datatype 0 1031;

layer_def Nwell 1032;
layer_map 2 -datatype 0 1032;

layer_def Nzvt 1033;
layer_map 52 -datatype 0 1033;

layer_def Oxide 1034;
layer_map 1 -datatype 0 1034;

layer_def Oxide_thk 1035;
layer_map 24 -datatype 0 1035;

layer_def PNPdummy 1036;
layer_map 21 -datatype 0 1036;

layer_def Phvt 1037;
layer_map 23 -datatype 0 1037;

layer_def Pimp 1038;
layer_map 5 -datatype 0 1038;

layer_def Plvt 1039;
layer_map 27 -datatype 0 1039;

layer_def Poly 1040;
layer_map 3 -datatype 0 1040;

layer_def Psub 1041;
layer_map 25 -datatype 0 1041;

layer_def ResWdum 1042;
layer_map 71 -datatype 0 1042;

layer_def Resdum 1043;
layer_map 13 -datatype 0 1043;

layer_def SiProt 1044;
layer_map 72 -datatype 0 1044;

layer_def Via1 1045;
layer_map 8 -datatype 0 1045;

layer_def Via2 1046;
layer_map 10 -datatype 0 1046;

layer_def Via3 1047;
layer_map 30 -datatype 0 1047;

layer_def Via4 1048;
layer_map 32 -datatype 0 1048;

layer_def Via5 1049;
layer_map 34 -datatype 0 1049;

layer_def Via6 1050;
layer_map 37 -datatype 0 1050;

layer_def Via7 1051;
layer_map 39 -datatype 0 1051;

layer_def Via8 1052;
layer_map 41 -datatype 0 1052;

layer_def Via9 1053;
layer_map 151 -datatype 0 1053;

layer_def Via10 1054;
layer_map 161 -datatype 0 1054;

layer_def metal1_conn_text 1055;
layer_map 7 -texttype 0 1055;
text_layer metal1_conn_text;

layer_def metal2_conn_text 1056;
layer_map 9 -texttype 0 1056;
text_layer metal2_conn_text;

layer_def metal3_conn_text 1057;
layer_map 11 -texttype 0 1057;
text_layer metal3_conn_text;

layer_def metal4_conn_text 1058;
layer_map 31 -texttype 0 1058;
text_layer metal4_conn_text;

layer_def metal5_conn_text 1059;
layer_map 33 -texttype 0 1059;
text_layer metal5_conn_text;

layer_def metal6_conn_text 1060;
layer_map 35 -texttype 0 1060;
text_layer metal6_conn_text;

layer_def metal7_conn_text 1061;
layer_map 38 -texttype 0 1061;
text_layer metal7_conn_text;

layer_def metal8_conn_text 1062;
layer_map 40 -texttype 0 1062;
text_layer metal8_conn_text;

layer_def metal9_conn_text 1063;
layer_map 42 -texttype 0 1063;
text_layer metal9_conn_text;

layer_def metal10_conn_text 1064;
layer_map 152 -texttype 0 1064;
text_layer metal10_conn_text;

layer_def metal11_conn_text 1065;
layer_map 162 -texttype 0 1065;
text_layer metal11_conn_text;

layer_def poly_conn_text 1066;
layer_map 3 -texttype 0 1066;
text_layer poly_conn_text;

extent bulk;

// Remove the beveled Bondpad edges.
// bondpad_sq=Bondpad downUp 5.0
size Bondpad -by 5.0 -underover bondpad_sq;

// bp_tap=Bondpad and Metal9
and Bondpad Metal9 bp_tap;

// cont_cluster_lt_pt1=(Cont withNeighbor < 0.1 >= 3)
select -with_neighbor Cont -ge  3 -space -lt  0.1 cont_cluster_lt_pt1;

// cont_poly=Cont and Poly
and Cont Poly cont_poly;

// cont_antenna=cont_poly and Poly
and Poly cont_poly cont_antenna;

// gate=Poly and Oxide
and Oxide Poly gate;

// metal1_conn=Metal1 andnot M1Resdum
not Metal1 M1Resdum metal1_conn;

// metal2_conn=Metal2 andnot M2Resdum
not Metal2 M2Resdum metal2_conn;

// metal3_conn=Metal3 andnot M3Resdum
not Metal3 M3Resdum metal3_conn;

// metal4_conn=Metal4 andnot M4Resdum
not Metal4 M4Resdum metal4_conn;

// metal5_conn=Metal5 andnot M5Resdum
not Metal5 M5Resdum metal5_conn;

// metal6_conn=Metal6 andnot M6Resdum
not Metal6 M6Resdum metal6_conn;

// metal7_conn=Metal7 andnot M7Resdum
not Metal7 M7Resdum metal7_conn;

// metal8_conn=Metal8 andnot M8Resdum
not Metal8 M8Resdum metal8_conn;

// metal9_conn=Metal9  andnot M9Resdum
not Metal9 M9Resdum metal9_conn;

// nactive=Nimp and Oxide
and Nimp Oxide nactive;

// nb_tap=Nburied and Nwell
and Nburied Nwell nb_tap;

// nwell_conn=Nwell andnot ResWdum
not Nwell ResWdum nwell_conn;

// nwellres=Nwell and ResWdum
and Nwell ResWdum nwellres;

// pactive=Pimp and Oxide
and Oxide Pimp pactive;

// pdiff=pactive andnot Poly
not pactive Poly pdiff;

// pdiff_conn=pdiff andnot Resdum
not pdiff Resdum pdiff_conn;

// cont_pdiff=Cont and pdiff_conn
and Cont pdiff_conn cont_pdiff;

// poly_conn=Poly andnot Resdum
not Poly Resdum poly_conn;

// ndiff=(nactive andnot poly_conn)
not nactive poly_conn ndiff;

// ndiff_conn=ndiff andnot Resdum
not ndiff Resdum ndiff_conn;

// cont_ndiff=Cont and ndiff_conn
and Cont ndiff_conn cont_ndiff;

// cont_diode=cont_ndiff or cont_pdiff

// cont_diode=cont_ndiff or cont_pdiff
or cont_ndiff cont_pdiff cont_diode;

// diff_diode=ndiff_conn or pdiff_conn

// diff_diode=ndiff_conn or pdiff_conn
or ndiff_conn pdiff_conn diff_diode;

// nsd=ndiff_conn buttOnly Poly
select -touch ndiff_conn Poly nsd;

// nsd_esd=nsd and ESDdummy
and ESDdummy nsd nsd_esd;

// poly_on_field=Poly andnot Oxide
not Poly Oxide poly_on_field;

// poly_tap=poly_on_field and Poly
and Poly poly_on_field poly_tap;

// psd=pdiff_conn buttOnly Poly
select -touch pdiff_conn Poly psd;

// psd_esd=psd and ESDdummy
and ESDdummy psd psd_esd;

// rule_NZVT_X_4=Nzvt interact > 1 Oxide
select -interact Nzvt Oxide -gt 1 rule_NZVT_X_4;

// via10_cap=Via10 and CapMetal
and CapMetal Via10 via10_cap;

// via10_nocap=Via10 andnot CapMetal
not Via10 CapMetal via10_nocap;

// bondpad_to_die_edge=Bondpad drcEncBy < 50.0 ( bulk area > 100000.0 )
area bulk -gt 100000.0 L31068;
enc Bondpad L31068 -lt 50.0 -metric opposite -para only -output region bondpad_to_die_edge;

// bondpad_via1_array=(( Via1 and Bondpad ) upDown 0.3)
and Bondpad Via1 L92260;
size L92260 -by 0.3 -overunder bondpad_via1_array;

// bondpad_via2_array=(( Via2 and Bondpad ) upDown 0.3)
and Bondpad Via2 L92259;
size L92259 -by 0.3 -overunder bondpad_via2_array;

// bondpad_via3_array=(( Via3 and Bondpad ) upDown 0.3)
and Bondpad Via3 L92258;
size L92258 -by 0.3 -overunder bondpad_via3_array;

// bondpad_via4_array=(( Via4 and Bondpad ) upDown 0.3)
and Bondpad Via4 L92257;
size L92257 -by 0.3 -overunder bondpad_via4_array;

// bondpad_via5_array=(( Via5 and Bondpad ) upDown 0.3)
and Bondpad Via5 L92256;
size L92256 -by 0.3 -overunder bondpad_via5_array;

// bondpad_via6_array=(( Via6 and Bondpad ) upDown 0.3)
and Bondpad Via6 L92255;
size L92255 -by 0.3 -overunder bondpad_via6_array;

// bondpad_via7_array=(( Via7 and Bondpad ) upDown 0.3)
and Bondpad Via7 L92254;
size L92254 -by 0.3 -overunder bondpad_via7_array;

// bondpad_via8_array=(( Via8 and Bondpad ) upDown 0.3)
and Bondpad Via8 L92253;
size L92253 -by 0.3 -overunder bondpad_via8_array;

// bondpad_via9_array=(( Via9 and Bondpad ) upDown 0.3)
and Bondpad Via9 L92252;
size L92252 -by 0.3 -overunder bondpad_via9_array;

// bondpad_via10_array=(( Via10 and Bondpad ) upDown 0.3)
and Bondpad Via10 L45652;
size L45652 -by 0.3 -overunder bondpad_via10_array;

// m1m2v1=(Metal1 and Metal2) enclose Via1
and Metal1 Metal2 L38712;
select -enclose L38712 Via1 m1m2v1;

// m2m3v2=(Metal2 and Metal3) enclose Via2
and Metal2 Metal3 L18248;
select -enclose L18248 Via2 m2m3v2;

// m3m4v3=(Metal3 and Metal4) enclose Via3
and Metal3 Metal4 L92088;
select -enclose L92088 Via3 m3m4v3;

// m4m5v4=(Metal4 and Metal5) enclose Via4
and Metal4 Metal5 L2424;
select -enclose L2424 Via4 m4m5v4;

// m5m6v5=(Metal5 and Metal6) enclose Via5
and Metal5 Metal6 L54536;
select -enclose L54536 Via5 m5m6v5;

// m6m7v6=(Metal6 and Metal7) enclose Via6
and Metal6 Metal7 L55800;
select -enclose L55800 Via6 m6m7v6;

// m7m8v7=(Metal7 and Metal8) enclose Via7
and Metal7 Metal8 L1160;
select -enclose L1160 Via7 m7m8v7;

// m8m9v8=(Metal8 and Metal9) enclose Via8
and Metal8 Metal9 L9176;
select -enclose L9176 Via8 m8m9v8;

// metal10_conn=Metal10 andnot (M10Resdum or INDdummy)

// metal10_conn=Metal10 andnot (M10Resdum or INDdummy)
or INDdummy M10Resdum L17074;
not Metal10 L17074 metal10_conn;

// metal11_conn=Metal11 andnot (M11Resdum or INDdummy )

// metal11_conn=Metal11 andnot (M11Resdum or INDdummy )
or INDdummy M11Resdum L86607;
not Metal11 L86607 metal11_conn;

// npn_emit=(ndiff_conn and NPNdummy ) andnot Nwell
and NPNdummy ndiff_conn L61645;
not L61645 Nwell npn_emit;

// nwell_in_od_res=(Nwell overlap Oxide) overlap ResWdum
select -outside -not Nwell Oxide L60860;
select -outside -not L60860 ResWdum nwell_in_od_res;

// oxide_in_res=(Oxide cut Resdum) cut SiProt
select -cut Oxide Resdum L36999;
select -cut L36999 SiProt oxide_in_res;

// poly_in_res=(Poly cut Resdum) cut SiProt
select -cut Poly Resdum L80658;
select -cut L80658 SiProt poly_in_res;

// rule_BONDPAD_L_1=bondpad_sq inside (bondpad_to_die_edge grow 68.0)
edge_expand bondpad_to_die_edge -outside_by 68.0 L23193;
or L23193 bondpad_to_die_edge L45856;
select -inside bondpad_sq L45856 rule_BONDPAD_L_1;

// rule_NBL_X_1=Nburied outside (holes Nwell)
holes Nwell L90546;
not L90546 Nwell L90545;
select -outside Nburied L90545 rule_NBL_X_1;

// rule_NHVT_X_1=(Oxide interact Nhvt) xor Nhvt
select -interact Oxide Nhvt L16673;
xor L16673 Nhvt rule_NHVT_X_1;

// rule_NLVT_X_1=(Oxide interact Nlvt) xor Nlvt
select -interact Oxide Nlvt L20517;
xor L20517 Nlvt rule_NLVT_X_1;

// rule_PHVT_X_1=(Oxide interact Phvt) xor Phvt
select -interact Oxide Phvt L76255;
xor L76255 Phvt rule_PHVT_X_1;

// rule_PLVT_X_1=(Oxide interact Plvt) xor Plvt
select -interact Oxide Plvt L80099;
xor L80099 Plvt rule_PLVT_X_1;

// rule_VIA1_E_3_PLATE=(Metal1 and Metal2) downUp .75
size L38712 -by .75 -underover rule_VIA1_E_3_PLATE;

// rule_VIA2_E_3_PLATE=(Metal2 and Metal3) downUp .75
size L18248 -by .75 -underover rule_VIA2_E_3_PLATE;

// rule_VIA3_E_3_PLATE=(Metal3 and Metal4) downUp .75
size L92088 -by .75 -underover rule_VIA3_E_3_PLATE;

// rule_VIA4_E_3_PLATE=(Metal4 and Metal5) downUp .75
size L2424 -by .75 -underover rule_VIA4_E_3_PLATE;

// rule_VIA5_E_3_PLATE=(Metal5 and Metal6) downUp .75
size L54536 -by .75 -underover rule_VIA5_E_3_PLATE;

// rule_VIA6_E_3_PLATE=(Metal6 and Metal7) downUp .75
size L55800 -by .75 -underover rule_VIA6_E_3_PLATE;

// rule_VIA7_E_3_PLATE=(Metal7 and Metal8) downUp .75
size L1160 -by .75 -underover rule_VIA7_E_3_PLATE;

// rule_VIA8_E_3_PLATE=(Metal8 and Metal9) downUp .75
size L9176 -by .75 -underover rule_VIA8_E_3_PLATE;

// cont_array_zone=(( ( Cont size 0.09 ) downUp 0.409 ) size -0.09)
size Cont -by 0.09 L26410;
size L26410 -by 0.409 -underover L61819;
size L61819 -by -0.09 cont_array_zone;

// ntap=(Nwell and ndiff_conn) andnot (Psub and NPNdummy)
and Nwell ndiff_conn L74405;
and NPNdummy Psub L28555;
not L74405 L28555 ntap;

// ntap_esd=ntap and ESDdummy
and ESDdummy ntap ntap_esd;

// rule_ESD_7_pmos=ntap_esd buttOnly psd_esd
select -touch ntap_esd psd_esd rule_ESD_7_pmos;

// ptap=(pdiff_conn andnot (Nwell andnot Psub)) andnot PNPdummy
not Nwell Psub L83944;
not pdiff_conn L83944 L65704;
not L65704 PNPdummy ptap;

// ptap_esd=ptap and ESDdummy
and ESDdummy ptap ptap_esd;

// rule_ESD_7_nmos=ptap_esd buttOnly nsd_esd
select -touch ptap_esd nsd_esd rule_ESD_7_nmos;

// rule_ESD_5=(Oxide cut nsd_esd) andnot (holes ptap_esd)
select -cut Oxide nsd_esd L54535;
holes ptap_esd L31818;
not L31818 ptap_esd L31817;
not L54535 L31817 rule_ESD_5;

// rule_ESD_6=(Oxide cut psd_esd) andnot (holes ntap_esd)
select -cut Oxide psd_esd L52827;
holes ntap_esd L85192;
not L85192 ntap_esd L85191;
not L52827 L85191 rule_ESD_6;

// rule_NZVT_O_1=((Oxide interact Nzvt) size 0.16) xor Nzvt
select -interact Oxide Nzvt L33971;
size L33971 -by 0.16 L90685;
xor L90685 Nzvt rule_NZVT_O_1;

// via1_array_zone=(( ( Via1 size 0.11 ) downUp 0.499 ) size -0.11)
size Via1 -by 0.11 L17980;
size L17980 -by 0.499 -underover L90952;
size L90952 -by -0.11 via1_array_zone;

// via2_array_zone=(( ( Via2 size 0.11 ) downUp 0.499 ) size -0.11)
size Via2 -by 0.11 L47131;
size L47131 -by 0.499 -underover L42681;
size L42681 -by -0.11 via2_array_zone;

// via3_array_zone=(( ( Via3 size 0.11 ) downUp 0.499 ) size -0.11)
size Via3 -by 0.11 L76282;
size L76282 -by 0.499 -underover L64294;
size L64294 -by -0.11 via3_array_zone;

// via4_array_zone=(( ( Via4 size 0.11 ) downUp 0.499 ) size -0.11)
size Via4 -by 0.11 L5433;
size L5433 -by 0.499 -underover L77470;
size L77470 -by -0.11 via4_array_zone;

// via5_array_zone=(( ( Via5 size 0.11 ) downUp 0.499 ) size -0.11)
size Via5 -by 0.11 L34584;
size L34584 -by 0.499 -underover L55171;
size L55171 -by -0.11 via5_array_zone;

// via6_array_zone=(( ( Via6 size 0.11 ) downUp 0.499 ) size -0.11)
size Via6 -by 0.11 L63735;
size L63735 -by 0.499 -underover L83479;
size L83479 -by -0.11 via6_array_zone;

// via7_array_zone=(( ( Via7 size 0.11 ) downUp 0.499 ) size -0.11)
size Via7 -by 0.11 L92886;
size L92886 -by 0.499 -underover L76842;
size L76842 -by -0.11 via7_array_zone;

// via8_array_zone=(( ( Via8 size 0.11 ) downUp 0.499 ) size -0.11)
size Via8 -by 0.11 L22037;
size L22037 -by 0.499 -underover L12415;
size L12415 -by -0.11 via8_array_zone;

// metal1_with_diode=(metal1_conn interact > 1 diff_diode) or (metal1_conn interact
//  (diff_diode area >= 0.1))
select -interact metal1_conn diff_diode -gt 1 L90713;
area diff_diode -ge 0.1 L28904;
select -interact metal1_conn L28904 L77036;
or L77036 L90713 metal1_with_diode;

// metal1_wo_diode=metal1_conn andnot metal1_with_diode
not metal1_conn metal1_with_diode metal1_wo_diode;

// resdum_sz=Resdum or ((Resdum growEdges 0.001) outside (Poly or Oxide))
edge_expand Resdum -outside_by 0.001 L4140;
or Oxide Poly L32232;
select -outside L4140 L32232 L10364;
or L10364 Resdum resdum_sz;

// via1_x_1=(Via1 and ( ( Metal1 downUp 0.20 ) or ( Metal2 downUp 0.20 ) ))
size Metal1 -by 0.20 -underover L82991;
size Metal2 -by 0.20 -underover L12142;
or L12142 L82991 L21748;
and L21748 Via1 via1_x_1;

// via1_x_2=(Via1 and ( ( Metal1 downUp 0.50 ) or ( Metal2 downUp 0.50 ) ))
size Metal1 -by 0.50 -underover L83084;
size Metal2 -by 0.50 -underover L12235;
or L12235 L83084 L4033;
and L4033 Via1 via1_x_2;

// via2_x_1=(Via2 and ( ( Metal2 downUp 0.20 ) or ( Metal3 downUp 0.20 ) ))
size Metal3 -by 0.20 -underover L41293;
or L12142 L41293 L52348;
and L52348 Via2 via2_x_1;

// via2_x_2=(Via2 and ( ( Metal2 downUp 0.50 ) or ( Metal3 downUp 0.50 ) ))
size Metal3 -by 0.50 -underover L41386;
or L12235 L41386 L53252;
and L53252 Via2 via2_x_2;

// via3_x_1=(Via3 and ( ( Metal3 downUp 0.20 ) or ( Metal4 downUp 0.20 ) ))
size Metal4 -by 0.20 -underover L70444;
or L41293 L70444 L48815;
and L48815 Via3 via3_x_1;

// via3_x_2=(Via3 and ( ( Metal3 downUp 0.50 ) or ( Metal4 downUp 0.50 ) ))
size Metal4 -by 0.50 -underover L70537;
or L41386 L70537 L87119;
and L87119 Via3 via3_x_2;

// via4_x_1=(Via4 and ( ( Metal4 downUp 0.20 ) or ( Metal5 downUp 0.20 ) ))
size Metal5 -by 0.20 -underover L99595;
or L70444 L99595 L18361;
and L18361 Via4 via4_x_1;

// via4_x_2=(Via4 and ( ( Metal4 downUp 0.50 ) or ( Metal5 downUp 0.50 ) ))
size Metal5 -by 0.50 -underover L99688;
or L70537 L99688 L43335;
and L43335 Via4 via4_x_2;

// via5_x_1=(Via5 and ( ( Metal5 downUp 0.20 ) or ( Metal6 downUp 0.20 ) ))
size Metal6 -by 0.20 -underover L28746;
or L28746 L99595 L91359;
and L91359 Via5 via5_x_1;

// via5_x_2=(Via5 and ( ( Metal5 downUp 0.50 ) or ( Metal6 downUp 0.50 ) ))
size Metal6 -by 0.50 -underover L28839;
or L28839 L99688 L14241;
and L14241 Via5 via5_x_2;

// via6_x_1=(Via6 and ( ( Metal6 downUp 0.20 ) or ( Metal7 downUp 0.20 ) ))
size Metal7 -by 0.20 -underover L57897;
or L28746 L57897 L42140;
and L42140 Via6 via6_x_1;

// via6_x_2=(Via6 and ( ( Metal6 downUp 0.50 ) or ( Metal7 downUp 0.50 ) ))
size Metal7 -by 0.50 -underover L57990;
or L28839 L57990 L63481;
and L63481 Via6 via6_x_2;

// via7_x_1=(Via7 and ( ( Metal7 downUp 0.20 ) or ( Metal8 downUp 0.20 ) ))
size Metal8 -by 0.20 -underover L87048;
or L57897 L87048 L79204;
and L79204 Via7 via7_x_1;

// via7_x_2=(Via7 and ( ( Metal7 downUp 0.50 ) or ( Metal8 downUp 0.50 ) ))
size Metal8 -by 0.50 -underover L87141;
or L57990 L87141 L96196;
and L96196 Via7 via7_x_2;

// via8_x_1=(Via8 and ( ( Metal8 downUp 0.20 ) or ( Metal9 downUp 0.20 ) ))
size Metal9 -by 0.20 -underover L16199;
or L16199 L87048 L19700;
and L19700 Via8 via8_x_1;

// via8_x_2=(Via8 and ( ( Metal8 downUp 0.50 ) or ( Metal9 downUp 0.50 ) ))
size Metal9 -by 0.50 -underover L16292;
or L16292 L87141 L2708;
and L2708 Via8 via8_x_2;

// via_1_5_stack=Via1 and Via2 and Via3 and Via4 and Via5
and Via1 Via2 L90744;
and L90744 Via3 L33864;
and L33864 Via4 L30797;
and L30797 Via5 via_1_5_stack;

// via_2_6_stack=Via2 and Via3 and Via4 and Via5 and Via6
and Via2 Via3 L19896;
and L19896 Via4 L73372;
and L73372 Via5 L56520;
and L56520 Via6 via_2_6_stack;

// via_3_7_stack=Via3 and Via4 and Via5 and Via6 and Via7
and Via3 Via4 L49048;
and L49048 Via5 L40741;
and L40741 Via6 L13939;
and L13939 Via7 via_3_7_stack;

// via_4_8_stack=Via4 and Via5 and Via6 and Via7 and Via8
and Via4 Via5 L78200;
and L78200 Via6 L54054;
and L54054 Via7 L29444;
and L29444 Via8 via_4_8_stack;

// metal_1_6_stack=Metal1 and Metal2 and Metal3 and Metal4 and Metal5 and Metal6
and L38712 Metal3 L46076;
and L46076 Metal4 L40611;
and L40611 Metal5 L40951;
and L40951 Metal6 metal_1_6_stack;

// rule_VIAk_X_3_X_4a=metal_1_6_stack enclose == 1 via_1_5_stack
select -enclose metal_1_6_stack via_1_5_stack -eq 1 rule_VIAk_X_3_X_4a;

// metal_2_7_stack=Metal2 and Metal3 and Metal4 and Metal5 and Metal6 and Metal7
and L18248 Metal4 L79489;
and L79489 Metal5 L42786;
and L42786 Metal6 L29755;
and L29755 Metal7 metal_2_7_stack;

// rule_VIAk_X_3_X_4b=metal_2_7_stack enclose == 1 via_2_6_stack
select -enclose metal_2_7_stack via_2_6_stack -eq 1 rule_VIAk_X_3_X_4b;

// metal_3_8_stack=Metal3 and Metal4 and Metal5 and Metal6 and Metal7 and Metal8
and L92088 Metal5 L76038;
and L76038 Metal6 L74596;
and L74596 Metal7 L15038;
and L15038 Metal8 metal_3_8_stack;

// rule_VIAk_X_3_X_4c=metal_3_8_stack enclose == 1 via_3_7_stack
select -enclose metal_3_8_stack via_3_7_stack -eq 1 rule_VIAk_X_3_X_4c;

// metal_4_9_stack=Metal4 and Metal5 and Metal6 and Metal7 and Metal8 and Metal9
and L2424 Metal6 L13512;
and L13512 Metal7 L29855;
and L29855 Metal8 L78947;
and L78947 Metal9 metal_4_9_stack;

// rule_VIAk_X_3_X_4d=metal_4_9_stack enclose == 1 via_4_8_stack
select -enclose metal_4_9_stack via_4_8_stack -eq 1 rule_VIAk_X_3_X_4d;

// psubstrate=(bulk andnot (Nburied and Nwell)) andnot (Psub andnot (Psub size -0.001))
not bulk nb_tap L14174;
size Psub -by -0.001 L86601;
not Psub L86601 L7495;
not L14174 L7495 psubstrate;

// bondpad_metal1_filled=((( (fill Metal1) enclose Bondpad) downUp 25.0) and (fill Metal1)
//  ) enclose Bondpad
holes Metal1 L11511;
or L11511 Metal1 L94375;
select -enclose L94375 Bondpad L83147;
size L83147 -by 25.0 -underover L11659;
and L11659 L94375 L22419;
select -enclose L22419 Bondpad bondpad_metal1_filled;

// bondpad_metal2_filled=((( (fill Metal2) enclose Bondpad) downUp 25.0) and (fill Metal2)
//  ) enclose Bondpad
holes Metal2 L11512;
or L11512 Metal2 L94376;
select -enclose L94376 Bondpad L28684;
size L28684 -by 25.0 -underover L91294;
and L91294 L94376 L29447;
select -enclose L29447 Bondpad bondpad_metal2_filled;

// bondpad_metal3_filled=((( (fill Metal3) enclose Bondpad) downUp 25.0) and (fill Metal3)
//  ) enclose Bondpad
holes Metal3 L11513;
or L11513 Metal3 L94377;
select -enclose L94377 Bondpad L25779;
size L25779 -by 25.0 -underover L57208;
and L57208 L94377 L38857;
select -enclose L38857 Bondpad bondpad_metal3_filled;

// bondpad_metal4_filled=((( (fill Metal4) enclose Bondpad) downUp 25.0) and (fill Metal4)
//  ) enclose Bondpad
holes Metal4 L11514;
or L11514 Metal4 L94378;
select -enclose L94378 Bondpad L87054;
size L87054 -by 25.0 -underover L10974;
and L10974 L94378 L74553;
select -enclose L74553 Bondpad bondpad_metal4_filled;

// bondpad_metal5_filled=((( (fill Metal5) enclose Bondpad) downUp 25.0) and (fill Metal5)
//  ) enclose Bondpad
holes Metal5 L11515;
or L11515 Metal5 L94379;
select -enclose L94379 Bondpad L67409;
size L67409 -by 25.0 -underover L60622;
and L60622 L94379 L45717;
select -enclose L45717 Bondpad bondpad_metal5_filled;

// bondpad_metal6_filled=((( (fill Metal6) enclose Bondpad) downUp 25.0) and (fill Metal6)
//  ) enclose Bondpad
holes Metal6 L11516;
or L11516 Metal6 L94380;
select -enclose L94380 Bondpad L59931;
size L59931 -by 25.0 -underover L61125;
and L61125 L94380 L25614;
select -enclose L25614 Bondpad bondpad_metal6_filled;

// bondpad_metal7_filled=((( (fill Metal7) enclose Bondpad) downUp 25.0) and (fill Metal7)
//  ) enclose Bondpad
holes Metal7 L11517;
or L11517 Metal7 L94381;
select -enclose L94381 Bondpad L52902;
size L52902 -by 25.0 -underover L96368;
and L94381 L96368 L79426;
select -enclose L79426 Bondpad bondpad_metal7_filled;

// bondpad_metal8_filled=((( (fill Metal8) enclose Bondpad) downUp 25.0) and (fill Metal8)
//  ) enclose Bondpad
holes Metal8 L11518;
or L11518 Metal8 L94382;
select -enclose L94382 Bondpad L1561;
size L1561 -by 25.0 -underover L79037;
and L79037 L94382 L79063;
select -enclose L79063 Bondpad bondpad_metal8_filled;

// bondpad_metal9_filled=((( (fill Metal9) enclose Bondpad) downUp 25.0) and (fill Metal9)
//  ) enclose Bondpad
holes Metal9 L11519;
or L11519 Metal9 L94383;
select -enclose L94383 Bondpad L11272;
size L11272 -by 25.0 -underover L32833;
and L32833 L94383 L91025;
select -enclose L91025 Bondpad bondpad_metal9_filled;

// bondpad_metal10_filled=((( (fill Metal10) enclose Bondpad) downUp 25.0) and (fill
//  Metal10) ) enclose Bondpad
holes Metal10 L77703;
or L77703 Metal10 L58377;
select -enclose L58377 Bondpad L17125;
size L17125 -by 25.0 -underover L33952;
and L33952 L58377 L66545;
select -enclose L66545 Bondpad bondpad_metal10_filled;

// bondpad_metal11_filled=((( (fill Metal11) enclose Bondpad) downUp 25.0) and (fill
//  Metal11) ) enclose Bondpad
holes Metal11 L77702;
or L77702 Metal11 L58378;
select -enclose L58378 Bondpad L37338;
size L37338 -by 25.0 -underover L51450;
and L51450 L58378 L85739;
select -enclose L85739 Bondpad bondpad_metal11_filled;

// rule_POLY_SE_3=((Poly andnot (Cont sizeWithin 6 0.2 Poly)) buttOnly == 2 (Cont sizeWithin
//  6 0.2 Poly)) andnot (Poly downUp 0.07)
size Cont -by 6 -inside_of Poly -step 0.2 L2596;
not Poly L2596 L29188;
select -touch L29188 L2596 -eq 2 L92413;
size Poly -by 0.07 -underover L99542;
not L92413 L99542 rule_POLY_SE_3;

// via1_e_3=m1m2v1 butt (((m1m2v1 drcSep2All <= 3.0 rule_VIA1_E_3_PLATE ) and ( Metal1
//  or Metal2)) butt > 1 ( rule_VIA1_E_3_PLATE or m1m2v1))
exte m1m2v1 rule_VIA1_E_3_PLATE -le 3.0 -output region L12009;
or Metal1 Metal2 L38948;
and L12009 L38948 L73527;
or m1m2v1 rule_VIA1_E_3_PLATE L41560;
edge_boolean -coincident_only L41560 L73527 -outside L36434;
edge_expand L36434 -inside_by 0.001 L13878;
select -interact L41560 L13878 L93892;
select -interact L73527 L93892 -gt 1 L17164;
edge_boolean -coincident_only L17164 m1m2v1 -outside L70743;
edge_expand L70743 -inside_by 0.001 L54357;
select -interact m1m2v1 L54357 via1_e_3;

// rule_VIA1_E_3=via1_e_3 enclose < 2 Via1
select -enclose via1_e_3 Via1 -ge 2 L91113;
select -interact -not via1_e_3 L91113 rule_VIA1_E_3;

// via2_e_3=m2m3v2 butt (((m2m3v2 drcSep2All <= 3.0 rule_VIA2_E_3_PLATE ) and ( Metal2
//  or Metal3)) butt > 1 ( rule_VIA2_E_3_PLATE or m2m3v2))
exte m2m3v2 rule_VIA2_E_3_PLATE -le 3.0 -output region L53957;
or Metal2 Metal3 L18012;
and L18012 L53957 L40458;
or m2m3v2 rule_VIA2_E_3_PLATE L63548;
edge_boolean -coincident_only L63548 L40458 -outside L12095;
edge_expand L12095 -inside_by 0.001 L83875;
select -interact L63548 L83875 L56322;
select -interact L40458 L56322 -gt 1 L10561;
edge_boolean -coincident_only L10561 m2m3v2 -outside L1628;
edge_expand L1628 -inside_by 0.001 L50163;
select -interact m2m3v2 L50163 via2_e_3;

// rule_VIA2_E_3=via2_e_3 enclose < 2 Via2
select -enclose via2_e_3 Via2 -ge 2 L60617;
select -interact -not via2_e_3 L60617 rule_VIA2_E_3;

// via3_e_3=m3m4v3 butt (((m3m4v3 drcSep2All <= 3.0 rule_VIA3_E_3_PLATE ) and ( Metal3
//  or Metal4)) butt > 1 ( rule_VIA3_E_3_PLATE or m3m4v3))
exte m3m4v3 rule_VIA3_E_3_PLATE -le 3.0 -output region L71391;
or Metal3 Metal4 L92324;
and L71391 L92324 L35458;
or m3m4v3 rule_VIA3_E_3_PLATE L81760;
edge_boolean -coincident_only L81760 L35458 -outside L58175;
edge_expand L58175 -inside_by 0.001 L16740;
select -interact L81760 L16740 L86069;
select -interact L35458 L86069 -gt 1 L92125;
edge_boolean -coincident_only L92125 m3m4v3 -outside L84867;
edge_expand L84867 -inside_by 0.001 L70219;
select -interact m3m4v3 L70219 via3_e_3;

// rule_VIA3_E_3=via3_e_3 enclose < 2 Via3
select -enclose via3_e_3 Via3 -ge 2 L30121;
select -interact -not via3_e_3 L30121 rule_VIA3_E_3;

// via4_e_3=m4m5v4 butt (((m4m5v4 drcSep2All <= 3.0 rule_VIA4_E_3_PLATE ) and ( Metal4
//  or Metal5)) butt > 1 ( rule_VIA4_E_3_PLATE or m4m5v4))
exte m4m5v4 rule_VIA4_E_3_PLATE -le 3.0 -output region L29443;
or Metal4 Metal5 L64636;
and L29443 L64636 L17594;
or m4m5v4 rule_VIA4_E_3_PLATE L40228;
edge_boolean -coincident_only L40228 L17594 -outside L70608;
edge_expand L70608 -inside_by 0.001 L62883;
select -interact L40228 L62883 L29638;
select -interact L17594 L29638 -gt 1 L74674;
edge_boolean -coincident_only L74674 m4m5v4 -outside L16251;
edge_expand L16251 -inside_by 0.001 L86369;
select -interact m4m5v4 L86369 via4_e_3;

// rule_VIA4_E_3=via4_e_3 enclose < 2 Via4
select -enclose via4_e_3 Via4 -ge 2 L67671;
select -interact -not via4_e_3 L67671 rule_VIA4_E_3;

// via5_e_3=m5m6v5 butt (((m5m6v5 drcSep2All <= 3.0 rule_VIA5_E_3_PLATE ) and ( Metal5
//  or Metal6)) butt > 1 ( rule_VIA5_E_3_PLATE or m5m6v5))
exte m5m6v5 rule_VIA5_E_3_PLATE -le 3.0 -output region L12505;
or Metal5 Metal6 L45700;
and L12505 L45700 L31348;
or m5m6v5 rule_VIA5_E_3_PLATE L5080;
edge_boolean -coincident_only L5080 L31348 -outside L93348;
edge_expand L93348 -inside_by 0.001 L55531;
select -interact L5080 L55531 L72905;
select -interact L31348 L72905 -gt 1 L33990;
edge_boolean -coincident_only L33990 m5m6v5 -outside L17102;
edge_expand L17102 -inside_by 0.001 L75771;
select -interact m5m6v5 L75771 via5_e_3;

// rule_VIA5_E_3=via5_e_3 enclose < 2 Via5
select -enclose via5_e_3 Via5 -ge 2 L98167;
select -interact -not via5_e_3 L98167 rule_VIA5_E_3;

// via6_e_3=m6m7v6 butt (((m6m7v6 drcSep2All <= 3.0 rule_VIA6_E_3_PLATE ) and ( Metal6
//  or Metal7)) butt > 1 ( rule_VIA6_E_3_PLATE or m6m7v6))
exte m6m7v6 rule_VIA6_E_3_PLATE -le 3.0 -output region L54453;
or Metal6 Metal7 L56036;
and L54453 L56036 L71402;
or m6m7v6 rule_VIA6_E_3_PLATE L16908;
edge_boolean -coincident_only L16908 L71402 -outside L88866;
edge_expand L88866 -inside_by 0.001 L46224;
select -interact L16908 L46224 L70795;
select -interact L71402 L70795 -gt 1 L95392;
edge_boolean -coincident_only L95392 m6m7v6 -outside L33457;
edge_expand L33457 -inside_by 0.001 L32366;
select -interact m6m7v6 L32366 via6_e_3;

// rule_VIA6_E_3=via6_e_3 enclose < 2 Via6
select -enclose via6_e_3 Via6 -ge 2 L28663;
select -interact -not via6_e_3 L28663 rule_VIA6_E_3;

// via7_e_3=m7m8v7 butt (((m7m8v7 drcSep2All <= 3.0 rule_VIA7_E_3_PLATE ) and ( Metal7
//  or Metal8)) butt > 1 ( rule_VIA7_E_3_PLATE or m7m8v7))
exte m7m8v7 rule_VIA7_E_3_PLATE -le 3.0 -output region L96401;
or Metal7 Metal8 L924;
and L924 L96401 L5972;
or m7m8v7 rule_VIA7_E_3_PLATE L28400;
edge_boolean -coincident_only L28400 L5972 -outside L87131;
edge_expand L87131 -inside_by 0.001 L59624;
select -interact L28400 L59624 L20027;
select -interact L5972 L20027 -gt 1 L26193;
edge_boolean -coincident_only L26193 m7m8v7 -outside L50045;
edge_expand L50045 -inside_by 0.001 L84206;
select -interact m7m8v7 L84206 via7_e_3;

// rule_VIA7_E_3=via7_e_3 enclose < 2 Via7
select -enclose via7_e_3 Via7 -ge 2 L59159;
select -interact -not via7_e_3 L59159 rule_VIA7_E_3;

// via8_e_3=m8m9v8 butt (((m8m9v8 drcSep2All <= 3.0 rule_VIA8_E_3_PLATE ) and ( Metal8
//  or Metal9)) butt > 1 ( rule_VIA8_E_3_PLATE or m8m9v8))
exte m8m9v8 rule_VIA8_E_3_PLATE -le 3.0 -output region L28947;
or Metal8 Metal9 L9412;
and L28947 L9412 L74245;
or m8m9v8 rule_VIA8_E_3_PLATE L93588;
edge_boolean -coincident_only L93588 L74245 -outside L81251;
edge_expand L81251 -inside_by 0.001 L34227;
select -interact L93588 L34227 L85158;
select -interact L74245 L85158 -gt 1 L89061;
edge_boolean -coincident_only L89061 m8m9v8 -outside L37117;
edge_expand L37117 -inside_by 0.001 L64149;
select -interact m8m9v8 L64149 via8_e_3;

// rule_VIA8_E_3=via8_e_3 enclose < 2 Via8
select -enclose via8_e_3 Via8 -ge 2 L89655;
select -interact -not via8_e_3 L89655 rule_VIA8_E_3;

// bondpad_metal1=(Metal1 and (( ( ( ( ( fill Metal1 ) enclose Bondpad ) downUp 25.0
//  ) and ( fill Metal1 ) ) enclose Bondpad )))
and Metal1 bondpad_metal1_filled bondpad_metal1;

// bondpad_metal1_slot=holes bondpad_metal1
holes bondpad_metal1 L16219;
not L16219 bondpad_metal1 bondpad_metal1_slot;

// bondpad_metal1_slot_on_edge=(bondpad_metal1_slot buttOnly == 1 ( bondpad_metal1_slot
//  drcSep <= 2.5 ))
exte bondpad_metal1_slot bondpad_metal1_slot -le 2.5 -metric opposite -para only -notch not -output region L51557;
select -touch bondpad_metal1_slot L51557 -eq 1 bondpad_metal1_slot_on_edge;

// rule_BONDPAD_SP_5_metal1=(( bondpad_metal1_slot drcSep <= 2.5 ) andnot ( bondpad_metal1_slot
//  drcSep == 1.5 ))
exte bondpad_metal1_slot bondpad_metal1_slot -eq 1.5 -metric opposite -para only -notch not -output region L74117;
not L51557 L74117 rule_BONDPAD_SP_5_metal1;

// rule_BONDPAD_W_4_metal1=(( bondpad_metal1_slot andnot ( bondpad_metal1_slot drcWidth
//  == 1.0 ) ) andnot bondpad_metal1_slot_on_edge)
inte bondpad_metal1_slot bondpad_metal1_slot -eq 1.0 -metric opposite -para only -output region L23896;
not bondpad_metal1_slot L23896 L22008;
not L22008 bondpad_metal1_slot_on_edge rule_BONDPAD_W_4_metal1;

// bondpad_metal2=(Metal2 and (( ( ( ( ( fill Metal2 ) enclose Bondpad ) downUp 25.0
//  ) and ( fill Metal2 ) ) enclose Bondpad )))
and Metal2 bondpad_metal2_filled bondpad_metal2;

// bondpad_metal2_slot=holes bondpad_metal2
holes bondpad_metal2 L16220;
not L16220 bondpad_metal2 bondpad_metal2_slot;

// bondpad_metal2_slot_on_edge=(bondpad_metal2_slot buttOnly == 1 ( bondpad_metal2_slot
//  drcSep <= 2.5 ))
exte bondpad_metal2_slot bondpad_metal2_slot -le 2.5 -metric opposite -para only -notch not -output region L34276;
select -touch bondpad_metal2_slot L34276 -eq 1 bondpad_metal2_slot_on_edge;

// rule_BONDPAD_R_1_via1=(( ( bondpad_metal1 and bondpad_metal2 ) enclose Via1 ) enclose
//  < 16 Via1)
and bondpad_metal1 bondpad_metal2 L27416;
select -enclose L27416 Via1 L39318;
select -enclose L39318 Via1 -ge 16 L96249;
select -interact -not L39318 L96249 rule_BONDPAD_R_1_via1;

// rule_BONDPAD_SP_5_metal2=(( bondpad_metal2_slot drcSep <= 2.5 ) andnot ( bondpad_metal2_slot
//  drcSep == 1.5 ))
exte bondpad_metal2_slot bondpad_metal2_slot -eq 1.5 -metric opposite -para only -notch not -output region L56836;
not L34276 L56836 rule_BONDPAD_SP_5_metal2;

// rule_BONDPAD_W_4_metal2=(( bondpad_metal2_slot andnot ( bondpad_metal2_slot drcWidth
//  == 1.0 ) ) andnot bondpad_metal2_slot_on_edge)
inte bondpad_metal2_slot bondpad_metal2_slot -eq 1.0 -metric opposite -para only -output region L41177;
not bondpad_metal2_slot L41177 L44343;
not L44343 bondpad_metal2_slot_on_edge rule_BONDPAD_W_4_metal2;

// bondpad_metal3=(Metal3 and (( ( ( ( ( fill Metal3 ) enclose Bondpad ) downUp 25.0
//  ) and ( fill Metal3 ) ) enclose Bondpad )))
and Metal3 bondpad_metal3_filled bondpad_metal3;

// bondpad_metal3_slot=holes bondpad_metal3
holes bondpad_metal3 L16221;
not L16221 bondpad_metal3 bondpad_metal3_slot;

// bondpad_metal3_slot_on_edge=(bondpad_metal3_slot buttOnly == 1 ( bondpad_metal3_slot
//  drcSep <= 2.5 ))
exte bondpad_metal3_slot bondpad_metal3_slot -le 2.5 -metric opposite -para only -notch not -output region L16995;
select -touch bondpad_metal3_slot L16995 -eq 1 bondpad_metal3_slot_on_edge;

// rule_BONDPAD_R_1_via2=(( ( bondpad_metal2 and bondpad_metal3 ) enclose Via2 ) enclose
//  < 16 Via2)
and bondpad_metal2 bondpad_metal3 L93240;
select -enclose L93240 Via2 L67829;
select -enclose L67829 Via2 -ge 16 L67742;
select -interact -not L67829 L67742 rule_BONDPAD_R_1_via2;

// rule_BONDPAD_SP_5_metal3=(( bondpad_metal3_slot drcSep <= 2.5 ) andnot ( bondpad_metal3_slot
//  drcSep == 1.5 ))
exte bondpad_metal3_slot bondpad_metal3_slot -eq 1.5 -metric opposite -para only -notch not -output region L39555;
not L16995 L39555 rule_BONDPAD_SP_5_metal3;

// rule_BONDPAD_W_4_metal3=(( bondpad_metal3_slot andnot ( bondpad_metal3_slot drcWidth
//  == 1.0 ) ) andnot bondpad_metal3_slot_on_edge)
inte bondpad_metal3_slot bondpad_metal3_slot -eq 1.0 -metric opposite -para only -output region L58458;
not bondpad_metal3_slot L58458 L54826;
not L54826 bondpad_metal3_slot_on_edge rule_BONDPAD_W_4_metal3;

// bondpad_metal4=(Metal4 and (( ( ( ( ( fill Metal4 ) enclose Bondpad ) downUp 25.0
//  ) and ( fill Metal4 ) ) enclose Bondpad )))
and Metal4 bondpad_metal4_filled bondpad_metal4;

// bondpad_metal4_slot=holes bondpad_metal4
holes bondpad_metal4 L16222;
not L16222 bondpad_metal4 bondpad_metal4_slot;

// bondpad_metal4_slot_on_edge=(bondpad_metal4_slot buttOnly == 1 ( bondpad_metal4_slot
//  drcSep <= 2.5 ))
exte bondpad_metal4_slot bondpad_metal4_slot -le 2.5 -metric opposite -para only -notch not -output region L99714;
select -touch bondpad_metal4_slot L99714 -eq 1 bondpad_metal4_slot_on_edge;

// rule_BONDPAD_R_1_via3=(( ( bondpad_metal3 and bondpad_metal4 ) enclose Via3 ) enclose
//  < 16 Via3)
and bondpad_metal3 bondpad_metal4 L59064;
select -enclose L59064 Via3 L64598;
select -enclose L64598 Via3 -ge 16 L50375;
select -interact -not L64598 L50375 rule_BONDPAD_R_1_via3;

// rule_BONDPAD_SP_5_metal4=(( bondpad_metal4_slot drcSep <= 2.5 ) andnot ( bondpad_metal4_slot
//  drcSep == 1.5 ))
exte bondpad_metal4_slot bondpad_metal4_slot -eq 1.5 -metric opposite -para only -notch not -output region L22274;
not L99714 L22274 rule_BONDPAD_SP_5_metal4;

// rule_BONDPAD_W_4_metal4=(( bondpad_metal4_slot andnot ( bondpad_metal4_slot drcWidth
//  == 1.0 ) ) andnot bondpad_metal4_slot_on_edge)
inte bondpad_metal4_slot bondpad_metal4_slot -eq 1.0 -metric opposite -para only -output region L75739;
not bondpad_metal4_slot L75739 L12310;
not L12310 bondpad_metal4_slot_on_edge rule_BONDPAD_W_4_metal4;

// bondpad_metal5=(Metal5 and (( ( ( ( ( fill Metal5 ) enclose Bondpad ) downUp 25.0
//  ) and ( fill Metal5 ) ) enclose Bondpad )))
and Metal5 bondpad_metal5_filled bondpad_metal5;

// bondpad_metal5_slot=holes bondpad_metal5
holes bondpad_metal5 L16223;
not L16223 bondpad_metal5 bondpad_metal5_slot;

// bondpad_metal5_slot_on_edge=(bondpad_metal5_slot buttOnly == 1 ( bondpad_metal5_slot
//  drcSep <= 2.5 ))
exte bondpad_metal5_slot bondpad_metal5_slot -le 2.5 -metric opposite -para only -notch not -output region L82433;
select -touch bondpad_metal5_slot L82433 -eq 1 bondpad_metal5_slot_on_edge;

// rule_BONDPAD_R_1_via4=(( ( bondpad_metal4 and bondpad_metal5 ) enclose Via4 ) enclose
//  < 16 Via4)
and bondpad_metal4 bondpad_metal5 L24888;
select -enclose L24888 Via4 L80299;
select -enclose L80299 Via4 -ge 16 L42372;
select -interact -not L80299 L42372 rule_BONDPAD_R_1_via4;

// rule_BONDPAD_SP_5_metal5=(( bondpad_metal5_slot drcSep <= 2.5 ) andnot ( bondpad_metal5_slot
//  drcSep == 1.5 ))
exte bondpad_metal5_slot bondpad_metal5_slot -eq 1.5 -metric opposite -para only -notch not -output region L4993;
not L82433 L4993 rule_BONDPAD_SP_5_metal5;

// rule_BONDPAD_W_4_metal5=(( bondpad_metal5_slot andnot ( bondpad_metal5_slot drcWidth
//  == 1.0 ) ) andnot bondpad_metal5_slot_on_edge)
inte bondpad_metal5_slot bondpad_metal5_slot -eq 1.0 -metric opposite -para only -output region L93020;
not bondpad_metal5_slot L93020 L89996;
not L89996 bondpad_metal5_slot_on_edge rule_BONDPAD_W_4_metal5;

// bondpad_metal6=(Metal6 and (( ( ( ( ( fill Metal6 ) enclose Bondpad ) downUp 25.0
//  ) and ( fill Metal6 ) ) enclose Bondpad )))
and Metal6 bondpad_metal6_filled bondpad_metal6;

// bondpad_metal6_slot=holes bondpad_metal6
holes bondpad_metal6 L16224;
not L16224 bondpad_metal6 bondpad_metal6_slot;

// bondpad_metal6_slot_on_edge=(bondpad_metal6_slot buttOnly == 1 ( bondpad_metal6_slot
//  drcSep <= 2.5 ))
exte bondpad_metal6_slot bondpad_metal6_slot -le 2.5 -metric opposite -para only -notch not -output region L65152;
select -touch bondpad_metal6_slot L65152 -eq 1 bondpad_metal6_slot_on_edge;

// rule_BONDPAD_R_1_via5=(( ( bondpad_metal5 and bondpad_metal6 ) enclose Via5 ) enclose
//  < 16 Via5)
and bondpad_metal5 bondpad_metal6 L90712;
select -enclose L90712 Via5 L7391;
select -enclose L7391 Via5 -ge 16 L80249;
select -interact -not L7391 L80249 rule_BONDPAD_R_1_via5;

// rule_BONDPAD_SP_5_metal6=(( bondpad_metal6_slot drcSep <= 2.5 ) andnot ( bondpad_metal6_slot
//  drcSep == 1.5 ))
exte bondpad_metal6_slot bondpad_metal6_slot -eq 1.5 -metric opposite -para only -notch not -output region L87712;
not L65152 L87712 rule_BONDPAD_SP_5_metal6;

// rule_BONDPAD_W_4_metal6=(( bondpad_metal6_slot andnot ( bondpad_metal6_slot drcWidth
//  == 1.0 ) ) andnot bondpad_metal6_slot_on_edge)
inte bondpad_metal6_slot bondpad_metal6_slot -eq 1.0 -metric opposite -para only -output region L10301;
not bondpad_metal6_slot L10301 L12270;
not L12270 bondpad_metal6_slot_on_edge rule_BONDPAD_W_4_metal6;

// bondpad_metal7=(Metal7 and (( ( ( ( ( fill Metal7 ) enclose Bondpad ) downUp 25.0
//  ) and ( fill Metal7 ) ) enclose Bondpad )))
and Metal7 bondpad_metal7_filled bondpad_metal7;

// bondpad_metal7_slot=holes bondpad_metal7
holes bondpad_metal7 L16225;
not L16225 bondpad_metal7 bondpad_metal7_slot;

// bondpad_metal7_slot_on_edge=(bondpad_metal7_slot buttOnly == 1 ( bondpad_metal7_slot
//  drcSep <= 2.5 ))
exte bondpad_metal7_slot bondpad_metal7_slot -le 2.5 -metric opposite -para only -notch not -output region L47871;
select -touch bondpad_metal7_slot L47871 -eq 1 bondpad_metal7_slot_on_edge;

// rule_BONDPAD_R_1_via6=(( ( bondpad_metal6 and bondpad_metal7 ) enclose Via6 ) enclose
//  < 16 Via6)
and bondpad_metal6 bondpad_metal7 L43464;
select -enclose L43464 Via6 L77040;
select -enclose L77040 Via6 -ge 16 L45932;
select -interact -not L77040 L45932 rule_BONDPAD_R_1_via6;

// rule_BONDPAD_SP_5_metal7=(( bondpad_metal7_slot drcSep <= 2.5 ) andnot ( bondpad_metal7_slot
//  drcSep == 1.5 ))
exte bondpad_metal7_slot bondpad_metal7_slot -eq 1.5 -metric opposite -para only -notch not -output region L70431;
not L47871 L70431 rule_BONDPAD_SP_5_metal7;

// rule_BONDPAD_W_4_metal7=(( bondpad_metal7_slot andnot ( bondpad_metal7_slot drcWidth
//  == 1.0 ) ) andnot bondpad_metal7_slot_on_edge)
inte bondpad_metal7_slot bondpad_metal7_slot -eq 1.0 -metric opposite -para only -output region L27582;
not bondpad_metal7_slot L27582 L43492;
not L43492 bondpad_metal7_slot_on_edge rule_BONDPAD_W_4_metal7;

// bondpad_metal8=(Metal8 and (( ( ( ( ( fill Metal8 ) enclose Bondpad ) downUp 25.0
//  ) and ( fill Metal8 ) ) enclose Bondpad )))
and Metal8 bondpad_metal8_filled bondpad_metal8;

// bondpad_metal8_slot=holes bondpad_metal8
holes bondpad_metal8 L16226;
not L16226 bondpad_metal8 bondpad_metal8_slot;

// bondpad_metal8_slot_on_edge=(bondpad_metal8_slot buttOnly == 1 ( bondpad_metal8_slot
//  drcSep <= 2.5 ))
exte bondpad_metal8_slot bondpad_metal8_slot -le 2.5 -metric opposite -para only -notch not -output region L30590;
select -touch bondpad_metal8_slot L30590 -eq 1 bondpad_metal8_slot_on_edge;

// rule_BONDPAD_R_2_via7=(( ( bondpad_metal7 and bondpad_metal8 ) enclose Via7 ) enclose
//  < 4 Via7)
and bondpad_metal7 bondpad_metal8 L77640;
select -enclose L77640 Via7 L17326;
select -enclose L17326 Via7 -ge 4 L81353;
select -interact -not L17326 L81353 rule_BONDPAD_R_2_via7;

// rule_BONDPAD_SP_5_metal8=(( bondpad_metal8_slot drcSep <= 2.5 ) andnot ( bondpad_metal8_slot
//  drcSep == 1.5 ))
exte bondpad_metal8_slot bondpad_metal8_slot -eq 1.5 -metric opposite -para only -notch not -output region L53150;
not L30590 L53150 rule_BONDPAD_SP_5_metal8;

// rule_BONDPAD_W_4_metal8=(( bondpad_metal8_slot andnot ( bondpad_metal8_slot drcWidth
//  == 1.0 ) ) andnot bondpad_metal8_slot_on_edge)
inte bondpad_metal8_slot bondpad_metal8_slot -eq 1.0 -metric opposite -para only -output region L44863;
not bondpad_metal8_slot L44863 L976;
not L976 bondpad_metal8_slot_on_edge rule_BONDPAD_W_4_metal8;

// bondpad_metal9=(Metal9 and (( ( ( ( ( fill Metal9 ) enclose Bondpad ) downUp 25.0
//  ) and ( fill Metal9 ) ) enclose Bondpad )))
and Metal9 bondpad_metal9_filled bondpad_metal9;

// bondpad_metal9_slot=holes bondpad_metal9
holes bondpad_metal9 L16227;
not L16227 bondpad_metal9 bondpad_metal9_slot;

// bondpad_metal9_slot_on_edge=(bondpad_metal9_slot buttOnly == 1 ( bondpad_metal9_slot
//  drcSep <= 2.5 ))
exte bondpad_metal9_slot bondpad_metal9_slot -le 2.5 -metric opposite -para only -notch not -output region L13309;
select -touch bondpad_metal9_slot L13309 -eq 1 bondpad_metal9_slot_on_edge;

// rule_BONDPAD_R_2_via8=(( ( bondpad_metal8 and bondpad_metal9 ) enclose Via8 ) enclose
//  < 4 Via8)
and bondpad_metal8 bondpad_metal9 L11816;
select -enclose L11816 Via8 L73128;
select -enclose L73128 Via8 -ge 4 L90016;
select -interact -not L73128 L90016 rule_BONDPAD_R_2_via8;

// rule_BONDPAD_SP_5_metal9=(( bondpad_metal9_slot drcSep <= 2.5 ) andnot ( bondpad_metal9_slot
//  drcSep == 1.5 ))
exte bondpad_metal9_slot bondpad_metal9_slot -eq 1.5 -metric opposite -para only -notch not -output region L35869;
not L13309 L35869 rule_BONDPAD_SP_5_metal9;

// rule_BONDPAD_W_4_metal9=(( bondpad_metal9_slot andnot ( bondpad_metal9_slot drcWidth
//  == 1.0 ) ) andnot bondpad_metal9_slot_on_edge)
inte bondpad_metal9_slot bondpad_metal9_slot -eq 1.0 -metric opposite -para only -output region L62144;
not bondpad_metal9_slot L62144 L78641;
not L78641 bondpad_metal9_slot_on_edge rule_BONDPAD_W_4_metal9;

// bondpad_metal10=(Metal10 and (( ( ( ( ( fill Metal10 ) enclose Bondpad ) downUp 25.0
//  ) and ( fill Metal10 ) ) enclose Bondpad )))
and Metal10 bondpad_metal10_filled bondpad_metal10;

// bondpad_metal10_slot=holes bondpad_metal10
holes bondpad_metal10 L35415;
not L35415 bondpad_metal10 bondpad_metal10_slot;

// bondpad_metal10_slot_on_edge=(bondpad_metal10_slot buttOnly == 1 ( bondpad_metal10_slot
//  drcSep <= 2.5 ))
exte bondpad_metal10_slot bondpad_metal10_slot -le 2.5 -metric opposite -para only -notch not -output region L59435;
select -touch bondpad_metal10_slot L59435 -eq 1 bondpad_metal10_slot_on_edge;

// rule_BONDPAD_R_2_via9=(( ( bondpad_metal9 and bondpad_metal10 ) enclose Via9 ) enclose
//  < 4 Via9)
and bondpad_metal10 bondpad_metal9 L54131;
select -enclose L54131 Via9 L14166;
select -enclose L14166 Via9 -ge 4 L5806;
select -interact -not L14166 L5806 rule_BONDPAD_R_2_via9;

// rule_BONDPAD_SP_5_metal10=(( bondpad_metal10_slot drcSep <= 2.5 ) andnot ( bondpad_metal10_slot
//  drcSep == 1.5 ))
exte bondpad_metal10_slot bondpad_metal10_slot -eq 1.5 -metric opposite -para only -notch not -output region L36875;
not L59435 L36875 rule_BONDPAD_SP_5_metal10;

// rule_BONDPAD_W_4_metal10=(( bondpad_metal10_slot andnot ( bondpad_metal10_slot drcWidth
//  == 1.0 ) ) andnot bondpad_metal10_slot_on_edge)
inte bondpad_metal10_slot bondpad_metal10_slot -eq 1.0 -metric opposite -para only -output region L69464;
not bondpad_metal10_slot L69464 L75577;
not L75577 bondpad_metal10_slot_on_edge rule_BONDPAD_W_4_metal10;

// bondpad_metal11=(Metal11 and (( ( ( ( ( fill Metal11 ) enclose Bondpad ) downUp 25.0
//  ) and ( fill Metal11 ) ) enclose Bondpad )))
and Metal11 bondpad_metal11_filled bondpad_metal11;

// rule_BONDPAD_R_2_via10=(( ( bondpad_metal10 and bondpad_metal11 ) enclose Via10 )
//  enclose < 4 Via10)
and bondpad_metal10 bondpad_metal11 L62394;
select -enclose L62394 Via10 L57756;
select -enclose L57756 Via10 -ge 4 L99952;
select -interact -not L57756 L99952 rule_BONDPAD_R_2_via10;

// rule_OXIDE_L_1_L_2=((Oxide andnot (Cont sizeWithin 6.0 0.1 Oxide)) interact (Oxide
//  andnot (Oxide downUp 0.09))) buttOnly (Cont sizeWithin 6.0 0.1 Oxide)
size Cont -by 6.0 -inside_of Oxide -step 0.1 L25906;
not Oxide L25906 L94579;
size Oxide -by 0.09 -underover L39287;
not Oxide L39287 L30786;
select -interact L94579 L30786 L83634;
select -touch L83634 L25906 rule_OXIDE_L_1_L_2;

// rule_BONDPAD_W_5_metal1=(( ( ( bondpad_metal1_filled size -25.0 ) size 20.0 ) growEdges
//  5.0 ) outside ( ( bondpad_metal1_filled andnot ( bondpad_metal1_slot or ( bondpad_metal1_slot
//  drcSep <= 10.0 ) ) ) drcWidth == 5.0 ))
size bondpad_metal1_filled -by -25.0 L95323;
size L95323 -by 20.0 L90795;
edge_expand L90795 -outside_by 5.0 L19940;
exte bondpad_metal1_slot bondpad_metal1_slot -le 10.0 -metric opposite -para only -notch not -output region L97067;
or L97067 bondpad_metal1_slot L52936;
not bondpad_metal1_filled L52936 L47599;
inte L47599 L47599 -eq 5.0 -metric opposite -para only -output region L53804;
select -outside L19940 L53804 rule_BONDPAD_W_5_metal1;

// rule_BONDPAD_W_5_metal2=(( ( ( bondpad_metal2_filled size -25.0 ) size 20.0 ) growEdges
//  5.0 ) outside ( ( bondpad_metal2_filled andnot ( bondpad_metal2_slot or ( bondpad_metal2_slot
//  drcSep <= 10.0 ) ) ) drcWidth == 5.0 ))
size bondpad_metal2_filled -by -25.0 L36698;
size L36698 -by 20.0 L3707;
edge_expand L3707 -outside_by 5.0 L74735;
exte bondpad_metal2_slot bondpad_metal2_slot -le 10.0 -metric opposite -para only -notch not -output region L74;
or L74 bondpad_metal2_slot L81007;
not bondpad_metal2_filled L81007 L35857;
inte L35857 L35857 -eq 5.0 -metric opposite -para only -output region L45326;
select -outside L74735 L45326 rule_BONDPAD_W_5_metal2;

// rule_BONDPAD_W_5_metal3=(( ( ( bondpad_metal3_filled size -25.0 ) size 20.0 ) growEdges
//  5.0 ) outside ( ( bondpad_metal3_filled andnot ( bondpad_metal3_slot or ( bondpad_metal3_slot
//  drcSep <= 10.0 ) ) ) drcWidth == 5.0 ))
size bondpad_metal3_filled -by -25.0 L21927;
size L21927 -by 20.0 L31022;
edge_expand L31022 -outside_by 5.0 L77926;
exte bondpad_metal3_slot bondpad_metal3_slot -le 10.0 -metric opposite -para only -notch not -output region L64215;
or L64215 bondpad_metal3_slot L98923;
not bondpad_metal3_filled L98923 L56717;
inte L56717 L56717 -eq 5.0 -metric opposite -para only -output region L53462;
select -outside L77926 L53462 rule_BONDPAD_W_5_metal3;

// rule_BONDPAD_W_5_metal4=(( ( ( bondpad_metal4_filled size -25.0 ) size 20.0 ) growEdges
//  5.0 ) outside ( ( bondpad_metal4_filled andnot ( bondpad_metal4_slot or ( bondpad_metal4_slot
//  drcSep <= 10.0 ) ) ) drcWidth == 5.0 ))
size bondpad_metal4_filled -by -25.0 L80552;
size L80552 -by 20.0 L95699;
edge_expand L95699 -outside_by 5.0 L27426;
exte bondpad_metal4_slot bondpad_metal4_slot -le 10.0 -metric opposite -para only -notch not -output region L61208;
or L61208 bondpad_metal4_slot L90065;
not bondpad_metal4_filled L90065 L61675;
inte L61675 L61675 -eq 5.0 -metric opposite -para only -output region L23149;
select -outside L27426 L23149 rule_BONDPAD_W_5_metal4;

// rule_BONDPAD_W_5_metal5=(( ( ( bondpad_metal5_filled size -25.0 ) size 20.0 ) growEdges
//  5.0 ) outside ( ( bondpad_metal5_filled andnot ( bondpad_metal5_slot or ( bondpad_metal5_slot
//  drcSep <= 10.0 ) ) ) drcWidth == 5.0 ))
size bondpad_metal5_filled -by -25.0 L39177;
size L39177 -by 20.0 L21314;
edge_expand L21314 -outside_by 5.0 L61825;
exte bondpad_metal5_slot bondpad_metal5_slot -le 10.0 -metric opposite -para only -notch not -output region L58201;
or L58201 bondpad_metal5_slot L24897;
not bondpad_metal5_filled L24897 L91512;
inte L91512 L91512 -eq 5.0 -metric opposite -para only -output region L26632;
select -outside L61825 L26632 rule_BONDPAD_W_5_metal5;

// rule_BONDPAD_W_5_metal6=(( ( ( bondpad_metal6_filled size -25.0 ) size 20.0 ) growEdges
//  5.0 ) outside ( ( bondpad_metal6_filled andnot ( bondpad_metal6_slot or ( bondpad_metal6_slot
//  drcSep <= 10.0 ) ) ) drcWidth == 5.0 ))
size bondpad_metal6_filled -by -25.0 L97802;
size L97802 -by 20.0 L15441;
edge_expand L15441 -outside_by 5.0 L19957;
exte bondpad_metal6_slot bondpad_metal6_slot -le 10.0 -metric opposite -para only -notch not -output region L55194;
or L55194 bondpad_metal6_slot L74852;
not bondpad_metal6_filled L74852 L77773;
inte L77773 L77773 -eq 5.0 -metric opposite -para only -output region L17229;
select -outside L19957 L17229 rule_BONDPAD_W_5_metal6;

// rule_BONDPAD_W_5_metal7=(( ( ( bondpad_metal7_filled size -25.0 ) size 20.0 ) growEdges
//  5.0 ) outside ( ( bondpad_metal7_filled andnot ( bondpad_metal7_slot or ( bondpad_metal7_slot
//  drcSep <= 10.0 ) ) ) drcWidth == 5.0 ))
size bondpad_metal7_filled -by -25.0 L10869;
size L10869 -by 20.0 L5615;
edge_expand L5615 -outside_by 5.0 L24363;
exte bondpad_metal7_slot bondpad_metal7_slot -le 10.0 -metric opposite -para only -notch not -output region L52187;
or L52187 bondpad_metal7_slot L83586;
not bondpad_metal7_filled L83586 L20526;
inte L20526 L20526 -eq 5.0 -metric opposite -para only -output region L2261;
select -outside L24363 L2261 rule_BONDPAD_W_5_metal7;

// rule_BONDPAD_W_5_metal8=(( ( ( bondpad_metal8_filled size -25.0 ) size 20.0 ) growEdges
//  5.0 ) outside ( ( bondpad_metal8_filled andnot ( bondpad_metal8_slot or ( bondpad_metal8_slot
//  drcSep <= 10.0 ) ) ) drcWidth == 5.0 ))
size bondpad_metal8_filled -by -25.0 L52244;
size L52244 -by 20.0 L85496;
edge_expand L85496 -outside_by 5.0 L3964;
exte bondpad_metal8_slot bondpad_metal8_slot -le 10.0 -metric opposite -para only -notch not -output region L49180;
or L49180 bondpad_metal8_slot L18418;
not bondpad_metal8_filled L18418 L11829;
inte L11829 L11829 -eq 5.0 -metric opposite -para only -output region L12231;
select -outside L3964 L12231 rule_BONDPAD_W_5_metal8;

// rule_BONDPAD_W_5_metal9=(( ( ( bondpad_metal9_filled size -25.0 ) size 20.0 ) growEdges
//  5.0 ) outside ( ( bondpad_metal9_filled andnot ( bondpad_metal9_slot or ( bondpad_metal9_slot
//  drcSep <= 10.0 ) ) ) drcWidth == 5.0 ))
size bondpad_metal9_filled -by -25.0 L93619;
size L93619 -by 20.0 L53065;
edge_expand L53065 -outside_by 5.0 L79015;
exte bondpad_metal9_slot bondpad_metal9_slot -le 10.0 -metric opposite -para only -notch not -output region L46173;
or L46173 bondpad_metal9_slot L9560;
not bondpad_metal9_filled L9560 L46654;
inte L46654 L46654 -eq 5.0 -metric opposite -para only -output region L54989;
select -outside L79015 L54989 rule_BONDPAD_W_5_metal9;

// rule_BONDPAD_W_5_metal10=(( ( ( bondpad_metal10_filled size -25.0 ) size 20.0 ) growEdges
//  5.0 ) outside ( ( bondpad_metal10_filled andnot ( bondpad_metal10_slot or ( bondpad_metal10_slot
//  drcSep <= 10.0 ) ) ) drcWidth == 5.0 ))
size bondpad_metal10_filled -by -25.0 L22427;
size L22427 -by 20.0 L40524;
edge_expand L40524 -outside_by 5.0 L22723;
exte bondpad_metal10_slot bondpad_metal10_slot -le 10.0 -metric opposite -para only -notch not -output region L97563;
or L97563 bondpad_metal10_slot L62913;
not bondpad_metal10_filled L62913 L90437;
inte L90437 L90437 -eq 5.0 -metric opposite -para only -output region L45819;
select -outside L22723 L45819 rule_BONDPAD_W_5_metal10;

// rule_VIA1_X_2=(( ( Metal1 and Metal2 ) enclose via1_x_2 ) outside ( ( ( via1_x_2
//  size 0.15 ) and ( Metal1 and Metal2 ) ) enclose > 3 via1_x_2 ) outside ( ( ( via1_x_2
//  size 0.30 ) and ( Metal1 and Metal2 ) ) enclose > 8 via1_x_2 ))
select -enclose L38712 via1_x_2 L8073;
size via1_x_2 -by 0.15 L62796;
and L38712 L62796 L3292;
select -enclose L3292 via1_x_2 -gt 3 L84071;
select -outside L8073 L84071 L71267;
size via1_x_2 -by 0.30 L62739;
and L38712 L62739 L3109;
select -enclose L3109 via1_x_2 -gt 8 L29299;
select -outside L71267 L29299 rule_VIA1_X_2;

// rule_VIA2_X_2=(( ( Metal2 and Metal3 ) enclose via2_x_2 ) outside ( ( ( via2_x_2
//  size 0.15 ) and ( Metal2 and Metal3 ) ) enclose > 3 via2_x_2 ) outside ( ( ( via2_x_2
//  size 0.30 ) and ( Metal2 and Metal3 ) ) enclose > 8 via2_x_2 ))
select -enclose L18248 via2_x_2 L18588;
size via2_x_2 -by 0.15 L90995;
and L18248 L90995 L49606;
select -enclose L49606 via2_x_2 -gt 3 L66271;
select -outside L18588 L66271 L89859;
size via2_x_2 -by 0.30 L91052;
and L18248 L91052 L70621;
select -enclose L70621 via2_x_2 -gt 8 L66389;
select -outside L89859 L66389 rule_VIA2_X_2;

// rule_VIA3_X_2=(( ( Metal3 and Metal4 ) enclose via3_x_2 ) outside ( ( ( via3_x_2
//  size 0.15 ) and ( Metal3 and Metal4 ) ) enclose > 3 via3_x_2 ) outside ( ( ( via3_x_2
//  size 0.30 ) and ( Metal3 and Metal4 ) ) enclose > 8 via3_x_2 ))
select -enclose L92088 via3_x_2 L45131;
size via3_x_2 -by 0.15 L77490;
and L77490 L92088 L64637;
select -enclose L64637 via3_x_2 -gt 3 L11835;
select -outside L45131 L11835 L17874;
size via3_x_2 -by 0.30 L77547;
and L77547 L92088 L97334;
select -enclose L97334 via3_x_2 -gt 8 L31676;
select -outside L17874 L31676 rule_VIA3_X_2;

// rule_VIA4_X_2=(( ( Metal4 and Metal5 ) enclose via4_x_2 ) outside ( ( ( via4_x_2
//  size 0.15 ) and ( Metal4 and Metal5 ) ) enclose > 3 via4_x_2 ) outside ( ( ( via4_x_2
//  size 0.30 ) and ( Metal4 and Metal5 ) ) enclose > 8 via4_x_2 ))
select -enclose L2424 via4_x_2 L91763;
size via4_x_2 -by 0.15 L63985;
and L2424 L63985 L2406;
select -enclose L2406 via4_x_2 -gt 3 L1562;
select -outside L91763 L1562 L98807;
size via4_x_2 -by 0.30 L64042;
and L2424 L64042 L23421;
select -enclose L23421 via4_x_2 -gt 8 L65761;
select -outside L98807 L65761 rule_VIA4_X_2;

// rule_VIA5_X_2=(( ( Metal5 and Metal6 ) enclose via5_x_2 ) outside ( ( ( via5_x_2
//  size 0.15 ) and ( Metal5 and Metal6 ) ) enclose > 3 via5_x_2 ) outside ( ( ( via5_x_2
//  size 0.30 ) and ( Metal5 and Metal6 ) ) enclose > 8 via5_x_2 ))
select -enclose L54536 via5_x_2 L74091;
size via5_x_2 -by 0.15 L50480;
and L50480 L54536 L47841;
select -enclose L47841 via5_x_2 -gt 3 L17351;
select -outside L74091 L17351 L12707;
size via5_x_2 -by 0.30 L50537;
and L50537 L54536 L53166;
select -enclose L53166 via5_x_2 -gt 8 L35999;
select -outside L12707 L35999 rule_VIA5_X_2;

// rule_VIA6_X_2=(( ( Metal6 and Metal7 ) enclose via6_x_2 ) outside ( ( ( via6_x_2
//  size 0.15 ) and ( Metal6 and Metal7 ) ) enclose > 3 via6_x_2 ) outside ( ( ( via6_x_2
//  size 0.30 ) and ( Metal6 and Metal7 ) ) enclose > 8 via6_x_2 ))
select -enclose L55800 via6_x_2 L62391;
size via6_x_2 -by 0.15 L36975;
and L36975 L55800 L17051;
select -enclose L17051 via6_x_2 -gt 3 L59980;
select -outside L62391 L59980 L15581;
size via6_x_2 -by 0.30 L37032;
and L37032 L55800 L93212;
select -enclose L93212 via6_x_2 -gt 8 L40196;
select -outside L15581 L40196 rule_VIA6_X_2;

// rule_VIA7_X_2=(( ( Metal7 and Metal8 ) enclose via7_x_2 ) outside ( ( ( via7_x_2
//  size 0.15 ) and ( Metal7 and Metal8 ) ) enclose > 3 via7_x_2 ) outside ( ( ( via7_x_2
//  size 0.30 ) and ( Metal7 and Metal8 ) ) enclose > 8 via7_x_2 ))
select -enclose L1160 via7_x_2 L66944;
size via7_x_2 -by 0.15 L23470;
and L1160 L23470 L29245;
select -enclose L29245 via7_x_2 -gt 3 L94577;
select -outside L66944 L94577 L75238;
size via7_x_2 -by 0.30 L23527;
and L1160 L23527 L28432;
select -enclose L28432 via7_x_2 -gt 8 L32727;
select -outside L75238 L32727 rule_VIA7_X_2;

// rule_VIA8_X_2=(( ( Metal8 and Metal9 ) enclose via8_x_2 ) outside ( ( ( via8_x_2
//  size 0.15 ) and ( Metal8 and Metal9 ) ) enclose > 3 via8_x_2 ) outside ( ( ( via8_x_2
//  size 0.30 ) and ( Metal8 and Metal9 ) ) enclose > 8 via8_x_2 ))
select -enclose L9176 via8_x_2 L34724;
size via8_x_2 -by 0.15 L9965;
and L9176 L9965 L72731;
select -enclose L72731 via8_x_2 -gt 3 L85854;
select -outside L34724 L85854 L59769;
size via8_x_2 -by 0.30 L10022;
and L10022 L9176 L98961;
select -enclose L98961 via8_x_2 -gt 8 L27934;
select -outside L59769 L27934 rule_VIA8_X_2;

// rule_VIA1_X_1=(( ( Metal1 and Metal2 ) enclose via1_x_1 ) outside ( ( ( via1_x_1
//  size 0.15 ) and ( Metal1 and Metal2 ) ) enclose > 1 via1_x_1 ) outside ( ( ( via1_x_1
//  size 0.30 ) and ( Metal1 and Metal2 ) ) enclose > 3 via1_x_1 )) andnot rule_VIA1_X_2
select -enclose L38712 via1_x_1 L8074;
size via1_x_1 -by 0.15 L91947;
and L38712 L91947 L45832;
select -enclose L45832 via1_x_1 -gt 1 L70080;
select -outside L8074 L70080 L96413;
size via1_x_1 -by 0.30 L91890;
and L38712 L91890 L45019;
select -enclose L45019 via1_x_1 -gt 3 L53699;
select -outside L96413 L53699 L53828;
not L53828 rule_VIA1_X_2 rule_VIA1_X_1;

// rule_VIA2_X_1=(( ( Metal2 and Metal3 ) enclose via2_x_1 ) outside ( ( ( via2_x_1
//  size 0.15 ) and ( Metal2 and Metal3 ) ) enclose > 1 via2_x_1 ) outside ( ( ( via2_x_1
//  size 0.30 ) and ( Metal2 and Metal3 ) ) enclose > 3 via2_x_1 )) andnot rule_VIA2_X_2
select -enclose L18248 via2_x_1 L18587;
size via2_x_1 -by 0.15 L61844;
and L18248 L61844 L7717;
select -enclose L7717 via2_x_1 -gt 1 L38181;
select -outside L18587 L38181 L67613;
size via2_x_1 -by 0.30 L61901;
and L18248 L61901 L8551;
select -enclose L8551 via2_x_1 -gt 3 L51226;
select -outside L67613 L51226 L36344;
not L36344 rule_VIA2_X_2 rule_VIA2_X_1;

// rule_VIA3_X_1=(( ( Metal3 and Metal4 ) enclose via3_x_1 ) outside ( ( ( via3_x_1
//  size 0.15 ) and ( Metal3 and Metal4 ) ) enclose > 1 via3_x_1 ) outside ( ( ( via3_x_1
//  size 0.30 ) and ( Metal3 and Metal4 ) ) enclose > 3 via3_x_1 )) andnot rule_VIA3_X_2
select -enclose L92088 via3_x_1 L45132;
size via3_x_1 -by 0.15 L48339;
and L48339 L92088 L32665;
select -enclose L32665 via3_x_1 -gt 1 L4930;
select -outside L45132 L4930 L84908;
size via3_x_1 -by 0.30 L48396;
and L48396 L92088 L44066;
select -enclose L44066 via3_x_1 -gt 3 L42854;
select -outside L84908 L42854 L59033;
not L59033 rule_VIA3_X_2 rule_VIA3_X_1;

// rule_VIA4_X_1=(( ( Metal4 and Metal5 ) enclose via4_x_1 ) outside ( ( ( via4_x_1
//  size 0.15 ) and ( Metal4 and Metal5 ) ) enclose > 1 via4_x_1 ) outside ( ( ( via4_x_1
//  size 0.30 ) and ( Metal4 and Metal5 ) ) enclose > 3 via4_x_1 )) andnot rule_VIA4_X_2
select -enclose L2424 via4_x_1 L91762;
size via4_x_1 -by 0.15 L34834;
and L2424 L34834 L60517;
select -enclose L60517 via4_x_1 -gt 1 L96440;
select -outside L91762 L96440 L31171;
size via4_x_1 -by 0.30 L34891;
and L2424 L34891 L60700;
select -enclose L60700 via4_x_1 -gt 3 L80442;
select -outside L31171 L80442 L53778;
not L53778 rule_VIA4_X_2 rule_VIA4_X_1;

// rule_VIA5_X_1=(( ( Metal5 and Metal6 ) enclose via5_x_1 ) outside ( ( ( via5_x_1
//  size 0.15 ) and ( Metal5 and Metal6 ) ) enclose > 1 via5_x_1 ) outside ( ( ( via5_x_1
//  size 0.30 ) and ( Metal5 and Metal6 ) ) enclose > 3 via5_x_1 )) andnot rule_VIA5_X_2
select -enclose L54536 via5_x_1 L74092;
size via5_x_1 -by 0.15 L21329;
and L21329 L54536 L17835;
select -enclose L17835 via5_x_1 -gt 1 L62342;
select -outside L74092 L62342 L75634;
size via5_x_1 -by 0.30 L21386;
and L21386 L54536 L6434;
select -enclose L6434 via5_x_1 -gt 3 L39709;
select -outside L75634 L39709 L46534;
not L46534 rule_VIA5_X_2 rule_VIA5_X_1;

// rule_VIA6_X_1=(( ( Metal6 and Metal7 ) enclose via6_x_1 ) outside ( ( ( via6_x_1
//  size 0.15 ) and ( Metal6 and Metal7 ) ) enclose > 1 via6_x_1 ) outside ( ( ( via6_x_1
//  size 0.30 ) and ( Metal6 and Metal7 ) ) enclose > 3 via6_x_1 )) andnot rule_VIA6_X_2
select -enclose L55800 via6_x_1 L62390;
size via6_x_1 -by 0.15 L7824;
and L55800 L7824 L86972;
select -enclose L86972 via6_x_1 -gt 1 L41787;
select -outside L62390 L41787 L89680;
size via6_x_1 -by 0.30 L7881;
and L55800 L7881 L86789;
select -enclose L86789 via6_x_1 -gt 3 L25793;
select -outside L89680 L25793 L95770;
not L95770 rule_VIA6_X_2 rule_VIA6_X_1;

// rule_VIA7_X_1=(( ( Metal7 and Metal8 ) enclose via7_x_1 ) outside ( ( ( via7_x_1
//  size 0.15 ) and ( Metal7 and Metal8 ) ) enclose > 1 via7_x_1 ) outside ( ( ( via7_x_1
//  size 0.30 ) and ( Metal7 and Metal8 ) ) enclose > 3 via7_x_1 )) andnot rule_VIA7_X_2
select -enclose L1160 via7_x_1 L66945;
size via7_x_1 -by 0.15 L94319;
and L1160 L94319 L35945;
select -enclose L35945 via7_x_1 -gt 1 L71964;
select -outside L66945 L71964 L14328;
size via7_x_1 -by 0.30 L94384;
and L1160 L94384 L35733;
select -enclose L35733 via7_x_1 -gt 3 L32987;
select -outside L14328 L32987 L70360;
not L70360 rule_VIA7_X_2 rule_VIA7_X_1;

// rule_VIA8_X_1=(( ( Metal8 and Metal9 ) enclose via8_x_1 ) outside ( ( ( via8_x_1
//  size 0.15 ) and ( Metal8 and Metal9 ) ) enclose > 1 via8_x_1 ) outside ( ( ( via8_x_1
//  size 0.30 ) and ( Metal8 and Metal9 ) ) enclose > 3 via8_x_1 )) andnot rule_VIA8_X_2
select -enclose L9176 via8_x_1 L34723;
size via8_x_1 -by 0.15 L80814;
and L80814 L9176 L4547;
select -enclose L4547 via8_x_1 -gt 1 L11363;
select -outside L34723 L11363 L58690;
size via8_x_1 -by 0.30 L80871;
and L80871 L9176 L79078;
select -enclose L79078 via8_x_1 -gt 3 L32204;
select -outside L58690 L32204 L17966;
not L17966 rule_VIA8_X_2 rule_VIA8_X_1;

// rule_BONDPAD_B_1_m1=( (( ( ( ( ( fill Metal1 ) enclose Bondpad ) downUp 25.0 ) and
//  ( fill Metal1 ) ) enclose Bondpad )) andnot ( (( ( ( ( ( fill Metal1 ) enclose Bondpad
//  ) downUp 25.0 ) and ( fill Metal1 ) ) enclose Bondpad )) drcSep <= 40.0 ) ) vertex
//  < 8
exte bondpad_metal1_filled bondpad_metal1_filled -le 40.0 -metric opposite -para only -notch not -output region L75346;
not bondpad_metal1_filled L75346 L78279;
vertex L78279 -lt 8 rule_BONDPAD_B_1_m1;

// rule_BONDPAD_B_1_m2=( (( ( ( ( ( fill Metal2 ) enclose Bondpad ) downUp 25.0 ) and
//  ( fill Metal2 ) ) enclose Bondpad )) andnot ( (( ( ( ( ( fill Metal2 ) enclose Bondpad
//  ) downUp 25.0 ) and ( fill Metal2 ) ) enclose Bondpad )) drcSep <= 40.0 ) ) vertex
//  < 8
exte bondpad_metal2_filled bondpad_metal2_filled -le 40.0 -metric opposite -para only -notch not -output region L76463;
not bondpad_metal2_filled L76463 L6397;
vertex L6397 -lt 8 rule_BONDPAD_B_1_m2;

// rule_BONDPAD_B_1_m3=( (( ( ( ( ( fill Metal3 ) enclose Bondpad ) downUp 25.0 ) and
//  ( fill Metal3 ) ) enclose Bondpad )) andnot ( (( ( ( ( ( fill Metal3 ) enclose Bondpad
//  ) downUp 25.0 ) and ( fill Metal3 ) ) enclose Bondpad )) drcSep <= 40.0 ) ) vertex
//  < 8
exte bondpad_metal3_filled bondpad_metal3_filled -le 40.0 -metric opposite -para only -notch not -output region L28272;
not bondpad_metal3_filled L28272 L85497;
vertex L85497 -lt 8 rule_BONDPAD_B_1_m3;

// rule_BONDPAD_B_1_m4=( (( ( ( ( ( fill Metal4 ) enclose Bondpad ) downUp 25.0 ) and
//  ( fill Metal4 ) ) enclose Bondpad )) andnot ( (( ( ( ( ( fill Metal4 ) enclose Bondpad
//  ) downUp 25.0 ) and ( fill Metal4 ) ) enclose Bondpad )) drcSep <= 40.0 ) ) vertex
//  < 8
exte bondpad_metal4_filled bondpad_metal4_filled -le 40.0 -metric opposite -para only -notch not -output region L87215;
not bondpad_metal4_filled L87215 L48458;
vertex L48458 -lt 8 rule_BONDPAD_B_1_m4;

// rule_BONDPAD_B_1_m5=( (( ( ( ( ( fill Metal5 ) enclose Bondpad ) downUp 25.0 ) and
//  ( fill Metal5 ) ) enclose Bondpad )) andnot ( (( ( ( ( ( fill Metal5 ) enclose Bondpad
//  ) downUp 25.0 ) and ( fill Metal5 ) ) enclose Bondpad )) drcSep <= 40.0 ) ) vertex
//  < 8
exte bondpad_metal5_filled bondpad_metal5_filled -le 40.0 -metric opposite -para only -notch not -output region L64594;
not bondpad_metal5_filled L64594 L314;
vertex L314 -lt 8 rule_BONDPAD_B_1_m5;

// rule_BONDPAD_B_1_m6=( (( ( ( ( ( fill Metal6 ) enclose Bondpad ) downUp 25.0 ) and
//  ( fill Metal6 ) ) enclose Bondpad )) andnot ( (( ( ( ( ( fill Metal6 ) enclose Bondpad
//  ) downUp 25.0 ) and ( fill Metal6 ) ) enclose Bondpad )) drcSep <= 40.0 ) ) vertex
//  < 8
exte bondpad_metal6_filled bondpad_metal6_filled -le 40.0 -metric opposite -para only -notch not -output region L50893;
not bondpad_metal6_filled L50893 L11692;
vertex L11692 -lt 8 rule_BONDPAD_B_1_m6;

// rule_BONDPAD_B_1_m7=( (( ( ( ( ( fill Metal7 ) enclose Bondpad ) downUp 25.0 ) and
//  ( fill Metal7 ) ) enclose Bondpad )) andnot ( (( ( ( ( ( fill Metal7 ) enclose Bondpad
//  ) downUp 25.0 ) and ( fill Metal7 ) ) enclose Bondpad )) drcSep <= 40.0 ) ) vertex
//  < 8
exte bondpad_metal7_filled bondpad_metal7_filled -le 40.0 -metric opposite -para only -notch not -output region L99084;
not bondpad_metal7_filled L99084 L17986;
vertex L17986 -lt 8 rule_BONDPAD_B_1_m7;

// rule_BONDPAD_B_1_m8=( (( ( ( ( ( fill Metal8 ) enclose Bondpad ) downUp 25.0 ) and
//  ( fill Metal8 ) ) enclose Bondpad )) andnot ( (( ( ( ( ( fill Metal8 ) enclose Bondpad
//  ) downUp 25.0 ) and ( fill Metal8 ) ) enclose Bondpad )) drcSep <= 40.0 ) ) vertex
//  < 8
exte bondpad_metal8_filled bondpad_metal8_filled -le 40.0 -metric opposite -para only -notch not -output region L52725;
not bondpad_metal8_filled L52725 L93580;
vertex L93580 -lt 8 rule_BONDPAD_B_1_m8;

// rule_BONDPAD_B_1_m9=( (( ( ( ( ( fill Metal9 ) enclose Bondpad ) downUp 25.0 ) and
//  ( fill Metal9 ) ) enclose Bondpad )) andnot ( (( ( ( ( ( fill Metal9 ) enclose Bondpad
//  ) downUp 25.0 ) and ( fill Metal9 ) ) enclose Bondpad )) drcSep <= 40.0 ) ) vertex
//  < 8
exte bondpad_metal9_filled bondpad_metal9_filled -le 40.0 -metric opposite -para only -notch not -output region L62762;
not bondpad_metal9_filled L62762 L81871;
vertex L81871 -lt 8 rule_BONDPAD_B_1_m9;

// rule_BONDPAD_B_1_m10=( (( ( ( ( ( fill Metal10 ) enclose Bondpad ) downUp 25.0 )
//  and ( fill Metal10 ) ) enclose Bondpad )) andnot ( (( ( ( ( ( fill Metal10 ) enclose
//  Bondpad ) downUp 25.0 ) and ( fill Metal10 ) ) enclose Bondpad )) drcSep <= 40.0
//  ) ) vertex < 8
exte bondpad_metal10_filled bondpad_metal10_filled -le 40.0 -metric opposite -para only -notch not -output region L10594;
not bondpad_metal10_filled L10594 L9655;
vertex L9655 -lt 8 rule_BONDPAD_B_1_m10;

// rule_BONDPAD_B_1_m11=( (( ( ( ( ( fill Metal11 ) enclose Bondpad ) downUp 25.0 )
//  and ( fill Metal11 ) ) enclose Bondpad )) andnot ( (( ( ( ( ( fill Metal11 ) enclose
//  Bondpad ) downUp 25.0 ) and ( fill Metal11 ) ) enclose Bondpad )) drcSep <= 40.0
//  ) ) vertex < 8
exte bondpad_metal11_filled bondpad_metal11_filled -le 40.0 -metric opposite -para only -notch not -output region L58785;
not bondpad_metal11_filled L58785 L71528;
vertex L71528 -lt 8 rule_BONDPAD_B_1_m11;

connect Bondpad metal11_conn -by bp_tap;
connect metal11_conn CapMetal -by via10_cap;
connect metal11_conn metal10_conn -by via10_nocap;
connect metal10_conn metal9_conn -by Via9;
connect metal9_conn metal8_conn -by Via8;
connect metal8_conn metal7_conn -by Via7;
connect metal7_conn metal6_conn -by Via6;
connect metal6_conn metal5_conn -by Via5;
connect metal5_conn metal4_conn -by Via4;
connect metal4_conn metal3_conn -by Via3;
connect metal3_conn metal2_conn -by Via2;
connect metal2_conn metal1_conn -by Via1;
connect metal1_conn poly_conn -by cont_poly;
connect metal1_conn pdiff_conn -by cont_pdiff;
connect metal1_conn npn_emit -by cont_ndiff;
connect metal1_conn ndiff_conn -by cont_ndiff;

sconnect pdiff_conn ptap;
rule soft_check_1 {
    caption soft_check_1: pdiff_conn causing multiple stamped connections to ptap;
    exte pdiff_conn ptap -eq 0 -inside_also -not_connected -output region;
}
rule soft_check_2 {
    caption soft_check_2: ptap has multiple stamped connections from pdiff_conn;
    select -interact ptap pdiff_conn -gt 1 -by_net;
}
rule soft_check_3 {
    caption soft_check_3: ptap missing stamped connections from pdiff_conn;
    select -interact -not ptap pdiff_conn;
}

sconnect ptap psubstrate;
rule soft_check_4 {
    caption soft_check_4: ptap causing multiple stamped connections to psubstrate;
    exte ptap psubstrate -eq 0 -inside_also -not_connected -output region;
}
rule soft_check_5 {
    caption soft_check_5: psubstrate has multiple stamped connections from ptap;
    select -interact psubstrate ptap -gt 1 -by_net;
}
rule soft_check_6 {
    caption soft_check_6: psubstrate missing stamped connections from ptap;
    select -interact -not psubstrate ptap;
}

sconnect ndiff_conn ntap;
rule soft_check_7 {
    caption soft_check_7: ndiff_conn causing multiple stamped connections to ntap;
    exte ndiff_conn ntap -eq 0 -inside_also -not_connected -output region;
}
rule soft_check_8 {
    caption soft_check_8: ntap has multiple stamped connections from ndiff_conn;
    select -interact ntap ndiff_conn -gt 1 -by_net;
}
rule soft_check_9 {
    caption soft_check_9: ntap missing stamped connections from ndiff_conn;
    select -interact -not ntap ndiff_conn;
}

sconnect ntap nwell_conn;
rule soft_check_10 {
    caption soft_check_10: ntap causing multiple stamped connections to nwell_conn;
    exte ntap nwell_conn -eq 0 -inside_also -not_connected -output region;
}
rule soft_check_11 {
    caption soft_check_11: nwell_conn has multiple stamped connections from ntap;
    select -interact nwell_conn ntap -gt 1 -by_net;
}
rule soft_check_12 {
    caption soft_check_12: nwell_conn missing stamped connections from ntap;
    select -interact -not nwell_conn ntap;
}

sconnect nwell_conn nb_tap;
rule soft_check_13 {
    caption soft_check_13: nwell_conn causing multiple stamped connections to nb_tap;
    exte nwell_conn nb_tap -eq 0 -inside_also -not_connected -output region;
}
rule soft_check_14 {
    caption soft_check_14: nb_tap has multiple stamped connections from nwell_conn;
    select -interact nb_tap nwell_conn -gt 1 -by_net;
}
rule soft_check_15 {
    caption soft_check_15: nb_tap missing stamped connections from nwell_conn;
    select -interact -not nb_tap nwell_conn;
}

sconnect nb_tap Nburied;
rule soft_check_16 {
    caption soft_check_16: nb_tap causing multiple stamped connections to Nburied;
    exte nb_tap Nburied -eq 0 -inside_also -not_connected -output region;
}
rule soft_check_17 {
    caption soft_check_17: Nburied has multiple stamped connections from nb_tap;
    select -interact Nburied nb_tap -gt 1 -by_net;
}
rule soft_check_18 {
    caption soft_check_18: Nburied missing stamped connections from nb_tap;
    select -interact -not Nburied nb_tap;
}

attach metal11_conn_text metal11_conn;
attach metal10_conn_text metal10_conn;
attach metal9_conn_text metal9_conn;
attach metal8_conn_text metal8_conn;
attach metal7_conn_text metal7_conn;
attach metal6_conn_text metal6_conn;
attach metal5_conn_text metal5_conn;
attach metal4_conn_text metal4_conn;
attach metal3_conn_text metal3_conn;
attach metal2_conn_text metal2_conn;
attach metal1_conn_text metal1_conn;
attach poly_conn_text poly_conn;


// nmos_io_esd=ndiff_conn buttOnly (Poly buttOnly (ndiff_conn connect Bondpad))
antenna ndiff_conn Bondpad -gt 0 L80382;
select -touch Poly L80382 L73764;
select -touch ndiff_conn L73764 nmos_io_esd;

// pmos_io_esd=pdiff_conn buttOnly (Poly buttOnly (pdiff_conn connect Bondpad))
antenna pdiff_conn Bondpad -gt 0 L64324;
select -touch Poly L64324 L1826;
select -touch pdiff_conn L1826 pmos_io_esd;

// rule_ESD_4_nmos=(nsd_esd buttOnly == 1 Poly) andnot ((ndiff_conn connect Bondpad)
//  or (ndiff_conn connect psubstrate))
select -touch nsd_esd Poly -eq 1 L78152;
antenna ndiff_conn psubstrate -gt 0 L10595;
or L10595 L80382 L87558;
not L78152 L87558 rule_ESD_4_nmos;

// rule_ESD_4_pmos=(psd_esd buttOnly == 1 Poly) andnot ((pdiff_conn connect Bondpad)
//  or (pdiff_conn connect nwell_conn ))
select -touch psd_esd Poly -eq 1 L90202;
antenna pdiff_conn nwell_conn -gt 0 L65219;
or L64324 L65219 L40217;
not L90202 L40217 rule_ESD_4_pmos;

// rule_ESD_8_nmos=((nsd_esd buttOnly == 2 Poly) andnot ((ndiff_conn connect Bondpad)
//  or (ndiff_conn connect psubstrate))) outside SiProt
select -touch nsd_esd Poly -eq 2 L78153;
not L78153 L87558 L40153;
select -outside L40153 SiProt rule_ESD_8_nmos;

// rule_ESD_8_pmos=((psd_esd buttOnly == 2 Poly) andnot ((pdiff_conn connect Bondpad)
//  or (pdiff_conn connect psubstrate))) outside SiProt
select -touch psd_esd Poly -eq 2 L90201;
antenna pdiff_conn psubstrate -gt 0 L12421;
or L12421 L64324 L42888;
not L90201 L42888 L65050;
select -outside L65050 SiProt rule_ESD_8_pmos;


// width check for Nburied <0.8 
rule NBL.W.1 {
    caption NBL.W.1: Minimum Nburied Width >= 0.8 um;
    inte Nburied Nburied -lt 0.8 -output region -singular -abut lt 90;
}



// enclose check for Nwell inside Nburied <0.2 
rule NBL.E.1 {
    caption NBL.E.1: Minimum Nburied to Nwell enclosure >= 0.2 um;
// output shapes that intersect
    select -cut Nwell Nburied L99284;
    not L99284 Nburied;
    enc Nwell Nburied -lt 0.2 -output region -singular -abut lt 90;
}


// spacing check for Nburied <2.0 
rule NBL.SP.1 {
    caption NBL.SP.1: Minimum Nburied to Nburied spacing >= 2.0 um;
    exte Nburied Nburied -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Nburied and Nwell <2.2 
rule NBL.SE.1 {
    caption NBL.SE.1: Minimum Nburied to non-related Nwell spacing >= 2.2 um;
// output parts of shapes that intersect
    select -cut Nburied Nwell L27316;
    Select -cut Nwell Nburied L90252;
    and L27316 L90252;
    exte Nburied Nwell -lt 2.2 -output region -singular -abut lt 90
}



// spacing check for Nburied and Oxide <1.2 
rule NBL.SE.2 {
    caption NBL.SE.2: Minimum Nburied to non-related Oxide spacing >= 1.2 um;
// output parts of shapes that intersect
    select -cut Nburied Oxide L70415;
    Select -cut Oxide Nburied L80783;
    and L70415 L80783;
    exte Nburied Oxide -lt 1.2 -output region -singular -abut lt 90
}


// data on layer rule_NBL_X_1 is always an error

rule NBL.X.1 {
    caption NBL.X.1: Nburied must have an Nwell isolation ring;
    copy rule_NBL_X_1;
}

// building polygons for layer Oxide
// inside layers Pimp Nburied
and Nburied Pimp L76974;
and L76974 Oxide L50485;

// building polygons for layer (Nwell)
// inside layer Nburied
// L90546 = holes Nwell
// L90545 = not L90546 Nwell
and L90545 Nburied L92339;

// enclose check for L50485 inside L92339 <0.09 
rule NBL.SE.3 {
    caption NBL.SE.3: Minimum Nwell ring (on Nburied) to P+ Active spacing >= 0.09 um;
// output shapes that intersect
    select -cut L50485 L92339 L68349;
    not L68349 L92339;
    enc L50485 L92339 -lt 0.09 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layers Nimp Nburied
and Nburied Nimp L17392;
and L17392 Oxide L18556;

// building polygons for layer (Nwell)
// inside layer Nburied
// L90546 = holes Nwell
// L90545 = not L90546 Nwell
// L92339 = and L90545 Nburied

// enclose check for L18556 inside L92339 <0.09 
rule NBL.SE.4 {
    caption NBL.SE.4: Minimum Nwell ring (on Nburied) to N+ Active spacing >= 0.09 um;
// output shapes that intersect
    select -cut L18556 L92339 L15286;
    not L15286 L92339;
    enc L18556 L92339 -lt 0.09 -output region -singular -abut lt 90;
}


// spacing check for nwell_conn <0.3  sameNet
rule NW.SP.1 {
    caption NW.SP.1: Minimum Nwell spacing to Nwell (same potential) >= 0.3 um;
    exte nwell_conn nwell_conn -lt 0.3 -output region -connected -singular -abut lt 90;
}



// spacing check for nwell_conn and nwellres <0.6  buttingOK
rule NW.SP.2 {
    caption NW.SP.2: Minimum Nwell spacing to Nwell (different potential) >= 0.6 um;
// output parts of shapes that intersect
    select -cut nwell_conn nwellres L84526;
    Select -cut nwellres nwell_conn L68740;
    and L84526 L68740;
    exte nwell_conn nwellres -lt 0.6 -output region -singular -abut ltgt 0 90
}


// spacing check for nwellres <0.6 
rule NW.SP.2_2 {
    caption NW.SP.2: Minimum Nwell spacing to Nwell (different potential) >= 0.6 um;
    exte nwellres nwellres -lt 0.6 -output region -singular -abut lt 90;
}


// width check for Nwell <0.3 
rule NW.W.1 {
    caption NW.W.1: Minimum Nwell Width >= 0.3 um;
    inte Nwell Nwell -lt 0.3 -output region -singular -abut lt 90;
}


// spacing check for nwell_conn <0.6  diffNet
rule NW.SP.2_3 {
    caption NW.SP.2: Minimum Nwell spacing to Nwell (different potential) >= 0.6 um;
    exte nwell_conn nwell_conn -lt 0.6 -output region -not_connected -singular -notch not;
}


// building polygons for layer Oxide
// inside layer Pimp
// pactive = and Oxide Pimp

// spacing check for Nwell and pactive <0.16 
rule NW.SE.2 {
    caption NW.SE.2: Minimum Nwell spacing to P+ Active Area >= 0.16 um;
// output parts of shapes that intersect
    select -cut Nwell pactive L37621;
    Select -cut pactive Nwell L46539;
    and L37621 L46539;
    exte Nwell pactive -lt 0.16 -output region -singular -abut lt 90
}

// building polygons for layer Nwell
// inside layer !nwell_in_od_res
not Nwell nwell_in_od_res L66724;

// building polygons for layer Oxide
// inside layer Nimp
// nactive = and Nimp Oxide

// spacing check for L66724 and nactive <0.16 
rule NW.SE.1 {
    caption NW.SE.1: Minimum Nwell spacing to N+ Active Area >= 0.16 um;
// output parts of shapes that intersect
    select -cut L66724 nactive L71704;
    Select -cut nactive L66724 L46976;
    and L71704 L46976;
    exte L66724 nactive -lt 0.16 -output region -singular -abut lt 90
}


// building polygons for layer Oxide
// inside layers Nimp Oxide_thk
and Nimp Oxide_thk L512;
and L512 Oxide L40980;

// spacing check for Nwell and L40980 <0.24 
rule NW.SE.3 {
    caption NW.SE.3: Minimum Nwell spacing to N+ 1.8V Active Area >= 0.24 um;
// output parts of shapes that intersect
    select -cut Nwell L40980 L98636;
    Select -cut L40980 Nwell L92116;
    and L98636 L92116;
    exte Nwell L40980 -lt 0.24 -output region -singular -abut lt 90
}


// building polygons for layer Oxide
// inside layers Oxide_thk Pimp
and Oxide_thk Pimp L4884;
and L4884 Oxide L13412;

// spacing check for Nwell and L13412 <0.24 
rule NW.SE.4 {
    caption NW.SE.4: Minimum Nwell spacing to P+ 1.8V Active Area >= 0.24 um;
// output parts of shapes that intersect
    select -cut Nwell L13412 L84846;
    Select -cut L13412 Nwell L38518;
    and L84846 L38518;
    exte Nwell L13412 -lt 0.24 -output region -singular -abut lt 90
}

// building polygons for layer Oxide
// inside layers Nimp !nwell_in_od_res
not Nimp nwell_in_od_res L72408;
and L72408 Oxide L48097;

// building polygons for layer Nwell
// inside layer !nwell_in_od_res
// L66724 = not Nwell nwell_in_od_res

// enclose check for L48097 inside L66724 <0.06 
rule NW.E.1 {
    caption NW.E.1: Minimum Nwell enclosure of N+ Active Area >= 0.06 um;
// output shapes that intersect
    select -cut L48097 L66724 L87416;
    not L87416 L66724;
    enc L48097 L66724 -lt 0.06 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layer Pimp
// pactive = and Oxide Pimp


// enclose check for pactive inside Nwell <0.06 
rule NW.E.2 {
    caption NW.E.2: Minimum Nwell enclosure of P+ Active Area >= 0.06 um;
// output shapes that intersect
    select -cut pactive Nwell L42997;
    not L42997 Nwell;
    enc pactive Nwell -lt 0.06 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layers Nimp Oxide_thk
// L512 = and Nimp Oxide_thk
// L40980 = and L512 Oxide


// enclose check for L40980 inside Nwell <0.24  shielded
rule NW.E.3 {
    caption NW.E.3: Minimum Nwell enclosure of N+ 1.8V Active Area >= 0.24 um;
// output shapes that intersect
    select -cut L40980 Nwell L59084;
    not L59084 Nwell;
    enc L40980 Nwell -lt 0.24 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layers Oxide_thk Pimp
// L4884 = and Oxide_thk Pimp
// L13412 = and L4884 Oxide


// enclose check for L13412 inside Nwell <0.24  shielded
rule NW.E.4 {
    caption NW.E.4: Minimum Nwell enclosure of P+ 1.8V Active Area >= 0.24 um;
// output shapes that intersect
    select -cut L13412 Nwell L12682;
    not L12682 Nwell;
    enc L13412 Nwell -lt 0.24 -output region -singular -abut lt 90;
}


// area check for Nwell <0.18 
rule NW.A.1 {
    caption NW.A.1: Minimum Nwell area >= 0.18 um;
    area Nwell -lt 0.18;
}

// L90546 = holes Nwell
// L90545 = not L90546 Nwell

// area check for L90545 <0.18 
rule NW.EA.1 {
    caption NW.EA.1: Minimum Nwell enclosed area >= 0.18 um;
    area L90545 -lt 0.18;
}



// spacing check for SiProt and nwell_in_od_res <0.16  overlapOK
rule NWR.SE.1 {
    caption NWR.SE.1: Minimum Resist Protect Oxide to Nwell spacing >= 0.16 um;
    exte SiProt nwell_in_od_res -lt 0.16 -output region -singular -abut lt 90
}



// enclose check for nwell_in_od_res inside Oxide <0.6  overlapOK
rule NWR.E.1 {
    caption NWR.E.1: Minimum Active Area to Nwell (in resistor) enclosure >= 0.6 um;
    enc nwell_in_od_res Oxide -lt 0.6 -output region -singular -abut lt 90;
}



// enclose check for Cont inside nwell_in_od_res <0.16 
rule NWR.E.2 {
    caption NWR.E.2: Minimum salicided Nwell to Contact enclosure >= 0.16 um;
// output shapes that intersect
    select -cut Cont nwell_in_od_res L61306;
    not L61306 nwell_in_od_res;
    enc Cont nwell_in_od_res -lt 0.16 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide_thk
// inside layer nwell_in_od_res
and Oxide_thk nwell_in_od_res L48131;

// data on layer L48131 is always an error
// building polygons for layer Oxide_thk
// inside layer nwell_in_od_res
// L48131 = and Oxide_thk nwell_in_od_res

rule NWR.X.1 {
    caption NWR.X.1: Thick Oxide is NOT allowed over Nwell resistor;
    copy L48131;
}

// building polygons for layer Nimp
// inside layer Nwell
edge_boolean -inside Nimp Nwell L26283;

// building polygons for layer SiProt
// inside layer Nwell
edge_boolean -inside SiProt Nwell L62966;

// overlap check for L26283 and L62966 <0.22 
rule NWR.O.1 {
    caption NWR.O.1: Minimum N+ Implant to Resist Protect Oxide overlap >= 0.22 um;
    inte L26283 L62966 -lt 0.22 -output region -abut lt 90;
}


// width check for Oxide <0.05 
rule OXIDE.W.1 {
    caption OXIDE.W.1: Minimum Active Area width >= 0.05 um;
    inte Oxide Oxide -lt 0.05 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layers !Oxide_thk Nimp Poly
and Nimp Poly L30789;
not L30789 Oxide_thk L71851;
edge_boolean -inside Oxide L71851 L7166;

// width check for L7166 <0.12 
rule OXIDE.W.2.1.1 {
    caption OXIDE.W.2.1.1: Minimum 1.1V N-channel gate width >= 0.12 um;
    inte L7166 L7166 -lt 0.12 -output region -abut lt 90;
}

// building polygons for layer Oxide
// inside layers Nimp Oxide_thk Poly
// L512 = and Nimp Oxide_thk
and L512 Poly L94841;
edge_boolean -inside Oxide L94841 L43550;

// width check for L43550 <0.32 
rule OXIDE.W.2.1.2 {
    caption OXIDE.W.2.1.2: Minimum 1.8V N-channel gate width >= 0.32 um;
    inte L43550 L43550 -lt 0.32 -output region -abut lt 90;
}

// building polygons for layer Oxide
// inside layers !Oxide_thk Pimp Poly
and Pimp Poly L78137;
not L78137 Oxide_thk L6254;
edge_boolean -inside Oxide L6254 L47177;

// width check for L47177 <0.12 
rule OXIDE.W.2.2.1 {
    caption OXIDE.W.2.2.1: Minimum 1.1V P-channel gate width >= 0.12 um;
    inte L47177 L47177 -lt 0.12 -output region -abut lt 90;
}

// building polygons for layer Oxide
// inside layers Oxide_thk Pimp Poly
// L4884 = and Oxide_thk Pimp
and L4884 Poly L54679;
edge_boolean -inside Oxide L54679 L47645;

// width check for L47645 <0.32 
rule OXIDE.W.2.2.2 {
    caption OXIDE.W.2.2.2: Minimum 1.8V P-channel gate width >= 0.32 um;
    inte L47645 L47645 -lt 0.32 -output region -abut lt 90;
}

// building polygons for layer Oxide
// with angle !=90
angle Oxide -ltgt 0 90 L19535;

// width check for L19535 <0.06 
rule OXIDE.W.3 {
    caption OXIDE.W.3: Minimum Active Area bent 45 degress width >= 0.06 um;
    inte L19535 L19535 -lt 0.06 -output region -abut lt 90;
}

// building polygons for layer Oxide
// inside layer Nimp
// nactive = and Nimp Oxide

// spacing check for nactive <0.08 
rule OXIDE.SP.1 {
    caption OXIDE.SP.1: Minimum N+ Active Area to N+ Active Area spacing >= 0.08 um;
    exte nactive nactive -lt 0.08 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layer Pimp
// pactive = and Oxide Pimp

// spacing check for pactive <0.08 
rule OXIDE.SP.2 {
    caption OXIDE.SP.2: Minimum P+ Active Area to P+ Active Area spacing >= 0.08 um;
    exte pactive pactive -lt 0.08 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layer Nimp
edge_boolean -inside Oxide Nimp L95182;

// building polygons for layer Oxide
// inside layer Pimp
edge_boolean -inside Oxide Pimp L54764;

// spacing check for L95182 and L54764 <0.1 
rule OXIDE.SP.3 {
    caption OXIDE.SP.3: Minimum N+ Active Area to P+ Active Area spacing >= 0.1 um;
    exte L95182 L54764 -lt 0.1 -output region -abut ltgt 0 90
}



// spacing check for Oxide and Oxide_thk <0.18  overlapOK shielded
rule OXIDE.SE.1 {
    caption OXIDE.SE.1: Minimum Active Area to Thick Active Area spacing >= 0.18 um;
    exte Oxide Oxide_thk -lt 0.18 -output region -singular -abut lt 90
}


// building polygons for layer Oxide
// with angle !=90
// L19535 = angle Oxide -ltgt 0 90

// spacing check for Oxide and L19535 <0.1 
rule OXIDE.SP.4 {
    caption OXIDE.SP.4: Minimum Active Area bent 45 degress to Active Area spacing >= 0.1 um;
    exte Oxide L19535 -lt 0.1 -output region -abut ltgt 0 90
}


// area check for Oxide <0.035 
rule OXIDE.A.1 {
    caption OXIDE.A.1: Minimum area for Active Area >= 0.035 um;
    area Oxide -lt 0.035;
}

holes Oxide L33644;
not L33644 Oxide L65624;

// area check for L65624 <0.04 
rule OXIDE.EA.1 {
    caption OXIDE.EA.1: Minimum Active Area enclosed area >= 0.04 um;
    area L65624 -lt 0.04;
}


// data on layer rule_OXIDE_L_1_L_2 is always an error

rule OXIDE.L.1_OXIDE.L.2 {
    caption OXIDE.L.1_OXIDE.L.2: Maximum Oxide length between two contacts (when the Oxide width is <= 0.18um) must be <= 22.0um and Maximum Oxide length between one contact and the end of the Oxide line (when the Oxide width is <= 0.18um) must be <= 11.0um;
    copy rule_OXIDE_L_1_L_2;
}

// building polygons for layer Oxide
// inside layers !Nimp !Nzvt !Pimp !SiProt
or Nimp Nzvt L70159;
or L70159 Pimp L66257;
or L66257 SiProt L23048;
not Oxide L23048 L12243;

// data on layer L12243 is always an error
// building polygons for layer Oxide
// inside layers !Nimp !Nzvt !Pimp !SiProt
// L70159 = or Nimp Nzvt
// L66257 = or L70159 Pimp
// L23048 = or L66257 SiProt
// L12243 = not Oxide L23048

rule OXIDE.X.1 {
    caption OXIDE.X.1: Oxide must be covered by Nimp or Pimp or Nzvt;
    copy L12243;
}



// spacing check for Nimp and oxide_in_res <0.16 
rule OXIDER.SE.2 {
    caption OXIDER.SE.2: Minimum Active Resistor to N+ or P+ Implant spacing >= 0.16 um;
// output parts of shapes that intersect
    select -cut Nimp oxide_in_res L10785;
    Select -cut oxide_in_res Nimp L93677;
    and L10785 L93677;
    exte Nimp oxide_in_res -lt 0.16 -output region -singular -abut lt 90
}



// spacing check for Pimp and oxide_in_res <0.16 
rule OXIDER.SE.2_2 {
    caption OXIDER.SE.2: Minimum Active Resistor to N+ or P+ Implant spacing >= 0.16 um;
// output parts of shapes that intersect
    select -cut Pimp oxide_in_res L8609;
    Select -cut oxide_in_res Pimp L34095;
    and L8609 L34095;
    exte Pimp oxide_in_res -lt 0.16 -output region -singular -abut lt 90
}



// enclose check for oxide_in_res inside SiProt <0.12  overlapOK
rule OXIDER.E.1 {
    caption OXIDER.E.1: Minimum Salicide Block to Active Resistor enclosure >= 0.12 um;
    enc oxide_in_res SiProt -lt 0.12 -output region -singular -abut lt 90;
}

// building polygons for layer oxide_in_res
// inside layers !Nimp !Pimp
or Nimp Pimp L13121;
not oxide_in_res L13121 L23345;

// data on layer L23345 is always an error
// building polygons for layer oxide_in_res
// inside layers !Nimp !Pimp
// L13121 = or Nimp Pimp
// L23345 = not oxide_in_res L13121

rule OXIDER.X.1 {
    caption OXIDER.X.1: Oxide resistors must have N+ or P+ Implant;
    copy L23345;
}


// width check for Oxide_thk <0.35 
rule OXIDETHK.W.1 {
    caption OXIDETHK.W.1: Minimum Thick Active Area width >= 0.35 um;
    inte Oxide_thk Oxide_thk -lt 0.35 -output region -singular -abut lt 90;
}


// spacing check for Oxide_thk <0.16 
rule OXIDETHK.SP.1 {
    caption OXIDETHK.SP.1: Minimum Thick Active Area to Thick Active Area spacing >= 0.16 um;
    exte Oxide_thk Oxide_thk -lt 0.16 -output region -singular -abut lt 90;
}


// building polygons for layer Oxide_thk
// with angle !=90
angle Oxide_thk -ltgt 0 90 L59527;

// spacing check for Oxide_thk and L59527 <0.32 
rule OXIDETHK.SP.2 {
    caption OXIDETHK.SP.2: Minimum Thick Active Area bent 45 degrees to Thick Active Area spacing >= 0.32 um;
    exte Oxide_thk L59527 -lt 0.32 -output region -abut ltgt 0 90
}

// building polygons for layer Oxide
// inside layers Nimp Oxide_thk
// L512 = and Nimp Oxide_thk
// L40980 = and L512 Oxide

// spacing check for L40980 <0.1 
rule OXIDETHK.SE.1 {
    caption OXIDETHK.SE.1: Minimum N+ 1.8V Active Area to 1.8V N+ Active Area spacing >= 0.1 um;
    exte L40980 L40980 -lt 0.1 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layers Oxide_thk Pimp
// L4884 = and Oxide_thk Pimp
// L13412 = and L4884 Oxide

// spacing check for L13412 <0.1 
rule OXIDETHK.SE.2 {
    caption OXIDETHK.SE.2: Minimum P+ 1.8V Active Area to 1.8V P+ Active Area spacing >= 0.1 um;
    exte L13412 L13412 -lt 0.1 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layers Nimp Oxide_thk
// L512 = and Nimp Oxide_thk
// L40980 = and L512 Oxide

// building polygons for layer Oxide
// inside layers Oxide_thk Pimp
// L4884 = and Oxide_thk Pimp
// L13412 = and L4884 Oxide

// spacing check for L40980 and L13412 <0.12 
rule OXIDETHK.SE.3 {
    caption OXIDETHK.SE.3: Minimum N+ 1.8V Active Area to 1.8V P+ Active Area spacing >= 0.12 um;
    exte L40980 L13412 -lt 0.12 -output region -singular -abut ltgt 0 90
}



// enclose check for Oxide inside Oxide_thk <0.16  overlapOK
rule OXIDETHK.E.1 {
    caption OXIDETHK.E.1: Minimum Thick Active Area to Active Area enclosure >= 0.16 um;
    enc Oxide Oxide_thk -lt 0.16 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide_thk
// inside layer Oxide
edge_boolean -inside Oxide_thk Oxide L2679;

// building polygons for layer Poly
// inside layer Oxide
edge_boolean -inside Poly Oxide L19486;

// spacing check for L2679 and L19486 <0.18 
rule OXIDETHK.SE.5 {
    caption OXIDETHK.SE.5: Minimum Thick Active Area to 1.1V Poly gate spacing >= 0.18 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L2679 -inside_by 0.001 L63662;
    edge_expand L19486 -inside_by 0.001 L24866;
    and L63662 L24866;
    exte L2679 L19486 -lt 0.18 -output region -abut lt 90
}

// building polygons for layer Poly
// inside layer Oxide
// L19486 = edge_boolean -inside Poly Oxide

// building polygons for layer Oxide_thk
// inside layer Oxide
// L2679 = edge_boolean -inside Oxide_thk Oxide

// enclose check for L19486 inside L2679 <0.18  overlapOK
rule OXIDETHK.E.2 {
    caption OXIDETHK.E.2: Minimum Thick Active Area to Thick Poly gate enclosure >= 0.18 um;
    enc L19486 L2679 -lt 0.18 -output region -abut lt 90;
}


// data on layer rule_NHVT_X_1 is always an error

rule NHVT.X.1 {
    caption NHVT.X.1: Nhvt to Oxide enclosure must be == 0.0 on all sides;
    copy rule_NHVT_X_1;
}

// building polygons for layer Nhvt
// inside layer Nwell
and Nhvt Nwell L89597;

// data on layer L89597 is always an error
// building polygons for layer Nhvt
// inside layer Nwell
// L89597 = and Nhvt Nwell

rule NHVT.X.2 {
    caption NHVT.X.2: Nhvt is NOT allowed on Nwell;
    copy L89597;
}

// building polygons for layer Nhvt
// inside layers Oxide Pimp
// pactive = and Oxide Pimp
and Nhvt pactive L87497;

// data on layer L87497 is always an error
// building polygons for layer Nhvt
// inside layers Oxide Pimp
// pactive = and Oxide Pimp
// L87497 = and Nhvt pactive

rule NHVT.X.3 {
    caption NHVT.X.3: Nhvt is NOT allowed on P+ Oxide;
    copy L87497;
}

// building polygons for layer Nhvt
// inside layer Nzvt
and Nhvt Nzvt L13111;

// data on layer L13111 is always an error
// building polygons for layer Nhvt
// inside layer Nzvt
// L13111 = and Nhvt Nzvt

rule NHVT.X.4 {
    caption NHVT.X.4: Nhvt is NOT allowed on Nzvt;
    copy L13111;
}


// data on layer rule_PHVT_X_1 is always an error

rule PHVT.X.1 {
    caption PHVT.X.1: Phvt to Oxide enclosure must be == 0.0 on all sides;
    copy rule_PHVT_X_1;
}

// building polygons for layer Phvt
// inside layer !Nwell
not Phvt Nwell L88255;

// data on layer L88255 is always an error
// building polygons for layer Phvt
// inside layer !Nwell
// L88255 = not Phvt Nwell

rule PHVT.X.2 {
    caption PHVT.X.2: Phvt is NOT allowed outside Nwell;
    copy L88255;
}

// building polygons for layer Phvt
// inside layers Nimp Oxide
// nactive = and Nimp Oxide
and Phvt nactive L37875;

// data on layer L37875 is always an error
// building polygons for layer Phvt
// inside layers Nimp Oxide
// nactive = and Nimp Oxide
// L37875 = and Phvt nactive

rule PHVT.X.3 {
    caption PHVT.X.3: Phvt is NOT allowed on N+ Oxide;
    copy L37875;
}

// building polygons for layer Phvt
// inside layer Nzvt
and Nzvt Phvt L44131;

// data on layer L44131 is always an error
// building polygons for layer Phvt
// inside layer Nzvt
// L44131 = and Nzvt Phvt

rule PHVT.X.4 {
    caption PHVT.X.4: Phvt is NOT allowed on Nzvt;
    copy L44131;
}


// data on layer rule_NLVT_X_1 is always an error

rule NLVT.X.1 {
    caption NLVT.X.1: Nlvt to Oxide enclosure must be == 0.0 on all sides;
    copy rule_NLVT_X_1;
}

// building polygons for layer Nlvt
// inside layer Nwell
and Nlvt Nwell L60959;

// data on layer L60959 is always an error
// building polygons for layer Nlvt
// inside layer Nwell
// L60959 = and Nlvt Nwell

rule NLVT.X.2 {
    caption NLVT.X.2: Nlvt is NOT allowed on Nwell;
    copy L60959;
}

// building polygons for layer Nlvt
// inside layers Oxide Pimp
// pactive = and Oxide Pimp
and Nlvt pactive L58341;

// data on layer L58341 is always an error
// building polygons for layer Nlvt
// inside layers Oxide Pimp
// pactive = and Oxide Pimp
// L58341 = and Nlvt pactive

rule NLVT.X.3 {
    caption NLVT.X.3: Nlvt is NOT allowed on P+ Oxide;
    copy L58341;
}

// building polygons for layer Nlvt
// inside layer Nzvt
and Nlvt Nzvt L6363;

// data on layer L6363 is always an error
// building polygons for layer Nlvt
// inside layer Nzvt
// L6363 = and Nlvt Nzvt

rule NLVT.X.4 {
    caption NLVT.X.4: Nlvt is NOT allowed on Nzvt;
    copy L6363;
}


// data on layer rule_PLVT_X_1 is always an error

rule PLVT.X.1 {
    caption PLVT.X.1: Plvt to Oxide enclosure must be == 0.0 on all sides;
    copy rule_PLVT_X_1;
}

// building polygons for layer Plvt
// inside layer !Nwell
not Plvt Nwell L62301;

// data on layer L62301 is always an error
// building polygons for layer Plvt
// inside layer !Nwell
// L62301 = not Plvt Nwell

rule PLVT.X.2 {
    caption PLVT.X.2: Plvt is NOT allowed outside Nwell;
    copy L62301;
}

// building polygons for layer Plvt
// inside layers Nimp Oxide
// nactive = and Nimp Oxide
and Plvt nactive L265;

// data on layer L265 is always an error
// building polygons for layer Plvt
// inside layers Nimp Oxide
// nactive = and Nimp Oxide
// L265 = and Plvt nactive

rule PLVT.X.3 {
    caption PLVT.X.3: Plvt is NOT allowed on N+ Oxide;
    copy L265;
}

// building polygons for layer Plvt
// inside layer Nzvt
and Nzvt Plvt L47975;

// data on layer L47975 is always an error
// building polygons for layer Plvt
// inside layer Nzvt
// L47975 = and Nzvt Plvt

rule PLVT.X.4 {
    caption PLVT.X.4: Plvt is NOT allowed on Nzvt;
    copy L47975;
}


// width check for Nzvt <0.35 
rule NZVT.W.1 {
    caption NZVT.W.1: Minimum Nzvt width >= 0.35 um;
    inte Nzvt Nzvt -lt 0.35 -output region -singular -abut lt 90;
}


// spacing check for Nzvt <0.3 
rule NZVT.SP.1 {
    caption NZVT.SP.1: Minimum Nzvt to Nzvt spacing >= 0.3 um;
    exte Nzvt Nzvt -lt 0.3 -output region -singular -abut lt 90;
}


// data on layer rule_NZVT_O_1 is always an error

rule NZVT.O.1 {
    caption NZVT.O.1: Minimum and maximum Nzvt to Active Area overlap == 0.16 um;
    copy rule_NZVT_O_1;
}



// spacing check for Nzvt and Oxide <0.18 
rule NZVT.SE.1 {
    caption NZVT.SE.1: Minimum Nzvt to Active spacing >= 0.18 um;
// output parts of shapes that intersect
    select -cut Nzvt Oxide L17075;
    Select -cut Oxide Nzvt L53744;
    and L17075 L53744;
    exte Nzvt Oxide -lt 0.18 -output region -singular -abut lt 90
}



// spacing check for Nwell and Nzvt <0.6  outsideOnly
rule NZVT.SE.2 {
    caption NZVT.SE.2: Minimum Nzvt to Nwell spacing >= 0.6 um;
    exte Nwell Nzvt -lt 0.6 -output region -singular -abut lt 90 -inside_also
}

// building polygons for layer Oxide
// inside layer Nzvt
and Nzvt Oxide L62764;


// enclose check for L62764 inside Poly <0.1  overlapOK
rule NZVT.E.1 {
    caption NZVT.E.1: Minimum N+ Poly gate end cap to Native Active Area enclosure >= 0.1 um;
    enc L62764 Poly -lt 0.1 -output region -singular -abut lt 90;
}

// building polygons for layer Poly
// inside layers Nzvt Oxide
// L62764 = and Nzvt Oxide
edge_boolean -inside Poly L62764 L55408;

// width check for L55408 <0.30 
rule NZVT.L.1 {
    caption NZVT.L.1: Minimum Native device Poly gate length >= 0.30 um;
    inte L55408 L55408 -lt 0.30 -output region -abut lt 90;
}

// building polygons for layer Oxide
// inside layers Nzvt Poly
and Nzvt Poly L50553;
edge_boolean -inside Oxide L50553 L27452;

// width check for L27452 <0.50 
rule NZVT.W.2 {
    caption NZVT.W.2: Minimum Native device Poly gate width >= 0.50 um;
    inte L27452 L27452 -lt 0.50 -output region -abut lt 90;
}

// building polygons for layer Oxide
// inside layers Nzvt Pimp
and Nzvt Pimp L44809;
and L44809 Oxide L32095;

// data on layer L32095 is always an error
// building polygons for layer Oxide
// inside layers Nzvt Pimp
// L44809 = and Nzvt Pimp
// L32095 = and L44809 Oxide

rule NZVT.X.3 {
    caption NZVT.X.3: P+ Oxide is NOT allowed in Nzvt;
    copy L32095;
}


// data on layer rule_NZVT_X_4 is always an error

rule NZVT.X.4 {
    caption NZVT.X.4: Only one Oxide region may be in an Nzvt region;
    copy rule_NZVT_X_4;
}

// building polygons for layer Poly
// inside layers Nimp Oxide
// nactive = and Nimp Oxide
edge_boolean -inside Poly nactive L78161;

// width check for L78161 <0.045 
rule POLY.W.1 {
    caption POLY.W.1: Minimum 1.1V N-channel gate length >= 0.045 um;
    inte L78161 L78161 -lt 0.045 -output region -abut lt 90;
}

// building polygons for layer Poly
// inside layers Oxide Pimp
// pactive = and Oxide Pimp
edge_boolean -inside Poly pactive L81773;

// width check for L81773 <0.045 
rule POLY.W.2 {
    caption POLY.W.2: Minimum 1.1V P-channel gate length >= 0.045 um;
    inte L81773 L81773 -lt 0.045 -output region -abut lt 90;
}

// building polygons for layer Poly
// inside layers Nimp Oxide Oxide_thk
// nactive = and Nimp Oxide
and Oxide_thk nactive L29500;
edge_boolean -inside Poly L29500 L43067;

// width check for L43067 <0.15 
rule POLY.W.3 {
    caption POLY.W.3: Minimum 1.8V N-channel gate length >= 0.15 um;
    inte L43067 L43067 -lt 0.15 -output region -abut lt 90;
}

// building polygons for layer Poly
// inside layers Oxide Oxide_thk Pimp
and Oxide Oxide_thk L24975;
and L24975 Pimp L93098;
edge_boolean -inside Poly L93098 L61684;

// width check for L61684 <0.15 
rule POLY.W.4 {
    caption POLY.W.4: Minimum 1.8V P-channel gate length >= 0.15 um;
    inte L61684 L61684 -lt 0.15 -output region -abut lt 90;
}

// building polygons for layer Poly
// inside layer !Oxide
edge_boolean -outside Poly Oxide L90757;

// width check for L90757 <0.045 
rule POLY.W.5 {
    caption POLY.W.5: Minimum Poly interconnect width >= 0.045 um;
    inte L90757 L90757 -lt 0.045 -output region -abut lt 90;
}

// building polygons for layer Poly
// inside layer Resdum
edge_boolean -inside Poly Resdum L6655;

// spacing check for L6655 <0.3 
rule POLY.SP.1 {
    caption POLY.SP.1: Minimum Poly resistor space >= 0.3 um;
    exte L6655 L6655 -lt 0.3 -output region -abut lt 90;
}

// building polygons for layer Poly
// inside layer Oxide
// L19486 = edge_boolean -inside Poly Oxide

// spacing check for L19486 <0.06 
rule POLY.SP.2 {
    caption POLY.SP.2: Minimum Poly gate space  >= 0.06 um;
    exte L19486 L19486 -lt 0.06 -output region -abut lt 90;
}

// building polygons for layer Poly
// inside layer !Oxide
// L90757 = edge_boolean -outside Poly Oxide

// spacing check for L90757 <0.06 
rule POLY.SP.3 {
    caption POLY.SP.3: Minimum Poly interconnect space >= 0.06 um;
    exte L90757 L90757 -lt 0.06 -output region -abut lt 90;
}

// building polygons for layer Poly
// inside layers Oxide Oxide_thk
// L24975 = and Oxide Oxide_thk
edge_boolean -inside Poly L24975 L87956;

// spacing check for L87956 <0.20 
rule POLY.SP.4 {
    caption POLY.SP.4: Minimum gate space in thick active >= 0.20 um;
    exte L87956 L87956 -lt 0.20 -output region -abut lt 90;
}

// building polygons for layer gate
// inside layer Nimp
and Nimp gate L2756;


// enclose check for L2756 inside Poly <0.1  coincidentOK
rule POLY.E.1 {
    caption POLY.E.1: Minimum N-channel gate extension beyond Active Area >= 0.1 um;
// output shapes that intersect
    select -cut L2756 Poly L71009;
    not L71009 Poly;
    enc L2756 Poly -lt 0.1 -output region -singular -abut ltgt 0 90;
}

// building polygons for layer gate
// inside layer Pimp
and Pimp gate L6170;


// enclose check for L6170 inside Poly <0.1  coincidentOK
rule POLY.E.2 {
    caption POLY.E.2: Minimum P-channel gate extension beyond Active Area >= 0.1 um;
// output shapes that intersect
    select -cut L6170 Poly L74509;
    not L74509 Poly;
    enc L6170 Poly -lt 0.1 -output region -singular -abut ltgt 0 90;
}



// spacing check for Oxide and Poly <0.05  overlapOK
rule POLY.SE.1_POLY.SE.2 {
    caption POLY.SE.1_POLY.SE.2: Minimum Poly interconnect to related Active Area space >= 0.05 um;
    exte Oxide Poly -lt 0.05 -output region -singular -abut lt 90
}



// enclose check for Poly inside Oxide <0.1  overlapOK shielded
rule POLY.E.3 {
    caption POLY.E.3: Minimum Active Area (source/drain) to gate enclosure >= 0.1 um;
    enc Poly Oxide -lt 0.1 -output region -singular -abut lt 90;
}

// building polygons for layer Poly
// with angle !=90
angle Poly -ltgt 0 90 L92308;

// width check for L92308 <0.1 
rule POLY.W.6 {
    caption POLY.W.6: Minimum bent Poly width >= 0.1 um;
    inte L92308 L92308 -lt 0.1 -output region -abut lt 90;
}

// building polygons for layer Poly
// with angle !=90
// L92308 = angle Poly -ltgt 0 90

// spacing check for L92308 <0.1 
rule POLY.SP.5 {
    caption POLY.SP.5: Minimum bent Poly space >= 0.1 um;
    exte L92308 L92308 -lt 0.1 -output region -abut lt 90;
}

// building polygons for layer Poly
// inside layer Oxide
// L19486 = edge_boolean -inside Poly Oxide

// bends check for L19486 !=0 
rule POLY.X.1 {
    caption POLY.X.1: Poly gate cannot have bends;
    edge_expand L19486 -outside_by 0.001 -corner_fill L60979;
    vertex L60979 -gt 4;
}

// building polygons for layer Poly
// inside layer Resdum
// L6655 = edge_boolean -inside Poly Resdum

// bends check for L6655 !=0 
rule POLY.X.2 {
    caption POLY.X.2: Poly resistor cannot have bends;
    edge_expand L6655 -outside_by 0.001 -corner_fill L45735;
    vertex L45735 -gt 4;
}


// data on layer rule_POLY_SE_3 is always an error

rule POLY.SE.3 {
    caption POLY.SE.3: Maximum Poly segment length (width < 0.14) between two contacts >= 12.0 um;
    copy rule_POLY_SE_3;
}


// area check for Poly <0.02 
rule POLY.A.1 {
    caption POLY.A.1: Minimum area for Poly interconnect >= 0.02 um;
    area Poly -lt 0.02;
}

holes Poly L5639;
not L5639 Poly L42202;

// area check for L42202 <0.05 
rule POLY.EA.1 {
    caption POLY.EA.1: Minimum enclosed area for Poly interconnect >= 0.05 um;
    area L42202 -lt 0.05;
}



// enclose check for poly_in_res inside SiProt <0.14  overlapOK
rule POLYR.E.1 {
    caption POLYR.E.1: Minimum Salicide Block to Poly resistor enclosure >= 0.14 um;
    enc poly_in_res SiProt -lt 0.14 -output region -singular -abut lt 90;
}



// enclose check for poly_in_res inside Nimp <0.07 
rule POLYR.E.2 {
    caption POLYR.E.2: Minimum N+ Implant to Poly used in resistor enclosure >= 0.07 um;
// output shapes that intersect
    select -cut poly_in_res Nimp L51116;
    not L51116 Nimp;
    enc poly_in_res Nimp -lt 0.07 -output region -singular -abut lt 90;
}



// enclose check for poly_in_res inside Pimp <0.07 
rule POLYR.E.3 {
    caption POLYR.E.3: Minimum P+ Implant to Poly used in resistor enclosure >= 0.07 um;
// output shapes that intersect
    select -cut poly_in_res Pimp L10698;
    not L10698 Pimp;
    enc poly_in_res Pimp -lt 0.07 -output region -singular -abut lt 90;
}



// spacing check for Nimp and poly_in_res <0.15 
rule POLYR.SE.2 {
    caption POLYR.SE.2: Minimum Poly resistor to other Implant spacing >= 0.15 um;
// output parts of shapes that intersect
    select -cut Nimp poly_in_res L9602;
    Select -cut poly_in_res Nimp L14036;
    and L9602 L14036;
    exte Nimp poly_in_res -lt 0.15 -output region -singular -abut lt 90
}



// spacing check for Nzvt and poly_in_res <0.15  outsideOnly
rule POLYR.SE.2_2 {
    caption POLYR.SE.2: Minimum Poly resistor to other Implant spacing >= 0.15 um;
    exte Nzvt poly_in_res -lt 0.15 -output region -singular -abut lt 90 -inside_also
}



// spacing check for Pimp and poly_in_res <0.15 
rule POLYR.SE.2_3 {
    caption POLYR.SE.2: Minimum Poly resistor to other Implant spacing >= 0.15 um;
// output parts of shapes that intersect
    select -cut Pimp poly_in_res L89340;
    Select -cut poly_in_res Pimp L54454;
    and L89340 L54454;
    exte Pimp poly_in_res -lt 0.15 -output region -singular -abut lt 90
}

// building polygons for layer poly_in_res
// inside layers !Nimp !Pimp
// L13121 = or Nimp Pimp
not poly_in_res L13121 L83018;

// data on layer L83018 is always an error
// building polygons for layer poly_in_res
// inside layers !Nimp !Pimp
// L13121 = or Nimp Pimp
// L83018 = not poly_in_res L13121

rule POLYR.X.1 {
    caption POLYR.X.1: Poly resistors must have N+ or P+ Implant;
    copy L83018;
}


// width check for Nimp <0.12 
rule NIMP.W.1 {
    caption NIMP.W.1: Minimum N+ Implant width >= 0.12 um;
    inte Nimp Nimp -lt 0.12 -output region -singular -abut lt 90;
}


// spacing check for Nimp <0.12 
rule NIMP.SP.1 {
    caption NIMP.SP.1: Minimum N+ Implant space >= 0.12 um;
    exte Nimp Nimp -lt 0.12 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layer !Nwell
not Oxide Nwell L53776;


// enclose check for L53776 inside Nimp <0.07  overlapOK
rule NIMP.E.1 {
    caption NIMP.E.1: Minimum N+ Implant to Active Area enclosure >= 0.07 um;
    enc L53776 Nimp -lt 0.07 -output region -singular -abut lt 90;
}



// overlap check for Nimp and Oxide <0.08 
rule NIMP.O.1 {
    caption NIMP.O.1: Minimum N+ Implant to Active Area overlap >= 0.08 um;
    inte Nimp Oxide -lt 0.08 -output region -singular -abut lt 90;
}

// building polygons for layer Nimp
// inside layer !Oxide
edge_boolean -outside Nimp Oxide L27059;

// building polygons for layer Oxide
// inside layers Nwell Pimp
and Nwell Pimp L85193;
edge_boolean -inside Oxide L85193 L43250;

// spacing check for L27059 and L43250 <0.08 
rule NIMP.SE.1 {
    caption NIMP.SE.1: Minimum N+ Implant to P+ Active Area (inside Nwell) spacing >= 0.08 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L27059 -inside_by 0.001 L79769;
    edge_expand L43250 -inside_by 0.001 L98970;
    and L79769 L98970;
    exte L27059 L43250 -lt 0.08 -output region -abut lt 90
}

// building polygons for layer Oxide
// inside layer Nwell
and Nwell Oxide L25620;


// enclose check for L25620 inside Nimp <0.01  overlapOK
rule NIMP.E.2 {
    caption NIMP.E.2: Minimum N+ Implant to Active Area (Nwell tie) enclosure >= 0.01 um;
    enc L25620 Nimp -lt 0.01 -output region -singular -abut lt 90;
}

// building polygons for layer Poly
// inside layer Oxide
// L19486 = edge_boolean -inside Poly Oxide

// building polygons for layer Nimp
// inside layer Oxide
edge_boolean -inside Nimp Oxide L83184;

// enclose check for L19486 inside L83184 <0.1  overlapOK
rule NIMP.E.3 {
    caption NIMP.E.3: Minimum N+ Implant to gate side enclosure >= 0.1 um;
    enc L19486 L83184 -lt 0.1 -output region -abut lt 90;
}

// building polygons for layer Oxide
// inside layer Poly
edge_boolean -inside Oxide Poly L60508;


// enclose check for L60508 inside Nimp <0.1 
rule NIMP.E.4 {
    caption NIMP.E.4: Minimum N+ Implant to gate (endcap) enclosure >= 0.1 um;
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L60508 -inside_by 0.001 L23899;
    edge_expand Nimp -outside_by 0.001 L50221;
    and L23899 L50221;
    enc L60508 Nimp -lt 0.1 -output region -abut lt 90;
}

// building polygons for layer Nimp
// inside layers !Nwell !Oxide
or Nwell Oxide L45216;
edge_boolean -outside Nimp L45216 L10142;

// building polygons for layer Oxide
// inside layers Pimp !Nwell
not Pimp Nwell L62533;
edge_boolean -inside Oxide L62533 L10493;

// spacing check for L10142 and L10493 <0.02 
rule NIMP.SE.2 {
    caption NIMP.SE.2: Minimum N+ Implant to P+ Active Area (substrate tie) spacing >= 0.02 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L10142 -inside_by 0.001 L99192;
    edge_expand L10493 -inside_by 0.001 L37895;
    and L99192 L37895;
    exte L10142 L10493 -lt 0.02 -output region -abut lt 90
}


// area check for Nimp <0.018 
rule NIMP.A.1 {
    caption NIMP.A.1: Minimum area for N+ Implant >= 0.018 um;
    area Nimp -lt 0.018;
}

holes Nimp L70965;
not L70965 Nimp L89538;

// area check for L89538 <0.04 
rule NIMP.EA.1 {
    caption NIMP.EA.1: Minimum N+ Implant ring enclosed area  >= 0.04 um;
    area L89538 -lt 0.04;
}

// building polygons for layer Nimp
// inside layer Oxide
// L83184 = edge_boolean -inside Nimp Oxide

// building polygons for layer Poly
// inside layers Oxide Pimp
// pactive = and Oxide Pimp
// L81773 = edge_boolean -inside Poly pactive

// spacing check for L83184 and L81773 <0.1 
rule NIMP.SE.3 {
    caption NIMP.SE.3: Minimum N+ Implant to P+ gate side (butted Implant) spacing >= 0.1 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L83184 -inside_by 0.001 L5098;
    edge_expand L81773 -inside_by 0.001 L8050;
    and L5098 L8050;
    exte L83184 L81773 -lt 0.1 -output region -abut lt 90
}

// building polygons for layer Pimp
// inside layer Nimp
and Nimp Pimp L25045;

// data on layer L25045 is always an error
// building polygons for layer Pimp
// inside layer Nimp
// L25045 = and Nimp Pimp

rule NIMP.X.1 {
    caption NIMP.X.1: Nimp is NOT allowed over Pimp;
    copy L25045;
}


// width check for Pimp <0.12 
rule PIMP.W.1 {
    caption PIMP.W.1: Minimum P+ Implant width >= 0.12 um;
    inte Pimp Pimp -lt 0.12 -output region -singular -abut lt 90;
}


// spacing check for Pimp <0.12 
rule PIMP.SP.1 {
    caption PIMP.SP.1: Minimum P+ Implant space >= 0.12 um;
    exte Pimp Pimp -lt 0.12 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layer Nwell
// L25620 = and Nwell Oxide


// enclose check for L25620 inside Pimp <0.07  overlapOK
rule PIMP.E.1 {
    caption PIMP.E.1: Minimum P+ Implant to Active Area enclosure >= 0.07 um;
    enc L25620 Pimp -lt 0.07 -output region -singular -abut lt 90;
}



// overlap check for Oxide and Pimp <0.08 
rule PIMP.O.1 {
    caption PIMP.O.1: Minimum P+ Implant to Active Area overlap >= 0.08 um;
    inte Oxide Pimp -lt 0.08 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layers Nimp !Nwell
not Nimp Nwell L89543;
edge_boolean -inside Oxide L89543 L66103;

// building polygons for layer Pimp
// inside layer !Oxide
edge_boolean -outside Pimp Oxide L54069;

// spacing check for L66103 and L54069 <0.08 
rule PIMP.SE.1 {
    caption PIMP.SE.1: Minimum P+ Implant to N+ Active Area (outside Nwell) spacing >= 0.08 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L66103 -inside_by 0.001 L94348;
    edge_expand L54069 -inside_by 0.001 L46412;
    and L94348 L46412;
    exte L66103 L54069 -lt 0.08 -output region -abut lt 90
}

// building polygons for layer Oxide
// inside layer !Nwell
// L53776 = not Oxide Nwell


// enclose check for L53776 inside Pimp <0.01  overlapOK
rule PIMP.E.2 {
    caption PIMP.E.2: Minimum P+ Implant to Active Area (substrate tie) enclosure >= 0.01 um;
    enc L53776 Pimp -lt 0.01 -output region -singular -abut lt 90;
}

// building polygons for layer Poly
// inside layer Oxide
// L19486 = edge_boolean -inside Poly Oxide

// building polygons for layer Pimp
// inside layer Oxide
edge_boolean -inside Pimp Oxide L56174;

// enclose check for L19486 inside L56174 <0.1  overlapOK
rule PIMP.E.3 {
    caption PIMP.E.3: Minimum P+ Implant to gate side enclosure >= 0.1 um;
    enc L19486 L56174 -lt 0.1 -output region -abut lt 90;
}

// building polygons for layer Oxide
// inside layer Poly
// L60508 = edge_boolean -inside Oxide Poly


// enclose check for L60508 inside Pimp <0.1 
rule PIMP.E.4 {
    caption PIMP.E.4: Minimum P+ Implant to gate (endcap) enclosure >= 0.1 um;
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L60508 -inside_by 0.001 L23900;
    edge_expand Pimp -outside_by 0.001 L95503;
    and L23900 L95503;
    enc L60508 Pimp -lt 0.1 -output region -abut lt 90;
}

// building polygons for layer Oxide
// inside layers Nimp Nwell
and Nimp Nwell L3421;
edge_boolean -inside Oxide L3421 L34725;

// building polygons for layer Pimp
// inside layers !Oxide Nwell
not Nwell Oxide L90512;
edge_boolean -inside Pimp L90512 L56230;

// spacing check for L34725 and L56230 <0.02 
rule PIMP.SE.2 {
    caption PIMP.SE.2: Minimum P+ Implant to N+ Active Area (Nwell tie) spacing >= 0.02 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L34725 -inside_by 0.001 L61105;
    edge_expand L56230 -inside_by 0.001 L39162;
    and L61105 L39162;
    exte L34725 L56230 -lt 0.02 -output region -abut lt 90
}


// area check for Pimp <0.018 
rule PIMP.A.1 {
    caption PIMP.A.1: Minimum area for P+ Implant >= 0.018 um;
    area Pimp -lt 0.018;
}

holes Pimp L11383;
not L11383 Pimp L81747;

// area check for L81747 <0.04 
rule PIMP.EA.1 {
    caption PIMP.EA.1: Minimum P+ Implant ring enclosed area  >= 0.04 um;
    area L81747 -lt 0.04;
}

// building polygons for layer Pimp
// inside layer Oxide
// L56174 = edge_boolean -inside Pimp Oxide

// building polygons for layer Poly
// inside layers Nimp Oxide
// nactive = and Nimp Oxide
// L78161 = edge_boolean -inside Poly nactive

// spacing check for L56174 and L78161 <0.1 
rule PIMP.SE.3 {
    caption PIMP.SE.3: Minimum P+ Implant to N+ gate side (butted Implant) spacing >= 0.1 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L56174 -inside_by 0.001 L46213;
    edge_expand L78161 -inside_by 0.001 L68035;
    and L46213 L68035;
    exte L56174 L78161 -lt 0.1 -output region -abut lt 90
}


// rectangle size checks for Cont
rule CONT.W.1 {
    caption CONT.W.1: Maximum and minimum Contact width/length == 0.06 um;
    rect_chk -not Cont -eq 0.06 -by -eq 0.06;
}


// spacing check for Cont <0.06 
rule CONT.SP.1 {
    caption CONT.SP.1: Minimum Contact to Contact spacing >= 0.06 um;
    exte Cont Cont -lt 0.06 -output region -singular -abut lt 90;
}


// spacing check for cont_cluster_lt_pt1 <0.08 
rule CONT.SP.2 {
    caption CONT.SP.2: Space to three adjacent Contacts ( < 0.10um apart) >= 0.08 um;
    exte cont_cluster_lt_pt1 cont_cluster_lt_pt1 -lt 0.08 -output region -singular -abut lt 90;
}

// building polygons for layer Cont
// inside layer Oxide
and Cont Oxide L32388;

// building polygons for layer Poly
// inside layer Oxide
// L19486 = edge_boolean -inside Poly Oxide

// spacing check for L32388 and L19486 <0.05 
rule CONT.SE.1 {
    caption CONT.SE.1: Minimum Contact on Active Area to gate spacing >= 0.05 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L32388 -inside_by 0.001 L20276;
    edge_expand L19486 -inside_by 0.001 L24867;
    and L20276 L24867;
    exte L32388 L19486 -lt 0.05 -output region -abut lt 90
}

// building polygons for layer Cont
// inside layers Oxide Oxide_thk
// L24975 = and Oxide Oxide_thk
and Cont L24975 L78798;

// building polygons for layer Poly
// inside layers Oxide Oxide_thk
// L24975 = and Oxide Oxide_thk
// L87956 = edge_boolean -inside Poly L24975

// spacing check for L78798 and L87956 <0.06 
rule CONT.SE.2 {
    caption CONT.SE.2: Minimum Contact on 1.8V Active Area to gate spacing >= 0.06 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L78798 -inside_by 0.001 L33581;
    edge_expand L87956 -inside_by 0.001 L42957;
    and L33581 L42957;
    exte L78798 L87956 -lt 0.06 -output region -abut lt 90
}

// building polygons for layer Cont
// inside layer Poly
// cont_poly = and Cont Poly

// building polygons for layer Oxide
// inside layer Poly
// L60508 = edge_boolean -inside Oxide Poly

// spacing check for cont_poly and L60508 <0.06 
rule CONT.SE.3 {
    caption CONT.SE.3: Minimum gate Contact on Active Area spacing >= 0.06 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand cont_poly -inside_by 0.001 L39381;
    edge_expand L60508 -inside_by 0.001 L23901;
    and L39381 L23901;
    exte cont_poly L60508 -lt 0.06 -output region -abut lt 90
}

// building polygons for layer Cont
// inside layer Poly
// cont_poly = and Cont Poly

// building polygons for layer Oxide
// inside layers Oxide_thk Poly
and Oxide_thk Poly L99140;
edge_boolean -inside Oxide L99140 L85777;

// spacing check for cont_poly and L85777 <0.07 
rule CONT.SE.4 {
    caption CONT.SE.4: Minimum 1.8V gate Contact on Active Area spacing >= 0.07 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand cont_poly -inside_by 0.001 L39382;
    edge_expand L85777 -inside_by 0.001 L26514;
    and L39382 L26514;
    exte cont_poly L85777 -lt 0.07 -output region -abut lt 90
}



// enclose check for Cont inside Oxide <0.03 
rule CONT.E.1 {
    caption CONT.E.1: Minimum Active Area to Contact enclosure >= 0.03 um;
// output shapes that intersect
    select -cut Cont Oxide L47450;
    not L47450 Oxide;
    enc Cont Oxide -lt 0.03 -output region -singular -abut lt 90;
}



// enclose check for Cont inside Poly <0.02 
rule CONT.E.2 {
    caption CONT.E.2: Minimum Poly to Contact enclosure >= 0.02 um;
// output shapes that intersect
    select -cut Cont Poly L67661;
    not L67661 Poly;
    enc Cont Poly -lt 0.02 -output region -singular -abut lt 90;
}



// enclose check for Cont inside Poly <0.03  oppSides
// for oppSides use sizing and straddle checks
// cont_poly = and Cont Poly
rule CONT.E.3 {
    caption CONT.E.3: Minimum Poly to Contact enclosure on at least two opposite sides >= 0.03 um;
    grow cont_poly -left 0.03 -right 0.03 L95731;
    select -inside L95731 Poly L76668;
    not cont_poly L76668 L39551;
    grow L39551 -top 0.03 -bottom 0.03 L13020;
    select -inside L13020 Poly L30287;
    not L39551 L30287;
}

// building polygons for layer Cont
// inside layer Oxide
// L32388 = and Cont Oxide

// building polygons for layer Nimp
// inside layer Oxide
// L83184 = edge_boolean -inside Nimp Oxide

// enclose check for L32388 inside L83184 <0.03 
rule CONT.E.4 {
    caption CONT.E.4: Minimum N+/P+ Implant on Active Area to Contact enclosure >= 0.03 um;
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L32388 -inside_by 0.001 L20277;
    edge_expand L83184 -outside_by 0.001 L63483;
    and L20277 L63483;
    enc L32388 L83184 -lt 0.03 -output region -abut lt 90;
}

// building polygons for layer Cont
// inside layer Oxide
// L32388 = and Cont Oxide

// building polygons for layer Pimp
// inside layer Oxide
// L56174 = edge_boolean -inside Pimp Oxide

// enclose check for L32388 inside L56174 <0.03 
rule CONT.E.4_2 {
    caption CONT.E.4: Minimum N+/P+ Implant on Active Area to Contact enclosure >= 0.03 um;
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L32388 -inside_by 0.001 L20278;
    edge_expand L56174 -outside_by 0.001 L40010;
    and L20278 L40010;
    enc L32388 L56174 -lt 0.03 -output region -abut lt 90;
}

// building polygons for layer Cont
// inside layer gate
and Cont gate L54224;

// data on layer L54224 is always an error
// building polygons for layer Cont
// inside layer gate
// L54224 = and Cont gate

rule CONT.X.1 {
    caption CONT.X.1: Cont on gate is NOT allowed;
    copy L54224;
}

// building polygons for layer Nimp
// inside layers Cont Oxide
// L32388 = and Cont Oxide
edge_boolean -inside Nimp L32388 L8409;

// segment length check for L8409 >=0.005 
rule CONT.X.2 {
    caption CONT.X.2: Nimp edge is NOT allowed on Oxide Cont;
    edge_length L8409 -ge 0.005;
}

// building polygons for layer Pimp
// inside layers Cont Oxide
// L32388 = and Cont Oxide
edge_boolean -inside Pimp L32388 L72987;

// segment length check for L72987 >=0.005 
rule CONT.X.2_2 {
    caption CONT.X.2: Pimp edge is NOT allowed on Oxide Cont;
    edge_length L72987 -ge 0.005;
}

// building polygons for layer Cont
// inside layers !Oxide !Poly
// L32232 = or Oxide Poly
not Cont L32232 L775;

// data on layer L775 is always an error
// building polygons for layer Cont
// inside layers !Oxide !Poly
// L32232 = or Oxide Poly
// L775 = not Cont L32232

rule CONT.X.3 {
    caption CONT.X.3: CONT must be covered by Oxide or Poly;
    copy L775;
}


// width check for SiProt <0.22 
rule SIPROT.W.1 {
    caption SIPROT.W.1: Minimum Salicide Block width >= 0.22 um;
    inte SiProt SiProt -lt 0.22 -output region -singular -abut lt 90;
}


// spacing check for SiProt <0.22 
rule SIPROT.SP.1 {
    caption SIPROT.SP.1: Minimum Salicide Block space >= 0.22 um;
    exte SiProt SiProt -lt 0.22 -output region -singular -abut lt 90;
}



// spacing check for Cont and SiProt <0.12 
rule SIPROT.SE.1 {
    caption SIPROT.SE.1: Minimum Salicide Block to Contact spacing >= 0.12 um;
// output parts of shapes that intersect
    select -cut Cont SiProt L30884;
    Select -cut SiProt Cont L89298;
    and L30884 L89298;
    exte Cont SiProt -lt 0.12 -output region -singular -abut lt 90
}



// spacing check for Oxide and SiProt <0.12  overlapOK
rule SIPROT.SE.2 {
    caption SIPROT.SE.2: Minimum Salicide Block to unrelated Active Area spacing >= 0.12 um;
    exte Oxide SiProt -lt 0.12 -output region -singular -abut lt 90
}

// building polygons for layer Poly
// inside layer Oxide
// L19486 = edge_boolean -inside Poly Oxide

// building polygons for layer SiProt
// inside layer Oxide
edge_boolean -inside SiProt Oxide L6065;

// spacing check for L19486 and L6065 <0.22 
rule SIPROT.SE.3 {
    caption SIPROT.SE.3: Minimum Salicide Block to gate spacing >= 0.22 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L19486 -inside_by 0.001 L24868;
    edge_expand L6065 -inside_by 0.001 L87969;
    and L24868 L87969;
    exte L19486 L6065 -lt 0.22 -output region -abut lt 90
}



// enclose check for SiProt inside Oxide <0.12  overlapOK
rule SIPROT.E.2 {
    caption SIPROT.E.2: Minimum Active Area to Salicide Block enclosure >= 0.12 um;
    enc SiProt Oxide -lt 0.12 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layer !Resdum
edge_boolean -outside Oxide Resdum L9687;


// enclose check for L9687 inside SiProt <0.12  overlapOK shielded
rule SIPROT.E.1 {
    caption SIPROT.E.1: Minimum Salicide Block to Active Area enclosure >= 0.12 um;
    enc L9687 SiProt -lt 0.12 -output region -abut lt 90;
}

// building polygons for layer Poly
// inside layer !Oxide
// L90757 = edge_boolean -outside Poly Oxide


// enclose check for L90757 inside SiProt <0.14  overlapOK
rule SIPROT.E.3 {
    caption SIPROT.E.3: Minimum Salicide Block to Poly (on field) enclosure >= 0.14 um;
    enc L90757 SiProt -lt 0.14 -output region -abut lt 90;
}


// area check for SiProt <0.6 
rule SIPROT.A.1 {
    caption SIPROT.A.1: Minimum Salicide Block area >= 0.6 um;
    area SiProt -lt 0.6;
}

// building polygons for layer Poly
// inside layer !Oxide
// L90757 = edge_boolean -outside Poly Oxide


// spacing check for L90757 and SiProt <0.18  overlapOK
rule SIPROT.SE.4 {
    caption SIPROT.SE.4: Minimum Salicide Block to Poly (on field) spacing >= 0.18 um;
    exte L90757 SiProt -lt 0.18 -output region -abut lt 90
}

holes SiProt L24522;
not L24522 SiProt L65079;

// area check for L65079 <0.6 
rule SIPROT.EA.1 {
    caption SIPROT.EA.1: Minimum Salicide Block enclosed area >= 0.6 um;
    area L65079 -lt 0.6;
}



// enclose check for Via1 inside metal2_conn <0.005  insideOnly
rule METAL2.E.1 {
    caption METAL2.E.1: Metal2 to Via1 enclosure must be >= 0.005 um;
    enc Via1 metal2_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via1 inside metal2_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via1 metal2_conn L18996;
rule METAL2.E.2 {
    caption METAL2.E.2: Metal2 to Via1 enclosure on opposite sides must be >= 0.03 um;
    grow L18996 -left 0.03 -right 0.03 L42031;
    select -inside L42031 metal2_conn L36895;
    not L18996 L36895 L51499;
    grow L51499 -top 0.03 -bottom 0.03 L40265;
    select -inside L40265 metal2_conn L46332;
    not L51499 L46332;
}



// enclose check for Via2 inside metal3_conn <0.005  insideOnly
rule METAL3.E.1 {
    caption METAL3.E.1: Metal3 to Via2 enclosure must be >= 0.005 um;
    enc Via2 metal3_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via2 inside metal3_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via2 metal3_conn L92852;
rule METAL3.E.2 {
    caption METAL3.E.2: Metal3 to Via2 enclosure on opposite sides must be >= 0.03 um;
    grow L92852 -left 0.03 -right 0.03 L10146;
    select -inside L10146 metal3_conn L50754;
    not L92852 L50754 L26254;
    grow L26254 -top 0.03 -bottom 0.03 L30910;
    select -inside L30910 metal3_conn L57943;
    not L26254 L57943;
}



// enclose check for Via3 inside metal4_conn <0.005  insideOnly
rule METAL4.E.1 {
    caption METAL4.E.1: Metal4 to Via3 enclosure must be >= 0.005 um;
    enc Via3 metal4_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via3 inside metal4_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via3 metal4_conn L66708;
rule METAL4.E.2 {
    caption METAL4.E.2: Metal4 to Via3 enclosure on opposite sides must be >= 0.03 um;
    grow L66708 -left 0.03 -right 0.03 L6945;
    select -inside L6945 metal4_conn L52979;
    not L66708 L52979 L94962;
    grow L94962 -top 0.03 -bottom 0.03 L4651;
    select -inside L4651 metal4_conn L80691;
    not L94962 L80691;
}



// enclose check for Via4 inside metal5_conn <0.005  insideOnly
rule METAL5.E.1 {
    caption METAL5.E.1: Metal5 to Via4 enclosure must be >= 0.005 um;
    enc Via4 metal5_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via4 inside metal5_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via4 metal5_conn L40564;
rule METAL5.E.2 {
    caption METAL5.E.2: Metal5 to Via4 enclosure on opposite sides must be >= 0.03 um;
    grow L40564 -left 0.03 -right 0.03 L17433;
    select -inside L17433 metal5_conn L74406;
    not L40564 L74406 L34535;
    grow L34535 -top 0.03 -bottom 0.03 L75865;
    select -inside L75865 metal5_conn L24411;
    not L34535 L24411;
}



// enclose check for Via5 inside metal6_conn <0.005  insideOnly
rule METAL6.E.1 {
    caption METAL6.E.1: Metal6 to Via5 enclosure must be >= 0.005 um;
    enc Via5 metal6_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via5 inside metal6_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via5 metal6_conn L14420;
rule METAL6.E.2 {
    caption METAL6.E.2: Metal6 to Via5 enclosure on opposite sides must be >= 0.03 um;
    grow L14420 -left 0.03 -right 0.03 L9041;
    select -inside L9041 metal6_conn L56385;
    not L14420 L56385 L48307;
    grow L48307 -top 0.03 -bottom 0.03 L31591;
    select -inside L31591 metal6_conn L17978;
    not L48307 L17978;
}



// enclose check for Via6 inside metal7_conn <0.005  insideOnly
rule METAL7.E.1 {
    caption METAL7.E.1: Metal7 to Via6 enclosure must be >= 0.005 um;
    enc Via6 metal7_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via6 inside metal7_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via6 metal7_conn L88276;
rule METAL7.E.2 {
    caption METAL7.E.2: Metal7 to Via6 enclosure on opposite sides must be >= 0.03 um;
    grow L88276 -left 0.03 -right 0.03 L1043;
    select -inside L1043 metal7_conn L14358;
    not L88276 L14358 L52149;
    grow L52149 -top 0.03 -bottom 0.03 L26454;
    select -inside L26454 metal7_conn L7513;
    not L52149 L7513;
}



// enclose check for Via7 inside metal8_conn <0.005  insideOnly
rule METAL8.E.1 {
    caption METAL8.E.1: Metal8 to Via7 enclosure must be >= 0.005 um;
    enc Via7 metal8_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via7 inside metal8_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via7 metal8_conn L5164;
rule METAL8.E.2 {
    caption METAL8.E.2: Metal8 to Via7 enclosure on opposite sides must be >= 0.03 um;
    grow L5164 -left 0.03 -right 0.03 L35590;
    select -inside L35590 metal8_conn L57421;
    not L5164 L57421 L34924;
    grow L34924 -top 0.03 -bottom 0.03 L96107;
    select -inside L96107 metal8_conn L1372;
    not L34924 L1372;
}



// enclose check for Via8 inside metal9_conn <0.005  insideOnly
rule METAL9.E.1 {
    caption METAL9.E.1: Metal9 to Via8 enclosure must be >= 0.005 um;
    enc Via8 metal9_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via8 inside metal9_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via8 metal9_conn L31308;
rule METAL9.E.2 {
    caption METAL9.E.2: Metal9 to Via8 enclosure on opposite sides must be >= 0.03 um;
    grow L31308 -left 0.03 -right 0.03 L79327;
    select -inside L79327 metal9_conn L59518;
    not L31308 L59518 L39762;
    grow L39762 -top 0.03 -bottom 0.03 L77794;
    select -inside L77794 metal9_conn L66458;
    not L39762 L66458;
}



// enclose check for Via9 inside Metal10 <0.03  insideOnly
rule METAL10.E.1 {
    caption METAL10.E.1: Metal10 to Via9 enclosure must be >= 0.03 um;
    enc Via9 Metal10 -lt 0.03 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via9 inside Metal10 <0.05  oppSides
// for oppSides use sizing and straddle checks
and Metal10 Via9 L50798;
rule METAL10.E.2 {
    caption METAL10.E.2: Metal10 to Via9 enclosure on opposite sides must be >= 0.05 um;
    grow L50798 -left 0.05 -right 0.05 L40825;
    select -inside L40825 Metal10 L14988;
    not L50798 L14988 L63054;
    grow L63054 -top 0.05 -bottom 0.05 L8707;
    select -inside L8707 Metal10 L73149;
    not L63054 L73149;
}



// enclose check for Via10 inside Metal11 <0.03  insideOnly
rule METAL11.E.1 {
    caption METAL11.E.1: Metal11 to Via10 enclosure must be >= 0.03 um;
    enc Via10 Metal11 -lt 0.03 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via10 inside Metal11 <0.05  oppSides
// for oppSides use sizing and straddle checks
and Metal11 Via10 L5259;
rule METAL11.E.2 {
    caption METAL11.E.2: Metal11 to Via10 enclosure on opposite sides must be >= 0.05 um;
    grow L5259 -left 0.05 -right 0.05 L42333;
    select -inside L42333 Metal11 L99221;
    not L5259 L99221 L22587;
    grow L22587 -top 0.05 -bottom 0.05 L8795;
    select -inside L8795 Metal11 L6765;
    not L22587 L6765;
}

// building polygons for layer Cont
// inside layer !metal1_conn
not Cont metal1_conn L24896;

// data on layer L24896 is always an error
// building polygons for layer Cont
// inside layer !metal1_conn
// L24896 = not Cont metal1_conn

rule METAL1.E.1 {
    caption METAL1.E.1: 0.00 >= 0.00 um;
    copy L24896;
}



// enclose check for Cont inside metal1_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Cont metal1_conn L83068;
rule METAL1.E.2 {
    caption METAL1.E.2: 0.03 >= 0.03 um;
    grow L83068 -left 0.03 -right 0.03 L52391;
    select -inside L52391 metal1_conn L46178;
    not L83068 L46178 L29812;
    grow L29812 -top 0.03 -bottom 0.03 L21027;
    select -inside L21027 metal1_conn L30406;
    not L29812 L30406;
}


// width check for metal1_conn <0.06 
rule METAL1.W.1 {
    caption METAL1.W.1: Metal1 width must be >= 0.06 um;
    inte metal1_conn metal1_conn -lt 0.06 -output region -singular -abut lt 90;
}


// width check for metal2_conn <0.08 
rule METAL2.W.1 {
    caption METAL2.W.1: Metal2 width must be >= 0.08 um;
    inte metal2_conn metal2_conn -lt 0.08 -output region -singular -abut lt 90;
}


// width check for metal3_conn <0.08 
rule METAL3.W.1 {
    caption METAL3.W.1: Metal3 width must be >= 0.08 um;
    inte metal3_conn metal3_conn -lt 0.08 -output region -singular -abut lt 90;
}


// width check for metal4_conn <0.08 
rule METAL4.W.1 {
    caption METAL4.W.1: Metal4 width must be >= 0.08 um;
    inte metal4_conn metal4_conn -lt 0.08 -output region -singular -abut lt 90;
}


// width check for metal5_conn <0.08 
rule METAL5.W.1 {
    caption METAL5.W.1: Metal5 width must be >= 0.08 um;
    inte metal5_conn metal5_conn -lt 0.08 -output region -singular -abut lt 90;
}


// width check for metal6_conn <0.08 
rule METAL6.W.1 {
    caption METAL6.W.1: Metal6 width must be >= 0.08 um;
    inte metal6_conn metal6_conn -lt 0.08 -output region -singular -abut lt 90;
}


// width check for metal7_conn <0.08 
rule METAL7.W.1 {
    caption METAL7.W.1: Metal7 width must be >= 0.08 um;
    inte metal7_conn metal7_conn -lt 0.08 -output region -singular -abut lt 90;
}


// width check for metal8_conn <0.08 
rule METAL8.W.1 {
    caption METAL8.W.1: Metal8 width must be >= 0.08 um;
    inte metal8_conn metal8_conn -lt 0.08 -output region -singular -abut lt 90;
}


// width check for metal9_conn <0.08 
rule METAL9.W.1 {
    caption METAL9.W.1: Metal9 width must be >= 0.08 um;
    inte metal9_conn metal9_conn -lt 0.08 -output region -singular -abut lt 90;
}


// width check for Metal10 <0.22 
rule METAL10.W.1 {
    caption METAL10.W.1: Metal10 width must be >= 0.22 um;
    inte Metal10 Metal10 -lt 0.22 -output region -singular -abut lt 90;
}


// width check for Metal11 <0.22 
rule METAL11.W.1 {
    caption METAL11.W.1: Metal11 width must be >= 0.22 um;
    inte Metal11 Metal11 -lt 0.22 -output region -singular -abut lt 90;
}

// building polygons for layer metal1_conn
// inside layers !Bondpad !cont_array_zone !via1_array_zone
or Bondpad cont_array_zone L15026;
or L15026 via1_array_zone L40879;
not metal1_conn L40879 L78366;

// width check for L78366 >6.0 
rule METAL1.W.2 {
    caption METAL1.W.2: Metal1 width must be <= 6.0 um;
// for check without upperlimit use sizing
    size L78366 -by -3.0 L84065;
    size L84065 -by 3.0;
}

// building polygons for layer metal2_conn
// inside layers !Bondpad !via1_array_zone !via2_array_zone
or Bondpad via1_array_zone L23007;
or L23007 via2_array_zone L10068;
not metal2_conn L10068 L97076;

// width check for L97076 >6.0 
rule METAL2.W.2 {
    caption METAL2.W.2: Metal2 width must be <= 6.0 um;
// for check without upperlimit use sizing
    size L97076 -by -3.0 L69472;
    size L69472 -by 3.0;
}

// building polygons for layer metal3_conn
// inside layers !Bondpad !via2_array_zone !via3_array_zone
or Bondpad via2_array_zone L40288;
or L40288 via3_array_zone L78285;
not metal3_conn L78285 L75504;

// width check for L75504 >6.0 
rule METAL3.W.2 {
    caption METAL3.W.2: Metal3 width must be <= 6.0 um;
// for check without upperlimit use sizing
    size L75504 -by -3.0 L76330;
    size L76330 -by 3.0;
}

// building polygons for layer metal4_conn
// inside layers !Bondpad !via3_array_zone !via4_array_zone
or Bondpad via3_array_zone L57569;
or L57569 via4_array_zone L91858;
not metal4_conn L91858 L16678;

// width check for L16678 >6.0 
rule METAL4.W.2 {
    caption METAL4.W.2: Metal4 width must be <= 6.0 um;
// for check without upperlimit use sizing
    size L16678 -by -3.0 L43487;
    size L43487 -by 3.0;
}

// building polygons for layer metal5_conn
// inside layers !Bondpad !via4_array_zone !via5_array_zone
or Bondpad via4_array_zone L74850;
or L74850 via5_array_zone L46863;
not metal5_conn L46863 L45047;

// width check for L45047 >6.0 
rule METAL5.W.2 {
    caption METAL5.W.2: Metal5 width must be <= 6.0 um;
// for check without upperlimit use sizing
    size L45047 -by -3.0 L74591;
    size L74591 -by 3.0;
}

// building polygons for layer metal6_conn
// inside layers !Bondpad !via5_array_zone !via6_array_zone
or Bondpad via5_array_zone L92131;
or L92131 via6_array_zone L90960;
not metal6_conn L90960 L81857;

// width check for L81857 >6.0 
rule METAL6.W.2 {
    caption METAL6.W.2: Metal6 width must be <= 6.0 um;
// for check without upperlimit use sizing
    size L81857 -by -3.0 L37488;
    size L37488 -by 3.0;
}

// building polygons for layer metal7_conn
// inside layers !Bondpad !via6_array_zone !via7_array_zone
or Bondpad via6_array_zone L9413;
or L9413 via7_array_zone L97204;
not metal7_conn L97204 L80478;

// width check for L80478 >6.0 
rule METAL7.W.2 {
    caption METAL7.W.2: Metal7 width must be <= 6.0 um;
// for check without upperlimit use sizing
    size L80478 -by -3.0 L14284;
    size L14284 -by 3.0;
}

// building polygons for layer metal8_conn
// inside layers !Bondpad !via7_array_zone !via8_array_zone
or Bondpad via7_array_zone L26693;
or L26693 via8_array_zone L18300;
not metal8_conn L18300 L20051;

// width check for L20051 >6.0 
rule METAL8.W.2 {
    caption METAL8.W.2: Metal8 width must be <= 6.0 um;
// for check without upperlimit use sizing
    size L20051 -by -3.0 L30749;
    size L30749 -by 3.0;
}

// building polygons for layer Metal9
// inside layers !Bondpad !via6_array_zone
// L9413 = or Bondpad via6_array_zone
not Metal9 L9413 L30808;

// width check for L30808 >6.0 
rule METAL9.W.2 {
    caption METAL9.W.2: Metal9 width must be <= 6.0 um;
// for check without upperlimit use sizing
    size L30808 -by -3.0 L67342;
    size L67342 -by 3.0;
}

// building polygons for layer Metal10
// inside layer !Bondpad
not Metal10 Bondpad L29449;

// width check for L29449 >6.0 
rule METAL10.W.2 {
    caption METAL10.W.2: Metal10 width must be <= 6.0 um;
// for check without upperlimit use sizing
    size L29449 -by -3.0 L83679;
    size L83679 -by 3.0;
}

// building polygons for layer Metal11
// inside layer !Bondpad
not Metal11 Bondpad L25014;

// width check for L25014 >6.0 
rule METAL11.W.2 {
    caption METAL11.W.2: Metal11 width must be <= 6.0 um;
// for check without upperlimit use sizing
    size L25014 -by -3.0 L48159;
    size L48159 -by 3.0;
}


// spacing check for Metal1 <0.06 
rule METAL1.SP.1.1 {
    caption METAL1.SP.1.1: Metal1 to Metal1 spacing must be >= 0.06 um;
    exte Metal1 Metal1 -lt 0.06 -output region -singular -abut lt 90;
}


// spacing check for Metal2 <0.07 
rule METAL2.SP.1.1 {
    caption METAL2.SP.1.1: Metal2 to Metal2 spacing must be >= 0.07 um;
    exte Metal2 Metal2 -lt 0.07 -output region -singular -abut lt 90;
}


// spacing check for Metal3 <0.07 
rule METAL3.SP.1.1 {
    caption METAL3.SP.1.1: Metal3 to Metal3 spacing must be >= 0.07 um;
    exte Metal3 Metal3 -lt 0.07 -output region -singular -abut lt 90;
}


// spacing check for Metal4 <0.07 
rule METAL4.SP.1.1 {
    caption METAL4.SP.1.1: Metal4 to Metal4 spacing must be >= 0.07 um;
    exte Metal4 Metal4 -lt 0.07 -output region -singular -abut lt 90;
}


// spacing check for Metal5 <0.07 
rule METAL5.SP.1.1 {
    caption METAL5.SP.1.1: Metal5 to Metal5 spacing must be >= 0.07 um;
    exte Metal5 Metal5 -lt 0.07 -output region -singular -abut lt 90;
}


// spacing check for Metal6 <0.07 
rule METAL6.SP.1.1 {
    caption METAL6.SP.1.1: Metal6 to Metal6 spacing must be >= 0.07 um;
    exte Metal6 Metal6 -lt 0.07 -output region -singular -abut lt 90;
}


// spacing check for Metal7 <0.07 
rule METAL7.SP.1.1 {
    caption METAL7.SP.1.1: Metal7 to Metal7 spacing must be >= 0.07 um;
    exte Metal7 Metal7 -lt 0.07 -output region -singular -abut lt 90;
}


// spacing check for Metal8 <0.07 
rule METAL8.SP.1.1 {
    caption METAL8.SP.1.1: Metal8 to Metal8 spacing must be >= 0.07 um;
    exte Metal8 Metal8 -lt 0.07 -output region -singular -abut lt 90;
}


// spacing check for Metal9 <0.07 
rule METAL9.SP.1.1 {
    caption METAL9.SP.1.1: Metal9 to Metal9 spacing must be >= 0.07 um;
    exte Metal9 Metal9 -lt 0.07 -output region -singular -abut lt 90;
}


// spacing check for Metal10 <0.20 
rule METAL10.SP.1.1 {
    caption METAL10.SP.1.1: Metal10 to Metal10 spacing must be >= 0.20 um;
    exte Metal10 Metal10 -lt 0.20 -output region -singular -abut lt 90;
}


// spacing check for Metal11 <0.20 
rule METAL11.SP.1.1 {
    caption METAL11.SP.1.1: Metal11 to Metal11 spacing must be >= 0.20 um;
    exte Metal11 Metal11 -lt 0.20 -output region -singular -abut lt 90;
}


// building polygons for layer Metal1
// with width >0.1
size Metal1 -by 0.05 -underover L78025;
and L78025 Metal1 L80731;
edge_boolean -coincident_only Metal1 L80731 L67295;

// spacing check for Metal1 and L67295 <0.1  project errorLengthB >0.32
rule METAL1.SP.1.2 {
    caption METAL1.SP.1.2: Metal1 to Metal1 spacing must be >= 0.1 um;
    exte Metal1 L67295 -lt 0.1 -output positive2  -output region -project -abut ltgt 0 90 L52229;
    edge_length L52229 -gt 0.32;
}


// building polygons for layer Metal2
// with width >0.1
size Metal2 -by 0.05 -underover L28938;
and L28938 Metal2 L45162;
edge_boolean -coincident_only Metal2 L45162 L7761;

// spacing check for Metal2 and L7761 <0.15  project errorLengthB >0.32
rule METAL2.SP.1.2 {
    caption METAL2.SP.1.2: Metal2 to Metal2 spacing must be >= 0.15 um;
    exte Metal2 L7761 -lt 0.15 -output positive2  -output region -project -abut ltgt 0 90 L21345;
    edge_length L21345 -gt 0.32;
}


// building polygons for layer Metal3
// with width >0.1
size Metal3 -by 0.05 -underover L87445;
and L87445 Metal3 L48135;
edge_boolean -coincident_only Metal3 L48135 L91857;

// spacing check for Metal3 and L91857 <0.15  project errorLengthB >0.32
rule METAL3.SP.1.2 {
    caption METAL3.SP.1.2: Metal3 to Metal3 spacing must be >= 0.15 um;
    exte Metal3 L91857 -lt 0.15 -output positive2  -output region -project -abut ltgt 0 90 L51617;
    edge_length L51617 -gt 0.32;
}


// building polygons for layer Metal4
// with width >0.1
size Metal4 -by 0.05 -underover L36532;
and L36532 Metal4 L66879;
edge_boolean -coincident_only Metal4 L66879 L70789;

// spacing check for Metal4 and L70789 <0.15  project errorLengthB >0.32
rule METAL4.SP.1.2 {
    caption METAL4.SP.1.2: Metal4 to Metal4 spacing must be >= 0.15 um;
    exte Metal4 L70789 -lt 0.15 -output positive2  -output region -project -abut ltgt 0 90 L59365;
    edge_length L59365 -gt 0.32;
}


// building polygons for layer Metal5
// with width >0.1
size Metal5 -by 0.05 -underover L85619;
and L85619 Metal5 L30416;
edge_boolean -coincident_only Metal5 L30416 L86204;

// spacing check for Metal5 and L86204 <0.15  project errorLengthB >0.32
rule METAL5.SP.1.2 {
    caption METAL5.SP.1.2: Metal5 to Metal5 spacing must be >= 0.15 um;
    exte Metal5 L86204 -lt 0.15 -output positive2  -output region -project -abut ltgt 0 90 L84845;
    edge_length L84845 -gt 0.32;
}


// building polygons for layer Metal6
// with width >0.1
size Metal6 -by 0.05 -underover L34706;
and L34706 Metal6 L21866;
edge_boolean -coincident_only Metal6 L21866 L60488;

// spacing check for Metal6 and L60488 <0.15  project errorLengthB >0.32
rule METAL6.SP.1.2 {
    caption METAL6.SP.1.2: Metal6 to Metal6 spacing must be >= 0.15 um;
    exte Metal6 L60488 -lt 0.15 -output positive2  -output region -project -abut ltgt 0 90 L35916;
    edge_length L35916 -gt 0.32;
}


// building polygons for layer Metal7
// with width >0.1
size Metal7 -by 0.05 -underover L83793;
and L83793 Metal7 L58397;
edge_boolean -coincident_only Metal7 L58397 L75764;

// spacing check for Metal7 and L75764 <0.15  project errorLengthB >0.32
rule METAL7.SP.1.2 {
    caption METAL7.SP.1.2: Metal7 to Metal7 spacing must be >= 0.15 um;
    exte Metal7 L75764 -lt 0.15 -output positive2  -output region -project -abut ltgt 0 90 L37776;
    edge_length L37776 -gt 0.32;
}


// building polygons for layer Metal8
// with width >0.1
size Metal8 -by 0.05 -underover L32880;
and L32880 Metal8 L93885;
edge_boolean -coincident_only Metal8 L93885 L84472;

// spacing check for Metal8 and L84472 <0.15  project errorLengthB >0.32
rule METAL8.SP.1.2 {
    caption METAL8.SP.1.2: Metal8 to Metal8 spacing must be >= 0.15 um;
    exte Metal8 L84472 -lt 0.15 -output positive2  -output region -project -abut ltgt 0 90 L96853;
    edge_length L96853 -gt 0.32;
}


// building polygons for layer Metal9
// with width >0.1
size Metal9 -by 0.05 -underover L81967;
and L81967 Metal9 L30348;
edge_boolean -coincident_only Metal9 L30348 L7914;

// spacing check for Metal9 and L7914 <0.15  project errorLengthB >0.32
rule METAL9.SP.1.2 {
    caption METAL9.SP.1.2: Metal9 to Metal9 spacing must be >= 0.15 um;
    exte Metal9 L7914 -lt 0.15 -output positive2  -output region -project -abut ltgt 0 90 L90160;
    edge_length L90160 -gt 0.32;
}


// building polygons for layer Metal10
// with width >0.75
size Metal10 -by 0.375 -underover L38977;
and L38977 Metal10 L93129;
edge_boolean -coincident_only Metal10 L93129 L32302;

// spacing check for Metal10 and L32302 <0.35  project errorLengthB >0.75
rule METAL10.SP.1.2 {
    caption METAL10.SP.1.2: Metal10 to Metal10 spacing must be >= 0.35 um;
    exte Metal10 L32302 -lt 0.35 -output positive2  -output region -project -abut ltgt 0 90 L15027;
    edge_length L15027 -gt 0.75;
}


// building polygons for layer Metal11
// with width >0.75
size Metal11 -by 0.375 -underover L17312;
and L17312 Metal11 L44814;
edge_boolean -coincident_only Metal11 L44814 L96910;

// spacing check for Metal11 and L96910 <0.35  project errorLengthB >0.75
rule METAL11.SP.1.2 {
    caption METAL11.SP.1.2: Metal11 to Metal11 spacing must be >= 0.35 um;
    exte Metal11 L96910 -lt 0.35 -output positive2  -output region -project -abut ltgt 0 90 L25449;
    edge_length L25449 -gt 0.75;
}


// building polygons for layer Metal1
// with width >0.75
size Metal1 -by 0.375 -underover L83743;
and L83743 Metal1 L96114;
edge_boolean -coincident_only Metal1 L96114 L70853;

// spacing check for Metal1 and L70853 <0.25  project errorLengthB >0.75
rule METAL1.SP.1.3 {
    caption METAL1.SP.1.3: Metal1 to Metal1 spacing must be >= 0.25 um;
    exte Metal1 L70853 -lt 0.25 -output positive2  -output region -project -abut ltgt 0 90 L49821;
    edge_length L49821 -gt 0.75;
}


// building polygons for layer Metal2
// with width >0.75
size Metal2 -by 0.375 -underover L27454;
and L27454 Metal2 L41952;
edge_boolean -coincident_only Metal2 L41952 L19268;

// spacing check for Metal2 and L19268 <0.25  project errorLengthB >0.75
rule METAL2.SP.1.3 {
    caption METAL2.SP.1.3: Metal2 to Metal2 spacing must be >= 0.25 um;
    exte Metal2 L19268 -lt 0.25 -output positive2  -output region -project -abut ltgt 0 90 L56533;
    edge_length L56533 -gt 0.75;
}


// building polygons for layer Metal3
// with width >0.75
size Metal3 -by 0.375 -underover L28835;
and L28835 Metal3 L71931;
edge_boolean -coincident_only Metal3 L71931 L61567;

// spacing check for Metal3 and L61567 <0.25  project errorLengthB >0.75
rule METAL3.SP.1.3 {
    caption METAL3.SP.1.3: Metal3 to Metal3 spacing must be >= 0.25 um;
    exte Metal3 L61567 -lt 0.25 -output positive2  -output region -project -abut ltgt 0 90 L96519;
    edge_length L96519 -gt 0.75;
}


// building polygons for layer Metal4
// with width >0.75
size Metal4 -by 0.375 -underover L82172;
and L82172 Metal4 L22078;
edge_boolean -coincident_only Metal4 L22078 L91726;

// spacing check for Metal4 and L91726 <0.25  project errorLengthB >0.75
rule METAL4.SP.1.3 {
    caption METAL4.SP.1.3: Metal4 to Metal4 spacing must be >= 0.25 um;
    exte Metal4 L91726 -lt 0.25 -output positive2  -output region -project -abut ltgt 0 90 L36288;
    edge_length L36288 -gt 0.75;
}


// building polygons for layer Metal5
// with width >0.75
size Metal5 -by 0.375 -underover L74118;
and L74118 Metal5 L11050;
edge_boolean -coincident_only Metal5 L11050 L65227;

// spacing check for Metal5 and L65227 <0.25  project errorLengthB >0.75
rule METAL5.SP.1.3 {
    caption METAL5.SP.1.3: Metal5 to Metal5 spacing must be >= 0.25 um;
    exte Metal5 L65227 -lt 0.25 -output positive2  -output region -project -abut ltgt 0 90 L54124;
    edge_length L54124 -gt 0.75;
}


// building polygons for layer Metal6
// with width >0.75
size Metal6 -by 0.375 -underover L36890;
and L36890 Metal6 L19194;
edge_boolean -coincident_only Metal6 L19194 L52317;

// spacing check for Metal6 and L52317 <0.25  project errorLengthB >0.75
rule METAL6.SP.1.3 {
    caption METAL6.SP.1.3: Metal6 to Metal6 spacing must be >= 0.25 um;
    exte Metal6 L52317 -lt 0.25 -output positive2  -output region -project -abut ltgt 0 90 L10583;
    edge_length L10583 -gt 0.75;
}


// building polygons for layer Metal7
// with width >0.75
size Metal7 -by 0.375 -underover L19399;
and L19399 Metal7 L87240;
edge_boolean -coincident_only Metal7 L87240 L36115;

// spacing check for Metal7 and L36115 <0.25  project errorLengthB >0.75
rule METAL7.SP.1.3 {
    caption METAL7.SP.1.3: Metal7 to Metal7 spacing must be >= 0.25 um;
    exte Metal7 L36115 -lt 0.25 -output positive2  -output region -project -abut ltgt 0 90 L79468;
    edge_length L79468 -gt 0.75;
}


// building polygons for layer Metal8
// with width >0.75
size Metal8 -by 0.375 -underover L91608;
and L91608 Metal8 L28110;
edge_boolean -coincident_only Metal8 L28110 L61831;

// spacing check for Metal8 and L61831 <0.25  project errorLengthB >0.75
rule METAL8.SP.1.3 {
    caption METAL8.SP.1.3: Metal8 to Metal8 spacing must be >= 0.25 um;
    exte Metal8 L61831 -lt 0.25 -output positive2  -output region -project -abut ltgt 0 90 L45332;
    edge_length L45332 -gt 0.75;
}


// building polygons for layer Metal9
// with width >0.75
size Metal9 -by 0.375 -underover L64681;
and L64681 Metal9 L56196;
edge_boolean -coincident_only Metal9 L56196 L83895;

// spacing check for Metal9 and L83895 <0.25  project errorLengthB >0.75
rule METAL9.SP.1.3 {
    caption METAL9.SP.1.3: Metal9 to Metal9 spacing must be >= 0.25 um;
    exte Metal9 L83895 -lt 0.25 -output positive2  -output region -project -abut ltgt 0 90 L72497;
    edge_length L72497 -gt 0.75;
}


// building polygons for layer Metal10
// with width >1.50
size Metal10 -by 0.75 -underover L71634;
and L71634 Metal10 L52704;
edge_boolean -coincident_only Metal10 L52704 L50478;

// spacing check for Metal10 and L50478 <0.45  project errorLengthB >1.50
rule METAL10.SP.1.3 {
    caption METAL10.SP.1.3: Metal10 to Metal10 spacing must be >= 0.45 um;
    exte Metal10 L50478 -lt 0.45 -output positive2  -output region -project -abut ltgt 0 90 L43528;
    edge_length L43528 -gt 1.50;
}


// building polygons for layer Metal11
// with width >1.50
size Metal11 -by 0.75 -underover L20721;
and L20721 Metal11 L43260;
edge_boolean -coincident_only Metal11 L43260 L61504;

// spacing check for Metal11 and L61504 <0.45  project errorLengthB >1.50
rule METAL11.SP.1.3 {
    caption METAL11.SP.1.3: Metal11 to Metal11 spacing must be >= 0.45 um;
    exte Metal11 L61504 -lt 0.45 -output positive2  -output region -project -abut ltgt 0 90 L73509;
    edge_length L73509 -gt 1.50;
}


// building polygons for layer Metal1
// with width >1.5
size Metal1 -by 0.75 -underover L43024;
and L43024 Metal1 L55558;
edge_boolean -coincident_only Metal1 L55558 L90756;

// spacing check for Metal1 and L90756 <0.45  project errorLengthB >1.5
rule METAL1.SP.1.4 {
    caption METAL1.SP.1.4: Metal1 to Metal1 spacing must be >= 0.45 um;
    exte Metal1 L90756 -lt 0.45 -output positive2  -output region -project -abut ltgt 0 90 L17987;
    edge_length L17987 -gt 1.5;
}


// building polygons for layer Metal2
// with width >1.5
size Metal2 -by 0.75 -underover L7889;
and L7889 Metal2 L37818;
edge_boolean -coincident_only Metal2 L37818 L65122;

// spacing check for Metal2 and L65122 <0.45  project errorLengthB >1.5
rule METAL2.SP.1.4 {
    caption METAL2.SP.1.4: Metal2 to Metal2 spacing must be >= 0.45 um;
    exte Metal2 L65122 -lt 0.45 -output positive2  -output region -project -abut ltgt 0 90 L84301;
    edge_length L84301 -gt 1.5;
}


// building polygons for layer Metal3
// with width >1.5
size Metal3 -by 0.75 -underover L58802;
and L58802 Metal3 L52472;
edge_boolean -coincident_only Metal3 L52472 L39636;

// spacing check for Metal3 and L39636 <0.45  project errorLengthB >1.5
rule METAL3.SP.1.4 {
    caption METAL3.SP.1.4: Metal3 to Metal3 spacing must be >= 0.45 um;
    exte Metal3 L39636 -lt 0.45 -output positive2  -output region -project -abut ltgt 0 90 L96243;
    edge_length L96243 -gt 1.5;
}


// building polygons for layer Metal4
// with width >1.5
size Metal4 -by 0.75 -underover L9715;
and L9715 Metal4 L12872;
edge_boolean -coincident_only Metal4 L12872 L7565;

// spacing check for Metal4 and L7565 <0.45  project errorLengthB >1.5
rule METAL4.SP.1.4 {
    caption METAL4.SP.1.4: Metal4 to Metal4 spacing must be >= 0.45 um;
    exte Metal4 L7565 -lt 0.45 -output positive2  -output region -project -abut ltgt 0 90 L59750;
    edge_length L59750 -gt 1.5;
}


// building polygons for layer Metal5
// with width >1.5
size Metal5 -by 0.75 -underover L60628;
and L60628 Metal5 L77617;
edge_boolean -coincident_only Metal5 L77617 L90748;

// spacing check for Metal5 and L90748 <0.45  project errorLengthB >1.5
rule METAL5.SP.1.4 {
    caption METAL5.SP.1.4: Metal5 to Metal5 spacing must be >= 0.45 um;
    exte Metal5 L90748 -lt 0.45 -output positive2  -output region -project -abut ltgt 0 90 L43582;
    edge_length L43582 -gt 1.5;
}


// building polygons for layer Metal6
// with width >1.5
size Metal6 -by 0.75 -underover L11541;
and L11541 Metal6 L26144;
edge_boolean -coincident_only Metal6 L26144 L18324;

// spacing check for Metal6 and L18324 <0.45  project errorLengthB >1.5
rule METAL6.SP.1.4 {
    caption METAL6.SP.1.4: Metal6 to Metal6 spacing must be >= 0.45 um;
    exte Metal6 L18324 -lt 0.45 -output positive2  -output region -project -abut ltgt 0 90 L6315;
    edge_length L6315 -gt 1.5;
}


// building polygons for layer Metal7
// with width >1.5
size Metal7 -by 0.75 -underover L62454;
and L62454 Metal7 L88868;
edge_boolean -coincident_only Metal7 L88868 L488;

// spacing check for Metal7 and L488 <0.45  project errorLengthB >1.5
rule METAL7.SP.1.4 {
    caption METAL7.SP.1.4: Metal7 to Metal7 spacing must be >= 0.45 um;
    exte Metal7 L488 -lt 0.45 -output positive2  -output region -project -abut ltgt 0 90 L5552;
    edge_length L5552 -gt 1.5;
}


// building polygons for layer Metal8
// with width >1.5
size Metal8 -by 0.75 -underover L13367;
and L13367 Metal8 L36226;
edge_boolean -coincident_only Metal8 L36226 L26768;

// spacing check for Metal8 and L26768 <0.45  project errorLengthB >1.5
rule METAL8.SP.1.4 {
    caption METAL8.SP.1.4: Metal8 to Metal8 spacing must be >= 0.45 um;
    exte Metal8 L26768 -lt 0.45 -output positive2  -output region -project -abut ltgt 0 90 L90736;
    edge_length L90736 -gt 1.5;
}


// building polygons for layer Metal9
// with width >1.5
size Metal9 -by 0.75 -underover L64280;
and L64280 Metal9 L99881;
edge_boolean -coincident_only Metal9 L99881 L93747;

// spacing check for Metal9 and L93747 <0.45  project errorLengthB >1.5
rule METAL9.SP.1.4 {
    caption METAL9.SP.1.4: Metal9 to Metal9 spacing must be >= 0.45 um;
    exte Metal9 L93747 -lt 0.45 -output positive2  -output region -project -abut ltgt 0 90 L97850;
    edge_length L97850 -gt 1.5;
}


// building polygons for layer Metal10
// with width >2.50
size Metal10 -by 1.25 -underover L95210;
and L95210 Metal10 L25976;
edge_boolean -coincident_only Metal10 L25976 L29527;

// spacing check for Metal10 and L29527 <0.75  project errorLengthB >2.50
rule METAL10.SP.1.4 {
    caption METAL10.SP.1.4: Metal10 to Metal10 spacing must be >= 0.75 um;
    exte Metal10 L29527 -lt 0.75 -output positive2  -output region -project -abut ltgt 0 90 L70828;
    edge_length L70828 -gt 2.50;
}


// building polygons for layer Metal11
// with width >2.50
size Metal11 -by 1.25 -underover L46123;
and L46123 Metal11 L1804;
edge_boolean -coincident_only Metal11 L1804 L88168;

// spacing check for Metal11 and L88168 <0.75  project errorLengthB >2.50
rule METAL11.SP.1.4 {
    caption METAL11.SP.1.4: Metal11 to Metal11 spacing must be >= 0.75 um;
    exte Metal11 L88168 -lt 0.75 -output positive2  -output region -project -abut ltgt 0 90 L13549;
    edge_length L13549 -gt 2.50;
}


// building polygons for layer Metal1
// with width >2.5
size Metal1 -by 1.25 -underover L43476;
and L43476 Metal1 L73369;
edge_boolean -coincident_only Metal1 L73369 L5186;

// spacing check for Metal1 and L5186 <0.75  project errorLengthB >2.5
rule METAL1.SP.1.5 {
    caption METAL1.SP.1.5: Metal1 to Metal1 spacing must be >= 0.75 um;
    exte Metal1 L5186 -lt 0.75 -output positive2  -output region -project -abut ltgt 0 90 L40669;
    edge_length L40669 -gt 2.5;
}


// building polygons for layer Metal2
// with width >2.5
size Metal2 -by 1.25 -underover L92563;
and L92563 Metal2 L48277;
edge_boolean -coincident_only Metal2 L48277 L17391;

// spacing check for Metal2 and L17391 <0.75  project errorLengthB >2.5
rule METAL2.SP.1.5 {
    caption METAL2.SP.1.5: Metal2 to Metal2 spacing must be >= 0.75 um;
    exte Metal2 L17391 -lt 0.75 -output positive2  -output region -project -abut ltgt 0 90 L35959;
    edge_length L35959 -gt 2.5;
}


// building polygons for layer Metal3
// with width >2.5
size Metal3 -by 1.25 -underover L41650;
and L41650 Metal3 L4005;
edge_boolean -coincident_only Metal3 L4005 L59777;

// spacing check for Metal3 and L59777 <0.75  project errorLengthB >2.5
rule METAL3.SP.1.5 {
    caption METAL3.SP.1.5: Metal3 to Metal3 spacing must be >= 0.75 um;
    exte Metal3 L59777 -lt 0.75 -output positive2  -output region -project -abut ltgt 0 90 L8106;
    edge_length L8106 -gt 2.5;
}


// building polygons for layer Metal4
// with width >2.5
size Metal4 -by 1.25 -underover L90737;
and L90737 Metal4 L40468;
edge_boolean -coincident_only Metal4 L40468 L453;

// spacing check for Metal4 and L453 <0.75  project errorLengthB >2.5
rule METAL4.SP.1.5 {
    caption METAL4.SP.1.5: Metal4 to Metal4 spacing must be >= 0.75 um;
    exte Metal4 L453 -lt 0.75 -output positive2  -output region -project -abut ltgt 0 90 L84564;
    edge_length L84564 -gt 2.5;
}


// building polygons for layer Metal5
// with width >2.5
size Metal5 -by 1.25 -underover L39824;
and L39824 Metal5 L52579;
edge_boolean -coincident_only Metal5 L52579 L93978;

// spacing check for Metal5 and L93978 <0.75  project errorLengthB >2.5
rule METAL5.SP.1.5 {
    caption METAL5.SP.1.5: Metal5 to Metal5 spacing must be >= 0.75 um;
    exte Metal5 L93978 -lt 0.75 -output positive2  -output region -project -abut ltgt 0 90 L61663;
    edge_length L61663 -gt 2.5;
}


// building polygons for layer Metal6
// with width >2.5
size Metal6 -by 1.25 -underover L88911;
and L88911 Metal6 L77671;
edge_boolean -coincident_only Metal6 L77671 L66033;

// spacing check for Metal6 and L66033 <0.75  project errorLengthB >2.5
rule METAL6.SP.1.5 {
    caption METAL6.SP.1.5: Metal6 to Metal6 spacing must be >= 0.75 um;
    exte Metal6 L66033 -lt 0.75 -output positive2  -output region -project -abut ltgt 0 90 L54576;
    edge_length L54576 -gt 2.5;
}


// building polygons for layer Metal7
// with width >2.5
size Metal7 -by 1.25 -underover L37998;
and L37998 Metal7 L64031;
edge_boolean -coincident_only Metal7 L64031 L74482;

// spacing check for Metal7 and L74482 <0.75  project errorLengthB >2.5
rule METAL7.SP.1.5 {
    caption METAL7.SP.1.5: Metal7 to Metal7 spacing must be >= 0.75 um;
    exte Metal7 L74482 -lt 0.75 -output positive2  -output region -project -abut ltgt 0 90 L72496;
    edge_length L72496 -gt 2.5;
}


// building polygons for layer Metal8
// with width >2.5
size Metal8 -by 1.25 -underover L12915;
and L12915 Metal8 L76392;
edge_boolean -coincident_only Metal8 L76392 L22026;

// spacing check for Metal8 and L22026 <0.75  project errorLengthB >2.5
rule METAL8.SP.1.5 {
    caption METAL8.SP.1.5: Metal8 to Metal8 spacing must be >= 0.75 um;
    exte Metal8 L22026 -lt 0.75 -output positive2  -output region -project -abut ltgt 0 90 L76110;
    edge_length L76110 -gt 2.5;
}


// building polygons for layer Metal9
// with width >2.5
size Metal9 -by 1.25 -underover L63828;
and L63828 Metal9 L75892;
edge_boolean -coincident_only Metal9 L75892 L59921;

// spacing check for Metal9 and L59921 <0.75  project errorLengthB >2.5
rule METAL9.SP.1.5 {
    caption METAL9.SP.1.5: Metal9 to Metal9 spacing must be >= 0.75 um;
    exte Metal9 L59921 -lt 0.75 -output positive2  -output region -project -abut ltgt 0 90 L66481;
    edge_length L66481 -gt 2.5;
}


// building polygons for layer Metal10
// with width >3.5
size Metal10 -by 1.75 -underover L19825;
and L19825 Metal10 L56118;
edge_boolean -coincident_only Metal10 L56118 L37045;

// spacing check for Metal10 and L37045 <1.25  project errorLengthB >3.5
rule METAL10.SP.1.5 {
    caption METAL10.SP.1.5: Metal10 to Metal10 spacing must be >= 1.25 um;
    exte Metal10 L37045 -lt 1.25 -output positive2  -output region -project -abut ltgt 0 90 L16394;
    edge_length L16394 -gt 3.5;
}


// building polygons for layer Metal11
// with width >3.5
size Metal11 -by 1.75 -underover L68912;
and L68912 Metal11 L83396;
edge_boolean -coincident_only Metal11 L83396 L56648;

// spacing check for Metal11 and L56648 <1.25  project errorLengthB >3.5
rule METAL11.SP.1.5 {
    caption METAL11.SP.1.5: Metal11 to Metal11 spacing must be >= 1.25 um;
    exte Metal11 L56648 -lt 1.25 -output positive2  -output region -project -abut ltgt 0 90 L98357;
    edge_length L98357 -gt 3.5;
}


// building polygons for layer Metal1
// with width >3.5
size Metal1 -by 1.75 -underover L8785;
and L8785 Metal1 L82421;
edge_boolean -coincident_only Metal1 L82421 L10627;

// spacing check for Metal1 and L10627 <1.25  project errorLengthB >3.5
rule METAL1.SP.1.6 {
    caption METAL1.SP.1.6: Metal1 to Metal1 spacing must be >= 1.25 um;
    exte Metal1 L10627 -lt 1.25 -output positive2  -output region -project -abut ltgt 0 90 L76483;
    edge_length L76483 -gt 3.5;
}


// building polygons for layer Metal2
// with width >3.5
size Metal2 -by 1.75 -underover L59698;
and L59698 Metal2 L32739;
edge_boolean -coincident_only Metal2 L32739 L14975;

// spacing check for Metal2 and L14975 <1.25  project errorLengthB >3.5
rule METAL2.SP.1.6 {
    caption METAL2.SP.1.6: Metal2 to Metal2 spacing must be >= 1.25 um;
    exte Metal2 L14975 -lt 1.25 -output positive2  -output region -project -abut ltgt 0 90 L82316;
    edge_length L82316 -gt 3.5;
}


// building polygons for layer Metal3
// with width >3.5
size Metal3 -by 1.75 -underover L10611;
and L10611 Metal3 L7208;
edge_boolean -coincident_only Metal3 L7208 L68479;

// spacing check for Metal3 and L68479 <1.25  project errorLengthB >3.5
rule METAL3.SP.1.6 {
    caption METAL3.SP.1.6: Metal3 to Metal3 spacing must be >= 1.25 um;
    exte Metal3 L68479 -lt 1.25 -output positive2  -output region -project -abut ltgt 0 90 L19667;
    edge_length L19667 -gt 3.5;
}


// building polygons for layer Metal4
// with width >3.5
size Metal4 -by 1.75 -underover L61524;
and L61524 Metal4 L22220;
edge_boolean -coincident_only Metal4 L22220 L89967;

// spacing check for Metal4 and L89967 <1.25  project errorLengthB >3.5
rule METAL4.SP.1.6 {
    caption METAL4.SP.1.6: Metal4 to Metal4 spacing must be >= 1.25 um;
    exte Metal4 L89967 -lt 1.25 -output positive2  -output region -project -abut ltgt 0 90 L46999;
    edge_length L46999 -gt 3.5;
}


// building polygons for layer Metal5
// with width >3.5
size Metal5 -by 1.75 -underover L54859;
and L54859 Metal5 L43948;
edge_boolean -coincident_only Metal5 L43948 L3998;

// spacing check for Metal5 and L3998 <1.25  project errorLengthB >3.5
rule METAL5.SP.1.6 {
    caption METAL5.SP.1.6: Metal5 to Metal5 spacing must be >= 1.25 um;
    exte Metal5 L3998 -lt 1.25 -output positive2  -output region -project -abut ltgt 0 90 L16466;
    edge_length L16466 -gt 3.5;
}


// building polygons for layer Metal6
// with width >3.5
size Metal6 -by 1.75 -underover L3946;
and L3946 Metal6 L93628;
edge_boolean -coincident_only Metal6 L93628 L38303;

// spacing check for Metal6 and L38303 <1.25  project errorLengthB >3.5
rule METAL6.SP.1.6 {
    caption METAL6.SP.1.6: Metal6 to Metal6 spacing must be >= 1.25 um;
    exte Metal6 L38303 -lt 1.25 -output positive2  -output region -project -abut ltgt 0 90 L86611;
    edge_length L86611 -gt 3.5;
}


// building polygons for layer Metal7
// with width >3.5
size Metal7 -by 1.75 -underover L53033;
and L53033 Metal7 L29665;
edge_boolean -coincident_only Metal7 L29665 L13748;

// spacing check for Metal7 and L13748 <1.25  project errorLengthB >3.5
rule METAL7.SP.1.6 {
    caption METAL7.SP.1.6: Metal7 to Metal7 spacing must be >= 1.25 um;
    exte Metal7 L13748 -lt 1.25 -output positive2  -output region -project -abut ltgt 0 90 L84340;
    edge_length L84340 -gt 3.5;
}


// building polygons for layer Metal8
// with width >3.5
size Metal8 -by 1.75 -underover L2120;
and L2120 Metal8 L20015;
edge_boolean -coincident_only Metal8 L20015 L22547;

// spacing check for Metal8 and L22547 <1.25  project errorLengthB >3.5
rule METAL8.SP.1.6 {
    caption METAL8.SP.1.6: Metal8 to Metal8 spacing must be >= 1.25 um;
    exte Metal8 L22547 -lt 1.25 -output positive2  -output region -project -abut ltgt 0 90 L92046;
    edge_length L92046 -gt 3.5;
}


// building polygons for layer Metal9
// with width >3.5
size Metal9 -by 1.75 -underover L51207;
and L51207 Metal9 L59080;
edge_boolean -coincident_only Metal9 L59080 L95520;

// spacing check for Metal9 and L95520 <1.25  project errorLengthB >3.5
rule METAL9.SP.1.6 {
    caption METAL9.SP.1.6: Metal9 to Metal9 spacing must be >= 1.25 um;
    exte Metal9 L95520 -lt 1.25 -output positive2  -output region -project -abut ltgt 0 90 L10160;
    edge_length L10160 -gt 3.5;
}

// building polygons for layer Metal1
// with angle !=90
angle Metal1 -ltgt 0 90 L79182;

// segment length check for L79182 <0.1 
rule METAL1.L.1 {
    caption METAL1.L.1: Metal1 non-90 degree segments must be >= 0.1 um;
    edge_length L79182 -lt 0.1;
}

// building polygons for layer Metal2
// with angle !=90
angle Metal2 -ltgt 0 90 L61902;

// segment length check for L61902 <0.1 
rule METAL2.L.1 {
    caption METAL2.L.1: Metal2 non-90 degree segments must be >= 0.1 um;
    edge_length L61902 -lt 0.1;
}

// building polygons for layer Metal3
// with angle !=90
angle Metal3 -ltgt 0 90 L44620;

// segment length check for L44620 <0.1 
rule METAL3.L.1 {
    caption METAL3.L.1: Metal3 non-90 degree segments must be >= 0.1 um;
    edge_length L44620 -lt 0.1;
}

// building polygons for layer Metal4
// with angle !=90
angle Metal4 -ltgt 0 90 L27339;

// segment length check for L27339 <0.1 
rule METAL4.L.1 {
    caption METAL4.L.1: Metal4 non-90 degree segments must be >= 0.1 um;
    edge_length L27339 -lt 0.1;
}

// building polygons for layer Metal5
// with angle !=90
angle Metal5 -ltgt 0 90 L10058;

// segment length check for L10058 <0.1 
rule METAL5.L.1 {
    caption METAL5.L.1: Metal5 non-90 degree segments must be >= 0.1 um;
    edge_length L10058 -lt 0.1;
}

// building polygons for layer Metal6
// with angle !=90
angle Metal6 -ltgt 0 90 L92777;

// segment length check for L92777 <0.1 
rule METAL6.L.1 {
    caption METAL6.L.1: Metal6 non-90 degree segments must be >= 0.1 um;
    edge_length L92777 -lt 0.1;
}

// building polygons for layer Metal7
// with angle !=90
angle Metal7 -ltgt 0 90 L75496;

// segment length check for L75496 <0.1 
rule METAL7.L.1 {
    caption METAL7.L.1: Metal7 non-90 degree segments must be >= 0.1 um;
    edge_length L75496 -lt 0.1;
}

// building polygons for layer Metal8
// with angle !=90
angle Metal8 -ltgt 0 90 L9081;

// segment length check for L9081 <0.1 
rule METAL8.L.1 {
    caption METAL8.L.1: Metal8 non-90 degree segments must be >= 0.1 um;
    edge_length L9081 -lt 0.1;
}

// building polygons for layer Metal9
// with angle !=90
angle Metal9 -ltgt 0 90 L26362;

// segment length check for L26362 <0.1 
rule METAL9.L.1 {
    caption METAL9.L.1: Metal9 non-90 degree segments must be >= 0.1 um;
    edge_length L26362 -lt 0.1;
}


// building polygons for layer Metal1
// with angle !=90
// L79182 = angle Metal1 -ltgt 0 90

// spacing check for Metal1 and L79182 <0.1 
rule METAL1.SP.2 {
    caption METAL1.SP.2: Metal1 to bent Metal1 spacing must be >= 0.1 um;
    exte Metal1 L79182 -lt 0.1 -output region -abut ltgt 0 90
}

// building polygons for layer Metal1
// with angle !=90
// L79182 = angle Metal1 -ltgt 0 90

// width check for L79182 <0.07 
rule METAL1.W.3 {
    caption METAL1.W.3: Bent Metal1 (45 degree angle) width must be >= 0.07;
    inte L79182 L79182 -lt 0.07 -output region -abut lt 90;
}


// building polygons for layer Metal2
// with angle !=90
// L61902 = angle Metal2 -ltgt 0 90

// spacing check for Metal2 and L61902 <0.1 
rule METAL2.SP.2 {
    caption METAL2.SP.2: Metal2 to bent Metal2 spacing must be >= 0.1 um;
    exte Metal2 L61902 -lt 0.1 -output region -abut ltgt 0 90
}

// building polygons for layer Metal2
// with angle !=90
// L61902 = angle Metal2 -ltgt 0 90

// width check for L61902 <0.09 
rule METAL2.W.3 {
    caption METAL2.W.3: Bent Metal2 (45 degree angle) width must be >= 0.09;
    inte L61902 L61902 -lt 0.09 -output region -abut lt 90;
}


// building polygons for layer Metal3
// with angle !=90
// L44620 = angle Metal3 -ltgt 0 90

// spacing check for Metal3 and L44620 <0.1 
rule METAL3.SP.2 {
    caption METAL3.SP.2: Metal3 to bent Metal3 spacing must be >= 0.1 um;
    exte Metal3 L44620 -lt 0.1 -output region -abut ltgt 0 90
}

// building polygons for layer Metal3
// with angle !=90
// L44620 = angle Metal3 -ltgt 0 90

// width check for L44620 <0.09 
rule METAL3.W.3 {
    caption METAL3.W.3: Bent Metal3 (45 degree angle) width must be >= 0.09;
    inte L44620 L44620 -lt 0.09 -output region -abut lt 90;
}


// building polygons for layer Metal4
// with angle !=90
// L27339 = angle Metal4 -ltgt 0 90

// spacing check for Metal4 and L27339 <0.1 
rule METAL4.SP.2 {
    caption METAL4.SP.2: Metal4 to bent Metal4 spacing must be >= 0.1 um;
    exte Metal4 L27339 -lt 0.1 -output region -abut ltgt 0 90
}

// building polygons for layer Metal4
// with angle !=90
// L27339 = angle Metal4 -ltgt 0 90

// width check for L27339 <0.09 
rule METAL4.W.3 {
    caption METAL4.W.3: Bent Metal4 (45 degree angle) width must be >= 0.09;
    inte L27339 L27339 -lt 0.09 -output region -abut lt 90;
}


// building polygons for layer Metal5
// with angle !=90
// L10058 = angle Metal5 -ltgt 0 90

// spacing check for Metal5 and L10058 <0.1 
rule METAL5.SP.2 {
    caption METAL5.SP.2: Metal5 to bent Metal5 spacing must be >= 0.1 um;
    exte Metal5 L10058 -lt 0.1 -output region -abut ltgt 0 90
}

// building polygons for layer Metal5
// with angle !=90
// L10058 = angle Metal5 -ltgt 0 90

// width check for L10058 <0.09 
rule METAL5.W.3 {
    caption METAL5.W.3: Bent Metal5 (45 degree angle) width must be >= 0.09;
    inte L10058 L10058 -lt 0.09 -output region -abut lt 90;
}


// building polygons for layer Metal6
// with angle !=90
// L92777 = angle Metal6 -ltgt 0 90

// spacing check for Metal6 and L92777 <0.1 
rule METAL6.SP.2 {
    caption METAL6.SP.2: Metal6 to bent Metal6 spacing must be >= 0.1 um;
    exte Metal6 L92777 -lt 0.1 -output region -abut ltgt 0 90
}

// building polygons for layer Metal6
// with angle !=90
// L92777 = angle Metal6 -ltgt 0 90

// width check for L92777 <0.09 
rule METAL6.W.3 {
    caption METAL6.W.3: Bent Metal6 (45 degree angle) width must be >= 0.09;
    inte L92777 L92777 -lt 0.09 -output region -abut lt 90;
}


// building polygons for layer Metal7
// with angle !=90
// L75496 = angle Metal7 -ltgt 0 90

// spacing check for Metal7 and L75496 <0.1 
rule METAL7.SP.2 {
    caption METAL7.SP.2: Metal7 to bent Metal7 spacing must be >= 0.1 um;
    exte Metal7 L75496 -lt 0.1 -output region -abut ltgt 0 90
}

// building polygons for layer Metal7
// with angle !=90
// L75496 = angle Metal7 -ltgt 0 90

// width check for L75496 <0.09 
rule METAL7.W.3 {
    caption METAL7.W.3: Bent Metal7 (45 degree angle) width must be >= 0.09;
    inte L75496 L75496 -lt 0.09 -output region -abut lt 90;
}


// building polygons for layer Metal8
// with angle !=90
// L9081 = angle Metal8 -ltgt 0 90

// spacing check for Metal8 and L9081 <0.1 
rule METAL8.SP.2 {
    caption METAL8.SP.2: Metal8 to bent Metal8 spacing must be >= 0.1 um;
    exte Metal8 L9081 -lt 0.1 -output region -abut ltgt 0 90
}

// building polygons for layer Metal8
// with angle !=90
// L9081 = angle Metal8 -ltgt 0 90

// width check for L9081 <0.09 
rule METAL8.W.3 {
    caption METAL8.W.3: Bent Metal8 (45 degree angle) width must be >= 0.09;
    inte L9081 L9081 -lt 0.09 -output region -abut lt 90;
}


// building polygons for layer Metal9
// with angle !=90
// L26362 = angle Metal9 -ltgt 0 90

// spacing check for Metal9 and L26362 <0.1 
rule METAL9.SP.2 {
    caption METAL9.SP.2: Metal9 to bent Metal9 spacing must be >= 0.1 um;
    exte Metal9 L26362 -lt 0.1 -output region -abut ltgt 0 90
}

// building polygons for layer Metal9
// with angle !=90
// L26362 = angle Metal9 -ltgt 0 90

// width check for L26362 <0.09 
rule METAL9.W.3 {
    caption METAL9.W.3: Bent Metal9 (45 degree angle) width must be >= 0.09;
    inte L26362 L26362 -lt 0.09 -output region -abut lt 90;
}


// area check for Metal1 <0.02 
rule METAL1.A.1 {
    caption METAL1.A.1: Metal1 area must be >= 0.02 um;
    area Metal1 -lt 0.02;
}


// area check for Metal2 <0.02 
rule METAL2.A.1 {
    caption METAL2.A.1: Metal2 area must be >= 0.02 um;
    area Metal2 -lt 0.02;
}


// area check for Metal3 <0.02 
rule METAL3.A.1 {
    caption METAL3.A.1: Metal3 area must be >= 0.02 um;
    area Metal3 -lt 0.02;
}


// area check for Metal4 <0.02 
rule METAL4.A.1 {
    caption METAL4.A.1: Metal4 area must be >= 0.02 um;
    area Metal4 -lt 0.02;
}


// area check for Metal5 <0.02 
rule METAL5.A.1 {
    caption METAL5.A.1: Metal5 area must be >= 0.02 um;
    area Metal5 -lt 0.02;
}


// area check for Metal6 <0.02 
rule METAL6.A.1 {
    caption METAL6.A.1: Metal6 area must be >= 0.02 um;
    area Metal6 -lt 0.02;
}


// area check for Metal7 <0.02 
rule METAL7.A.1 {
    caption METAL7.A.1: Metal7 area must be >= 0.02 um;
    area Metal7 -lt 0.02;
}


// area check for Metal8 <0.02 
rule METAL8.A.1 {
    caption METAL8.A.1: Metal8 area must be >= 0.02 um;
    area Metal8 -lt 0.02;
}


// area check for Metal9 <0.02 
rule METAL9.A.1 {
    caption METAL9.A.1: Metal9 area must be >= 0.02 um;
    area Metal9 -lt 0.02;
}


// area check for Metal10 <0.10 
rule METAL10.A.1 {
    caption METAL10.A.1: Metal10 area must be >= 0.10 um;
    area Metal10 -lt 0.10;
}


// area check for Metal11 <0.10 
rule METAL11.A.1 {
    caption METAL11.A.1: Metal11 area must be >= 0.10 um;
    area Metal11 -lt 0.10;
}

// L11511 = holes Metal1
not L11511 Metal1 L70100;

// area check for L70100 <0.045 
rule METAL1.EA.1 {
    caption METAL1.EA.1: Metal1 enclosed area must be >= 0.05 um;
    area L70100 -lt 0.045;
}

// L11512 = holes Metal2
not L11512 Metal2 L86860;

// area check for L86860 <0.055 
rule METAL2.EA.1 {
    caption METAL2.EA.1: Metal2 enclosed area must be >= 0.05 um;
    area L86860 -lt 0.055;
}

// L11513 = holes Metal3
not L11513 Metal3 L76524;

// area check for L76524 <0.055 
rule METAL3.EA.1 {
    caption METAL3.EA.1: Metal3 enclosed area must be >= 0.05 um;
    area L76524 -lt 0.055;
}

// L11514 = holes Metal4
not L11514 Metal4 L33812;

// area check for L33812 <0.055 
rule METAL4.EA.1 {
    caption METAL4.EA.1: Metal4 enclosed area must be >= 0.05 um;
    area L33812 -lt 0.055;
}

// L11515 = holes Metal5
not L11515 Metal5 L23148;

// area check for L23148 <0.055 
rule METAL5.EA.1 {
    caption METAL5.EA.1: Metal5 enclosed area must be >= 0.05 um;
    area L23148 -lt 0.055;
}

// L11516 = holes Metal6
not L11516 Metal6 L87188;

// area check for L87188 <0.055 
rule METAL6.EA.1 {
    caption METAL6.EA.1: Metal6 enclosed area must be >= 0.05 um;
    area L87188 -lt 0.055;
}

// L11517 = holes Metal7
not L11517 Metal7 L69772;

// area check for L69772 <0.055 
rule METAL7.EA.1 {
    caption METAL7.EA.1: Metal7 enclosed area must be >= 0.05 um;
    area L69772 -lt 0.055;
}

// L11518 = holes Metal8
not L11518 Metal8 L40565;

// area check for L40565 <0.055 
rule METAL8.EA.1 {
    caption METAL8.EA.1: Metal8 enclosed area must be >= 0.05 um;
    area L40565 -lt 0.055;
}

// L11519 = holes Metal9
not L11519 Metal9 L50900;

// area check for L50900 <0.055 
rule METAL9.EA.1 {
    caption METAL9.EA.1: Metal9 enclosed area must be >= 0.05 um;
    area L50900 -lt 0.055;
}

// L77703 = holes Metal10
not L77703 Metal10 L15903;

// area check for L15903 <0.11 
rule METAL10.EA.1 {
    caption METAL10.EA.1: Metal10 enclosed area must be >= 0.05 um;
    area L15903 -lt 0.11;
}

// L77702 = holes Metal11
not L77702 Metal11 L38561;

// area check for L38561 <0.11 
rule METAL11.EA.1 {
    caption METAL11.EA.1: Metal11 enclosed area must be >= 0.05 um;
    area L38561 -lt 0.11;
}


// spacing check for CapMetal <1.0 
rule CMET.S.1 {
    caption CMET.S.1: Minimum space of CapMetal >= 1.0 um;
    exte CapMetal CapMetal -lt 1.0 -output region -singular -abut lt 90;
}


// width check for CapMetal <1.0 
rule CMET.W.1 {
    caption CMET.W.1: Minimum width of CapMetal >= 1.0 um;
    inte CapMetal CapMetal -lt 1.0 -output region -singular -abut lt 90;
}



// enclose check for via10_cap inside Metal11 <0.05 
rule CMET.E.1 {
    caption CMET.E.1: Minimum Metal 1 overlap of Via 10 on CapMetal >= 0.05 um;
// output shapes that intersect
    select -cut via10_cap Metal11 L49600;
    not L49600 Metal11;
    enc via10_cap Metal11 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for via10_cap inside CapMetal <0.15 
rule CMET.E.2 {
    caption CMET.E.2: Minimum CapMetal overlap of Via 10 >= 0.15 um;
// output shapes that intersect
    select -cut via10_cap CapMetal L86172;
    not L86172 CapMetal;
    enc via10_cap CapMetal -lt 0.15 -output region -singular -abut lt 90;
}



// enclose check for CapMetal inside Metal10 <0.2 
rule CMET.E.4 {
    caption CMET.E.4: Minimum Metal 10 overlap of CapMetal >= 0.2 um;
// output shapes that intersect
    select -cut CapMetal Metal10 L87618;
    not L87618 Metal10;
    enc CapMetal Metal10 -lt 0.2 -output region -singular -abut lt 90;
}



// enclose check for Metal11 inside CapMetal <0.1  overlapOK
rule CMET.E.3 {
    caption CMET.E.3: Minimum CapMetal extension over Metal 11 >= 0.1 um;
    enc Metal11 CapMetal -lt 0.1 -output region -singular -abut lt 90;
}


// rectangle size checks for Via1
rule VIA1.W.1 {
    caption VIA1.W.1: Via1 shapes must be 0.07x0.07 rectangles;
    rect_chk -not Via1 -eq 0.07 -by -eq 0.07;
}


// spacing check for Via1 <0.07 
rule VIA1.SP.1 {
    caption VIA1.SP.1: Via1 to Via1 spacing must be >= 0.07 um;
    exte Via1 Via1 -lt 0.07 -output region -singular -abut lt 90;
}


// rectangle size checks for Via2
rule VIA2.W.1 {
    caption VIA2.W.1: Via2 shapes must be 0.07x0.07 rectangles;
    rect_chk -not Via2 -eq 0.07 -by -eq 0.07;
}


// spacing check for Via2 <0.07 
rule VIA2.SP.1 {
    caption VIA2.SP.1: Via2 to Via2 spacing must be >= 0.07 um;
    exte Via2 Via2 -lt 0.07 -output region -singular -abut lt 90;
}


// rectangle size checks for Via3
rule VIA3.W.1 {
    caption VIA3.W.1: Via3 shapes must be 0.07x0.07 rectangles;
    rect_chk -not Via3 -eq 0.07 -by -eq 0.07;
}


// spacing check for Via3 <0.07 
rule VIA3.SP.1 {
    caption VIA3.SP.1: Via3 to Via3 spacing must be >= 0.07 um;
    exte Via3 Via3 -lt 0.07 -output region -singular -abut lt 90;
}


// rectangle size checks for Via4
rule VIA4.W.1 {
    caption VIA4.W.1: Via4 shapes must be 0.07x0.07 rectangles;
    rect_chk -not Via4 -eq 0.07 -by -eq 0.07;
}


// spacing check for Via4 <0.07 
rule VIA4.SP.1 {
    caption VIA4.SP.1: Via4 to Via4 spacing must be >= 0.07 um;
    exte Via4 Via4 -lt 0.07 -output region -singular -abut lt 90;
}


// rectangle size checks for Via5
rule VIA5.W.1 {
    caption VIA5.W.1: Via5 shapes must be 0.07x0.07 rectangles;
    rect_chk -not Via5 -eq 0.07 -by -eq 0.07;
}


// spacing check for Via5 <0.07 
rule VIA5.SP.1 {
    caption VIA5.SP.1: Via5 to Via5 spacing must be >= 0.07 um;
    exte Via5 Via5 -lt 0.07 -output region -singular -abut lt 90;
}


// rectangle size checks for Via6
rule VIA6.W.1 {
    caption VIA6.W.1: Via6 shapes must be 0.07x0.07 rectangles;
    rect_chk -not Via6 -eq 0.07 -by -eq 0.07;
}


// spacing check for Via6 <0.07 
rule VIA6.SP.1 {
    caption VIA6.SP.1: Via6 to Via6 spacing must be >= 0.07 um;
    exte Via6 Via6 -lt 0.07 -output region -singular -abut lt 90;
}


// rectangle size checks for Via7
rule VIA7.W.1 {
    caption VIA7.W.1: Via7 shapes must be 0.07x0.07 rectangles;
    rect_chk -not Via7 -eq 0.07 -by -eq 0.07;
}


// spacing check for Via7 <0.07 
rule VIA7.SP.1 {
    caption VIA7.SP.1: Via7 to Via7 spacing must be >= 0.07 um;
    exte Via7 Via7 -lt 0.07 -output region -singular -abut lt 90;
}


// rectangle size checks for Via8
rule VIA8.W.1 {
    caption VIA8.W.1: Via8 shapes must be 0.07x0.07 rectangles;
    rect_chk -not Via8 -eq 0.07 -by -eq 0.07;
}


// spacing check for Via8 <0.07 
rule VIA8.SP.1 {
    caption VIA8.SP.1: Via8 to Via8 spacing must be >= 0.07 um;
    exte Via8 Via8 -lt 0.07 -output region -singular -abut lt 90;
}


// rectangle size checks for Via9
rule VIA9.W.1 {
    caption VIA9.W.1: Via9 shapes must be 0.18x0.18 rectangles;
    rect_chk -not Via9 -eq 0.18 -by -eq 0.18;
}


// spacing check for Via9 <0.18 
rule VIA9.SP.1 {
    caption VIA9.SP.1: Via9 to Via9 spacing must be >= 0.18 um;
    exte Via9 Via9 -lt 0.18 -output region -singular -abut lt 90;
}


// rectangle size checks for Via10
rule VIA10.W.1 {
    caption VIA10.W.1: Via10 shapes must be 0.18x0.18 rectangles;
    rect_chk -not Via10 -eq 0.18 -by -eq 0.18;
}


// spacing check for Via10 <0.18 
rule VIA10.SP.1 {
    caption VIA10.SP.1: Via10 to Via10 spacing must be >= 0.18 um;
    exte Via10 Via10 -lt 0.18 -output region -singular -abut lt 90;
}



// enclose check for Via1 inside metal1_conn <0.005  insideOnly
rule VIA1.E.1 {
    caption VIA1.E.1: Metal1 to Via1 enclosure must be >= 0.005 um;
    enc Via1 metal1_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via1 inside metal1_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via1 metal1_conn L48147;
rule VIA1.E.2 {
    caption VIA1.E.2: Metal1 to Via1 enclosure on opposite sides must be >= 0.03 um;
    grow L48147 -left 0.03 -right 0.03 L79310;
    select -inside L79310 metal1_conn L61312;
    not L48147 L61312 L97988;
    grow L97988 -top 0.03 -bottom 0.03 L45492;
    select -inside L45492 metal1_conn L57692;
    not L97988 L57692;
}



// enclose check for Via2 inside metal2_conn <0.005  insideOnly
rule VIA2.E.1 {
    caption VIA2.E.1: Metal2 to Via2 enclosure must be >= 0.005 um;
    enc Via2 metal2_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via2 inside metal2_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via2 metal2_conn L22003;
rule VIA2.E.2 {
    caption VIA2.E.2: Metal2 to Via2 enclosure on opposite sides must be >= 0.03 um;
    grow L22003 -left 0.03 -right 0.03 L45579;
    select -inside L45579 metal2_conn L32443;
    not L22003 L32443 L60436;
    grow L60436 -top 0.03 -bottom 0.03 L50898;
    select -inside L50898 metal2_conn L22027;
    not L60436 L22027;
}



// enclose check for Via3 inside metal3_conn <0.005  insideOnly
rule VIA3.E.1 {
    caption VIA3.E.1: Metal3 to Via3 enclosure must be >= 0.005 um;
    enc Via3 metal3_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via3 inside metal3_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via3 metal3_conn L95859;
rule VIA3.E.2 {
    caption VIA3.E.2: Metal3 to Via3 enclosure on opposite sides must be >= 0.03 um;
    grow L95859 -left 0.03 -right 0.03 L62370;
    select -inside L62370 metal3_conn L42078;
    not L95859 L42078 L54118;
    grow L54118 -top 0.03 -bottom 0.03 L54678;
    select -inside L54678 metal3_conn L95398;
    not L54118 L95398;
}



// enclose check for Via4 inside metal4_conn <0.005  insideOnly
rule VIA4.E.1 {
    caption VIA4.E.1: Metal4 to Via4 enclosure must be >= 0.005 um;
    enc Via4 metal4_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via4 inside metal4_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via4 metal4_conn L69715;
rule VIA4.E.2 {
    caption VIA4.E.2: Metal4 to Via4 enclosure on opposite sides must be >= 0.03 um;
    grow L69715 -left 0.03 -right 0.03 L46022;
    select -inside L46022 metal4_conn L85893;
    not L69715 L85893 L16336;
    grow L16336 -top 0.03 -bottom 0.03 L36674;
    select -inside L36674 metal4_conn L51171;
    not L16336 L51171;
}



// enclose check for Via5 inside metal5_conn <0.005  insideOnly
rule VIA5.E.1 {
    caption VIA5.E.1: Metal5 to Via5 enclosure must be >= 0.005 um;
    enc Via5 metal5_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via5 inside metal5_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via5 metal5_conn L43571;
rule VIA5.E.2 {
    caption VIA5.E.2: Metal5 to Via5 enclosure on opposite sides must be >= 0.03 um;
    grow L43571 -left 0.03 -right 0.03 L64466;
    select -inside L64466 metal5_conn L24418;
    not L43571 L24418 L89764;
    grow L89764 -top 0.03 -bottom 0.03 L18437;
    select -inside L18437 metal5_conn L20611;
    not L89764 L20611;
}



// enclose check for Via6 inside metal6_conn <0.005  insideOnly
rule VIA6.E.1 {
    caption VIA6.E.1: Metal6 to Via6 enclosure must be >= 0.005 um;
    enc Via6 metal6_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via6 inside metal6_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via6 metal6_conn L17427;
rule VIA6.E.2 {
    caption VIA6.E.2: Metal6 to Via6 enclosure on opposite sides must be >= 0.03 um;
    grow L17427 -left 0.03 -right 0.03 L85740;
    select -inside L85740 metal6_conn L72383;
    not L17427 L72383 L40141;
    grow L40141 -top 0.03 -bottom 0.03 L11011;
    select -inside L11011 metal6_conn L24165;
    not L40141 L24165;
}



// enclose check for Via7 inside metal7_conn <0.005  insideOnly
rule VIA7.E.1 {
    caption VIA7.E.1: Metal7 to Via7 enclosure must be >= 0.005 um;
    enc Via7 metal7_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via7 inside metal7_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via7 metal7_conn L76013;
rule VIA7.E.2 {
    caption VIA7.E.2: Metal7 to Via7 enclosure on opposite sides must be >= 0.03 um;
    grow L76013 -left 0.03 -right 0.03 L9579;
    select -inside L9579 metal7_conn L77354;
    not L76013 L77354 L90834;
    grow L90834 -top 0.03 -bottom 0.03 L33997;
    select -inside L33997 metal7_conn L99327;
    not L90834 L99327;
}



// enclose check for Via8 inside metal8_conn <0.005  insideOnly
rule VIA8.E.1 {
    caption VIA8.E.1: Metal8 to Via8 enclosure must be >= 0.005 um;
    enc Via8 metal8_conn -lt 0.005 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via8 inside metal8_conn <0.03  oppSides
// for oppSides use sizing and straddle checks
and Via8 metal8_conn L2157;
rule VIA8.E.2 {
    caption VIA8.E.2: Metal8 to Via8 enclosure on opposite sides must be >= 0.03 um;
    grow L2157 -left 0.03 -right 0.03 L82623;
    select -inside L82623 metal8_conn L55130;
    not L2157 L55130 L10147;
    grow L10147 -top 0.03 -bottom 0.03 L58106;
    select -inside L58106 metal8_conn L29085;
    not L10147 L29085;
}



// enclose check for Via9 inside metal9_conn <0.015  insideOnly
rule VIA9.E.1 {
    caption VIA9.E.1: Metal9 to Via9 enclosure must be >= 0.015 um;
    enc Via9 metal9_conn -lt 0.015 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via9 inside metal9_conn <0.04  oppSides
// for oppSides use sizing and straddle checks
and Via9 metal9_conn L28301;
rule VIA9.E.2 {
    caption VIA9.E.2: Metal9 to Via9 enclosure on opposite sides must be >= 0.04 um;
    grow L28301 -left 0.04 -right 0.04 L32306;
    select -inside L32306 metal9_conn L19774;
    not L28301 L19774 L42543;
    grow L42543 -top 0.04 -bottom 0.04 L24121;
    select -inside L24121 metal9_conn L36362;
    not L42543 L36362;
}



// enclose check for Via10 inside Metal10 <0.015  insideOnly
rule VIA10.E.1 {
    caption VIA10.E.1: Metal10 to Via10 enclosure must be >= 0.015 um;
    enc Via10 Metal10 -lt 0.015 -output region -singular -abut lt 90 -outside_also;
}



// enclose check for Via10 inside Metal10 <0.04  oppSides
// for oppSides use sizing and straddle checks
and Metal10 Via10 L1578;
rule VIA10.E.2 {
    caption VIA10.E.2: Metal10 to Via10 enclosure on opposite sides must be >= 0.04 um;
    grow L1578 -left 0.04 -right 0.04 L13315;
    select -inside L13315 Metal10 L77898;
    not L1578 L77898 L22439;
    grow L22439 -top 0.04 -bottom 0.04 L21067;
    select -inside L21067 Metal10 L87079;
    not L22439 L87079;
}


// data on layer rule_VIA1_E_3 is always an error

rule VIA1.E.3 {
    caption VIA1.E.3: At least 2 Via1 must be used to join Metal1 and Metal2 when they are within 3.0um of a metal plate (Metal1/Metal2) when the metal plate size is has width > 1.5 and length > 1.5;
    copy rule_VIA1_E_3;
}


// data on layer rule_VIA2_E_3 is always an error

rule VIA2.E.3 {
    caption VIA2.E.3: At least 2 Via2 must be used to join Metal2 and Metal3 when they are within 3.0um of a metal plate (Metal2/Metal3) when the metal plate size is has width > 1.5 and length > 1.5;
    copy rule_VIA2_E_3;
}


// data on layer rule_VIA3_E_3 is always an error

rule VIA3.E.3 {
    caption VIA3.E.3: At least 2 Via3 must be used to join Metal3 and Metal4 when they are within 3.0um of a metal plate (Metal3/Metal4) when the metal plate size is has width > 1.5 and length > 1.5;
    copy rule_VIA3_E_3;
}


// data on layer rule_VIA4_E_3 is always an error

rule VIA4.E.3 {
    caption VIA4.E.3: At least 2 Via4 must be used to join Metal4 and Metal5 when they are within 3.0um of a metal plate (Metal4/Metal5) when the metal plate size is has width > 1.5 and length > 1.5;
    copy rule_VIA4_E_3;
}


// data on layer rule_VIA5_E_3 is always an error

rule VIA5.E.3 {
    caption VIA5.E.3: At least 2 Via5 must be used to join Metal5 and Metal6 when they are within 3.0um of a metal plate (Metal5/Metal6) when the metal plate size is has width > 1.5 and length > 1.5;
    copy rule_VIA5_E_3;
}


// data on layer rule_VIA6_E_3 is always an error

rule VIA6.E.3 {
    caption VIA6.E.3: At least 2 Via6 must be used to join Metal6 and Metal7 when they are within 3.0um of a metal plate (Metal6/Metal7) when the metal plate size is has width > 1.5 and length > 1.5;
    copy rule_VIA6_E_3;
}


// data on layer rule_VIA7_E_3 is always an error

rule VIA7.E.3 {
    caption VIA7.E.3: At least 2 Via7 must be used to join Metal7 and Metal8 when they are within 3.0um of a metal plate (Metal7/Metal8) when the metal plate size is has width > 1.5 and length > 1.5;
    copy rule_VIA7_E_3;
}


// data on layer rule_VIA8_E_3 is always an error

rule VIA8.E.3 {
    caption VIA8.E.3: At least 2 Via8 must be used to join Metal8 and Metal9 when they are within 3.0um of a metal plate (Metal8/Metal9) when the metal plate size is has width > 1.5 and length > 1.5;
    copy rule_VIA8_E_3;
}


// data on layer rule_VIA1_X_1 is always an error

rule VIA1.X.1 {
    caption VIA1.X.1: Metal1 must connect to Metal2 with >= 2 Via1 spaced < 0.30 um or >= 4 Via1 spaced < 0.60 um;
    copy rule_VIA1_X_1;
}


// data on layer rule_VIA2_X_1 is always an error

rule VIA2.X.1 {
    caption VIA2.X.1: Metal2 must connect to Metal3 with >= 2 Via2 spaced < 0.30 um or >= 4 Via2 spaced < 0.60 um;
    copy rule_VIA2_X_1;
}


// data on layer rule_VIA3_X_1 is always an error

rule VIA3.X.1 {
    caption VIA3.X.1: Metal3 must connect to Metal4 with >= 2 Via3 spaced < 0.30 um or >= 4 Via3 spaced < 0.60 um;
    copy rule_VIA3_X_1;
}


// data on layer rule_VIA4_X_1 is always an error

rule VIA4.X.1 {
    caption VIA4.X.1: Metal4 must connect to Metal5 with >= 2 Via4 spaced < 0.30 um or >= 4 Via4 spaced < 0.60 um;
    copy rule_VIA4_X_1;
}


// data on layer rule_VIA5_X_1 is always an error

rule VIA5.X.1 {
    caption VIA5.X.1: Metal5 must connect to Metal6 with >= 2 Via5 spaced < 0.30 um or >= 4 Via5 spaced < 0.60 um;
    copy rule_VIA5_X_1;
}


// data on layer rule_VIA6_X_1 is always an error

rule VIA6.X.1 {
    caption VIA6.X.1: Metal6 must connect to Metal7 with >= 2 Via6 spaced < 0.30 um or >= 4 Via6 spaced < 0.60 um;
    copy rule_VIA6_X_1;
}


// data on layer rule_VIA7_X_1 is always an error

rule VIA7.X.1 {
    caption VIA7.X.1: Metal7 must connect to Metal8 with >= 2 Via7 spaced < 0.30 um or >= 4 Via7 spaced < 0.60 um;
    copy rule_VIA7_X_1;
}


// data on layer rule_VIA8_X_1 is always an error

rule VIA8.X.1 {
    caption VIA8.X.1: Metal8 must connect to Metal9 with >= 2 Via8 spaced < 0.30 um or >= 4 Via8 spaced < 0.60 um;
    copy rule_VIA8_X_1;
}


// data on layer rule_VIA1_X_2 is always an error

rule VIA1.X.2 {
    caption VIA1.X.2: Metal1 must connect to Metal2 with >= 4 Via1 spaced < 0.30 um or >= 9 Via1 spaced < 0.60 um;
    copy rule_VIA1_X_2;
}


// data on layer rule_VIA2_X_2 is always an error

rule VIA2.X.2 {
    caption VIA2.X.2: Metal2 must connect to Metal3 with >= 4 Via2 spaced < 0.30 um or >= 9 Via2 spaced < 0.60 um;
    copy rule_VIA2_X_2;
}


// data on layer rule_VIA3_X_2 is always an error

rule VIA3.X.2 {
    caption VIA3.X.2: Metal3 must connect to Metal4 with >= 4 Via3 spaced < 0.30 um or >= 9 Via3 spaced < 0.60 um;
    copy rule_VIA3_X_2;
}


// data on layer rule_VIA4_X_2 is always an error

rule VIA4.X.2 {
    caption VIA4.X.2: Metal4 must connect to Metal5 with >= 4 Via4 spaced < 0.30 um or >= 9 Via4 spaced < 0.60 um;
    copy rule_VIA4_X_2;
}


// data on layer rule_VIA5_X_2 is always an error

rule VIA5.X.2 {
    caption VIA5.X.2: Metal5 must connect to Metal6 with >= 4 Via5 spaced < 0.30 um or >= 9 Via5 spaced < 0.60 um;
    copy rule_VIA5_X_2;
}


// data on layer rule_VIA6_X_2 is always an error

rule VIA6.X.2 {
    caption VIA6.X.2: Metal6 must connect to Metal7 with >= 4 Via6 spaced < 0.30 um or >= 9 Via6 spaced < 0.60 um;
    copy rule_VIA6_X_2;
}


// data on layer rule_VIA7_X_2 is always an error

rule VIA7.X.2 {
    caption VIA7.X.2: Metal7 must connect to Metal8 with >= 4 Via7 spaced < 0.30 um or >= 9 Via7 spaced < 0.60 um;
    copy rule_VIA7_X_2;
}


// data on layer rule_VIA8_X_2 is always an error

rule VIA8.X.2 {
    caption VIA8.X.2: Metal8 must connect to Metal9 with >= 4 Via8 spaced < 0.30 um or >= 9 Via8 spaced < 0.60 um;
    copy rule_VIA8_X_2;
}


// data on layer rule_VIAk_X_3_X_4a is always an error

rule VIAk.X.3_VIAk.X.4 {
    caption VIAk.X.3_VIAk.X.4: Metal1 through Metal6 stack must have two or more stacked Vias at all levels;
    copy rule_VIAk_X_3_X_4a;
}


// data on layer rule_VIAk_X_3_X_4b is always an error

rule VIAk.X.3_VIAk.X.4_2 {
    caption VIAk.X.3_VIAk.X.4: Metal2 through Metal7 stack must have two or more stacked Vias at all levels;
    copy rule_VIAk_X_3_X_4b;
}


// data on layer rule_VIAk_X_3_X_4c is always an error

rule VIAk.X.3_VIAk.X.4_3 {
    caption VIAk.X.3_VIAk.X.4: Metal3 through Metal8 stack must have two or more stacked Vias at all levels;
    copy rule_VIAk_X_3_X_4c;
}


// data on layer rule_VIAk_X_3_X_4d is always an error

rule VIAk.X.3_VIAk.X.4_4 {
    caption VIAk.X.3_VIAk.X.4: Metal4 through Metal9 stack must have two or more stacked Vias at all levels;
    copy rule_VIAk_X_3_X_4d;
}

// building polygons for layer ntap
// inside layer Nwell
and Nwell ntap L89122;

// building polygons for layer psd
// inside layer Nwell
and Nwell psd L19028;

// spacing check for L89122 and L19028 >20.0  in tub Nwell
// distance to far edge is done with sizing
// this is a tub rule
size L89122 -by 20.0 -inside_of Nwell -step 0.6 L97857;
rule LATCHUP.1 {
    caption LATCHUP.1: The maximum distance from any point in a P+ source/drain Active Area to the nearest Nwell pick-up in the same Nwell >= 20.0 um;
    not L19028 L97857;
}

not bulk Nwell L8219;
// building polygons for layer ptap
// inside layer !Nwell
not ptap Nwell L47516;

// building polygons for layer nsd
// inside layers !NPNdummy !Nwell !PNPdummy
or NPNdummy Nwell L88683;
or L88683 PNPdummy L29684;
not nsd L29684 L62163;

// spacing check for L47516 and L62163 >20.0  in tub !Nwell
// distance to far edge is done with sizing
// this is a tub rule
size L47516 -by 20.0 -inside_of L8219 -step 0.21 L35547;
rule LATCHUP.2 {
    caption LATCHUP.2: The maximum distance from any point in a N+ source/drain Active Area to the nearest Psub pick-up in the same Psub >= 20.0 um;
    not L62163 L35547;
}



// spacing check for nmos_io_esd and pmos_io_esd <10.0 
rule LATCHUP.3 {
    caption LATCHUP.3: Minimum I/O or ESD NMOS to PMOS spacing >= 10.0 um;
// output parts of shapes that intersect
    select -cut nmos_io_esd pmos_io_esd L53421;
    Select -cut pmos_io_esd nmos_io_esd L63347;
    and L53421 L63347;
    exte nmos_io_esd pmos_io_esd -lt 10.0 -output region -singular -abut lt 90
}



// spacing check for nmos_io_esd and pmos_io_esd <30.0 
rule LATCHUP.4 {
    caption LATCHUP.4: Minimum I/O or ESD NMOS to PMOS spacing when not blocked by a double guardring >= 30.0 um;
// output parts of shapes that intersect
    select -cut nmos_io_esd pmos_io_esd L53422;
    Select -cut pmos_io_esd nmos_io_esd L63348;
    and L53422 L63348;
// rule only applies if not blocked by other layers
    exte nmos_io_esd pmos_io_esd -lt 30.0 -output region -singular -abut lt 90 L51316;
    not L51316 ntap L35560;
    select -interact L35560 nmos_io_esd L11845;
    select -interact L11845 pmos_io_esd;
    not L51316 ptap L75978;
    select -interact L75978 nmos_io_esd L83094;
    select -interact L83094 pmos_io_esd;
}

// building polygons for layer Poly
// inside layers ESDdummy Oxide
and ESDdummy Oxide L23388;
edge_boolean -inside Poly L23388 L23479;

// segment length check for L23479 <10.0 or >30.0 
rule ESD.1 {
    caption ESD.1: ESD gate width must be >= 10.0 um and <= 30.0 um;
    edge_length -not L23479 -ge 10.0 -le 30.0;
}

// building polygons for layer rule_ESD_4_nmos
// inside layer ESDdummy
and ESDdummy rule_ESD_4_nmos L59531;

// data on layer L59531 is always an error
// building polygons for layer rule_ESD_4_nmos
// inside layer ESDdummy
// L59531 = and ESDdummy rule_ESD_4_nmos

rule ESD.4 {
    caption ESD.4: N+ source should connect to Pad or Bulk;
    copy L59531;
}

// building polygons for layer rule_ESD_4_pmos
// inside layer ESDdummy
and ESDdummy rule_ESD_4_pmos L99949;

// data on layer L99949 is always an error
// building polygons for layer rule_ESD_4_pmos
// inside layer ESDdummy
// L99949 = and ESDdummy rule_ESD_4_pmos

rule ESD.4_2 {
    caption ESD.4: P+ source should connect to Pad or Nwell;
    copy L99949;
}

// building polygons for layer rule_ESD_5
// inside layer ESDdummy
and ESDdummy rule_ESD_5 L90158;

// data on layer L90158 is always an error
// building polygons for layer rule_ESD_5
// inside layer ESDdummy
// L90158 = and ESDdummy rule_ESD_5

rule ESD.5 {
    caption ESD.5: NMOS I/O and ESD devices must be inside P+ rings;
    copy L90158;
}

// building polygons for layer rule_ESD_6
// inside layer ESDdummy
and ESDdummy rule_ESD_6 L90159;

// data on layer L90159 is always an error
// building polygons for layer rule_ESD_6
// inside layer ESDdummy
// L90159 = and ESDdummy rule_ESD_6

rule ESD.6 {
    caption ESD.6: PMOS I/O and ESD devices must be inside N+ rings;
    copy L90159;
}

// building polygons for layer rule_ESD_7_nmos
// inside layer ESDdummy
and ESDdummy rule_ESD_7_nmos L72078;

// data on layer L72078 is always an error
// building polygons for layer rule_ESD_7_nmos
// inside layer ESDdummy
// L72078 = and ESDdummy rule_ESD_7_nmos

rule ESD.7 {
    caption ESD.7: P+ taps can NOT butt NMOS I/O and ESD devices;
    copy L72078;
}

// building polygons for layer rule_ESD_7_pmos
// inside layer ESDdummy
and ESDdummy rule_ESD_7_pmos L12496;

// data on layer L12496 is always an error
// building polygons for layer rule_ESD_7_pmos
// inside layer ESDdummy
// L12496 = and ESDdummy rule_ESD_7_pmos

rule ESD.7_2 {
    caption ESD.7: N+ taps can NOT butt PMOS I/O and ESD devices;
    copy L12496;
}

// building polygons for layer rule_ESD_8_nmos
// inside layer ESDdummy
and ESDdummy rule_ESD_8_nmos L42927;

// data on layer L42927 is always an error
// building polygons for layer rule_ESD_8_nmos
// inside layer ESDdummy
// L42927 = and ESDdummy rule_ESD_8_nmos

rule ESD.8 {
    caption ESD.8: N+ drains must be non-salicided (except Contact area);
    copy L42927;
}

// building polygons for layer rule_ESD_8_pmos
// inside layer ESDdummy
and ESDdummy rule_ESD_8_pmos L83345;

// data on layer L83345 is always an error
// building polygons for layer rule_ESD_8_pmos
// inside layer ESDdummy
// L83345 = and ESDdummy rule_ESD_8_pmos

rule ESD.8_2 {
    caption ESD.8: P+ drains must be non-salicided (except Contact area);
    copy L83345;
}

// building polygons for layer Poly
// inside layers ESDdummy Oxide
// L23388 = and ESDdummy Oxide
// L23479 = edge_boolean -inside Poly L23388

// building polygons for layer SiProt
// inside layers ESDdummy Oxide
// L23388 = and ESDdummy Oxide
edge_boolean -inside SiProt L23388 L9896;

// overlap check for L23479 and L9896 <0.05 
rule ESD.11 {
    caption ESD.11: Minimum SiProt to Poly gate overlap in NMOS and PMOS drains >= 0.05 um;
    inte L23479 L9896 -lt 0.05 -output region -abut lt 90;
}

// building polygons for layer Poly
// inside layers ESDdummy Oxide
// L23388 = and ESDdummy Oxide
// L23479 = edge_boolean -inside Poly L23388

// building polygons for layer SiProt
// inside layers ESDdummy Oxide
// L23388 = and ESDdummy Oxide
// L9896 = edge_boolean -inside SiProt L23388

// enclose check for L23479 inside L9896 <0.9  overlapOK
rule ESD.12 {
    caption ESD.12: Minimum enclosure of SiProt edge to Poly gate edge in NMOS and PMOS drains >= 0.9 um;
    enc L23479 L9896 -lt 0.9 -output region -abut lt 90;
}

// building polygons for layer Oxide
// inside layer ESDdummy
// L23388 = and ESDdummy Oxide

// building polygons for layer SiProt
// inside layer ESDdummy
and ESDdummy SiProt L88738;

// overlap check for L23388 and L88738 <0.9 
rule ESD.13 {
    caption ESD.13: Minimum SiProt to Oxide overlap in NMOS and PMOS I/O drains >= 0.9 um;
    inte L23388 L88738 -lt 0.9 -output region -singular -abut lt 90;
}

// building polygons for layer Oxide
// inside layers ESDdummy Poly
and ESDdummy Poly L23215;
edge_boolean -inside Oxide L23215 L43257;

// segment length check for L43257 !=0.2 
rule ESD.14 {
    caption ESD.14: Exact gate length of NMOS and PMOS in I/O buffers and in Vdd to Vss ESD protection == 0.2 um;
    edge_length L43257 -ne 0.2;
}

// building polygons for layer Cont
// inside layers ESDdummy Oxide
// L23388 = and ESDdummy Oxide
and Cont L23388 L43275;

// building polygons for layer Poly
// inside layers ESDdummy Oxide
// L23388 = and ESDdummy Oxide
// L23479 = edge_boolean -inside Poly L23388

// spacing check for L43275 and L23479 <0.12 
rule ESD.15 {
    caption ESD.15: Minimu Poly gate to Contact spacing in NMOS and PMOS in I/O buffers and in Vdd to Vss ESD protection >= 0.12 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
    edge_expand L43275 -inside_by 0.001 L39241;
    edge_expand L23479 -inside_by 0.001 L64525;
    and L39241 L64525;
    exte L43275 L23479 -lt 0.12 -output region -abut lt 90
}



// enclose check for Bondpad inside bondpad_metal1_filled <2.0 
rule BONDPAD.E.1 {
    caption BONDPAD.E.1: Metal1 to Bondpad enclosure must be >= 2.0 um;
// output shapes that intersect
    select -cut Bondpad bondpad_metal1_filled L93393;
    not L93393 bondpad_metal1_filled;
    enc Bondpad bondpad_metal1_filled -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Metal1 and bondpad_metal1_filled <3.0  overlapOK
rule BONDPAD.SP.2 {
    caption BONDPAD.SP.2: Bondpad Metal1 to Metal1 spacing must be >= 3.0 um;
    exte Metal1 bondpad_metal1_filled -lt 3.0 -output region -singular -abut lt 90
}



// enclose check for Bondpad inside bondpad_metal2_filled <2.0 
rule BONDPAD.E.1_2 {
    caption BONDPAD.E.1: Metal2 to Bondpad enclosure must be >= 2.0 um;
// output shapes that intersect
    select -cut Bondpad bondpad_metal2_filled L3728;
    not L3728 bondpad_metal2_filled;
    enc Bondpad bondpad_metal2_filled -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Metal2 and bondpad_metal2_filled <3.0  overlapOK
rule BONDPAD.SP.2_2 {
    caption BONDPAD.SP.2: Bondpad Metal2 to Metal2 spacing must be >= 3.0 um;
    exte Metal2 bondpad_metal2_filled -lt 3.0 -output region -singular -abut lt 90
}



// enclose check for Bondpad inside bondpad_metal3_filled <2.0 
rule BONDPAD.E.1_3 {
    caption BONDPAD.E.1: Metal3 to Bondpad enclosure must be >= 2.0 um;
// output shapes that intersect
    select -cut Bondpad bondpad_metal3_filled L53233;
    not L53233 bondpad_metal3_filled;
    enc Bondpad bondpad_metal3_filled -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Metal3 and bondpad_metal3_filled <3.0  overlapOK
rule BONDPAD.SP.2_3 {
    caption BONDPAD.SP.2: Bondpad Metal3 to Metal3 spacing must be >= 3.0 um;
    exte Metal3 bondpad_metal3_filled -lt 3.0 -output region -singular -abut lt 90
}



// enclose check for Bondpad inside bondpad_metal4_filled <2.0 
rule BONDPAD.E.1_4 {
    caption BONDPAD.E.1: Metal4 to Bondpad enclosure must be >= 2.0 um;
// output shapes that intersect
    select -cut Bondpad bondpad_metal4_filled L57102;
    not L57102 bondpad_metal4_filled;
    enc Bondpad bondpad_metal4_filled -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Metal4 and bondpad_metal4_filled <3.0  overlapOK
rule BONDPAD.SP.2_4 {
    caption BONDPAD.SP.2: Bondpad Metal4 to Metal4 spacing must be >= 3.0 um;
    exte Metal4 bondpad_metal4_filled -lt 3.0 -output region -singular -abut lt 90
}



// enclose check for Bondpad inside bondpad_metal5_filled <2.0 
rule BONDPAD.E.1_5 {
    caption BONDPAD.E.1: Metal5 to Bondpad enclosure must be >= 2.0 um;
// output shapes that intersect
    select -cut Bondpad bondpad_metal5_filled L99859;
    not L99859 bondpad_metal5_filled;
    enc Bondpad bondpad_metal5_filled -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Metal5 and bondpad_metal5_filled <3.0  overlapOK
rule BONDPAD.SP.2_5 {
    caption BONDPAD.SP.2: Bondpad Metal5 to Metal5 spacing must be >= 3.0 um;
    exte Metal5 bondpad_metal5_filled -lt 3.0 -output region -singular -abut lt 90
}



// enclose check for Bondpad inside bondpad_metal6_filled <2.0 
rule BONDPAD.E.1_6 {
    caption BONDPAD.E.1: Metal6 to Bondpad enclosure must be >= 2.0 um;
// output shapes that intersect
    select -cut Bondpad bondpad_metal6_filled L10476;
    not L10476 bondpad_metal6_filled;
    enc Bondpad bondpad_metal6_filled -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Metal6 and bondpad_metal6_filled <3.0  overlapOK
rule BONDPAD.SP.2_6 {
    caption BONDPAD.SP.2: Bondpad Metal6 to Metal6 spacing must be >= 3.0 um;
    exte Metal6 bondpad_metal6_filled -lt 3.0 -output region -singular -abut lt 90
}



// enclose check for Bondpad inside bondpad_metal7_filled <2.0 
rule BONDPAD.E.1_7 {
    caption BONDPAD.E.1: Metal7 to Bondpad enclosure must be >= 2.0 um;
// output shapes that intersect
    select -cut Bondpad bondpad_metal7_filled L46485;
    not L46485 bondpad_metal7_filled;
    enc Bondpad bondpad_metal7_filled -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Metal7 and bondpad_metal7_filled <3.0  overlapOK
rule BONDPAD.SP.2_7 {
    caption BONDPAD.SP.2: Bondpad Metal7 to Metal7 spacing must be >= 3.0 um;
    exte Metal7 bondpad_metal7_filled -lt 3.0 -output region -singular -abut lt 90
}



// enclose check for Bondpad inside bondpad_metal8_filled <2.0 
rule BONDPAD.E.1_8 {
    caption BONDPAD.E.1: Metal8 to Bondpad enclosure must be >= 2.0 um;
// output shapes that intersect
    select -cut Bondpad bondpad_metal8_filled L36150;
    not L36150 bondpad_metal8_filled;
    enc Bondpad bondpad_metal8_filled -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Metal8 and bondpad_metal8_filled <3.0  overlapOK
rule BONDPAD.SP.2_8 {
    caption BONDPAD.SP.2: Bondpad Metal8 to Metal8 spacing must be >= 3.0 um;
    exte Metal8 bondpad_metal8_filled -lt 3.0 -output region -singular -abut lt 90
}



// enclose check for Bondpad inside bondpad_metal9_filled <2.0 
rule BONDPAD.E.1_9 {
    caption BONDPAD.E.1: Metal9 to Bondpad enclosure must be >= 2.0 um;
// output shapes that intersect
    select -cut Bondpad bondpad_metal9_filled L74185;
    not L74185 bondpad_metal9_filled;
    enc Bondpad bondpad_metal9_filled -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Metal9 and bondpad_metal9_filled <3.0  overlapOK
rule BONDPAD.SP.2_9 {
    caption BONDPAD.SP.2: Bondpad Metal9 to Metal9 spacing must be >= 3.0 um;
    exte Metal9 bondpad_metal9_filled -lt 3.0 -output region -singular -abut lt 90
}



// enclose check for Bondpad inside bondpad_metal10_filled <2.0 
rule BONDPAD.E.1_10 {
    caption BONDPAD.E.1: Metal10 to Bondpad enclosure must be >= 2.0 um;
// output shapes that intersect
    select -cut Bondpad bondpad_metal10_filled L43841;
    not L43841 bondpad_metal10_filled;
    enc Bondpad bondpad_metal10_filled -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Metal10 and bondpad_metal10_filled <3.0  overlapOK
rule BONDPAD.SP.2_10 {
    caption BONDPAD.SP.2: Bondpad Metal10 to Metal10 spacing must be >= 3.0 um;
    exte Metal10 bondpad_metal10_filled -lt 3.0 -output region -singular -abut lt 90
}



// enclose check for Bondpad inside bondpad_metal11_filled <2.0 
rule BONDPAD.E.1_11 {
    caption BONDPAD.E.1: Metal11 to Bondpad enclosure must be >= 2.0 um;
// output shapes that intersect
    select -cut Bondpad bondpad_metal11_filled L13120;
    not L13120 bondpad_metal11_filled;
    enc Bondpad bondpad_metal11_filled -lt 2.0 -output region -singular -abut lt 90;
}



// spacing check for Metal11 and bondpad_metal11_filled <3.0  overlapOK
rule BONDPAD.SP.2_11 {
    caption BONDPAD.SP.2: Bondpad Metal11 to Metal11 spacing must be >= 3.0 um;
    exte Metal11 bondpad_metal11_filled -lt 3.0 -output region -singular -abut lt 90
}


// data on layer rule_BONDPAD_B_1_m1 is always an error

rule BONDPAD.B.1A {
    caption BONDPAD.B.1A: Bondpad Metal1 must have bevelled corners;
    copy rule_BONDPAD_B_1_m1;
}


// data on layer rule_BONDPAD_B_1_m2 is always an error

rule BONDPAD.B.1A_2 {
    caption BONDPAD.B.1A: Bondpad Metal2 must have bevelled corners;
    copy rule_BONDPAD_B_1_m2;
}


// data on layer rule_BONDPAD_B_1_m3 is always an error

rule BONDPAD.B.1A_3 {
    caption BONDPAD.B.1A: Bondpad Metal3 must have bevelled corners;
    copy rule_BONDPAD_B_1_m3;
}


// data on layer rule_BONDPAD_B_1_m4 is always an error

rule BONDPAD.B.1A_4 {
    caption BONDPAD.B.1A: Bondpad Metal4 must have bevelled corners;
    copy rule_BONDPAD_B_1_m4;
}


// data on layer rule_BONDPAD_B_1_m5 is always an error

rule BONDPAD.B.1A_5 {
    caption BONDPAD.B.1A: Bondpad Metal5 must have bevelled corners;
    copy rule_BONDPAD_B_1_m5;
}


// data on layer rule_BONDPAD_B_1_m6 is always an error

rule BONDPAD.B.1A_6 {
    caption BONDPAD.B.1A: Bondpad Metal6 must have bevelled corners;
    copy rule_BONDPAD_B_1_m6;
}


// data on layer rule_BONDPAD_B_1_m7 is always an error

rule BONDPAD.B.1A_7 {
    caption BONDPAD.B.1A: Bondpad Metal7 must have bevelled corners;
    copy rule_BONDPAD_B_1_m7;
}


// data on layer rule_BONDPAD_B_1_m8 is always an error

rule BONDPAD.B.1A_8 {
    caption BONDPAD.B.1A: Bondpad Metal8 must have bevelled corners;
    copy rule_BONDPAD_B_1_m8;
}


// data on layer rule_BONDPAD_B_1_m9 is always an error

rule BONDPAD.B.1A_9 {
    caption BONDPAD.B.1A: Bondpad Metal9 must have bevelled corners;
    copy rule_BONDPAD_B_1_m9;
}


// data on layer rule_BONDPAD_B_1_m10 is always an error

rule BONDPAD.B.1A_10 {
    caption BONDPAD.B.1A: Bondpad Metal10 must have bevelled corners;
    copy rule_BONDPAD_B_1_m10;
}


// data on layer rule_BONDPAD_B_1_m11 is always an error

rule BONDPAD.B.1A_11 {
    caption BONDPAD.B.1A: Bondpad Metal11 must have bevelled corners;
    copy rule_BONDPAD_B_1_m11;
}



// spacing check for bondpad_sq and bondpad_to_die_edge <5.0  errorLengthA <55.0
rule BONDPAD.W.1 {
    caption BONDPAD.W.1: Bondpad width must be >= 55.0 um;
// output parts of shapes that intersect
    select -cut bondpad_sq bondpad_to_die_edge L38661;
    Select -cut bondpad_to_die_edge bondpad_sq L84099;
    and L38661 L84099;
    exte bondpad_sq bondpad_to_die_edge -lt 5.0 -output positive1  -singular -abut lt 90 L54252;
    edge_length L54252 -lt 55.0;
}


// spacing check for Bondpad <8.0 
rule BONDPAD.SP.1 {
    caption BONDPAD.SP.1: Bondpad to Bondpad spacing must be >= 8.0 um;
    exte Bondpad Bondpad -lt 8.0 -output region -singular -abut lt 90;
}


// data on layer rule_BONDPAD_L_1 is always an error

rule BONDPAD.L.1 {
    caption BONDPAD.L.1: Bondpad length must be >= 68.0 um;
    copy rule_BONDPAD_L_1;
}

// building polygons for layer bondpad_metal1
// with angle !=90
angle bondpad_metal1 -ltgt 0 90 L43679;

// segment length check for L43679 <1.8 or >3.2 
rule BONDPAD.B.1B {
    caption BONDPAD.B.1B: Bondpad Metal1 beveled segments must be >= 1.8 um and <= 3.2 um;
    edge_length -not L43679 -ge 1.8 -le 3.2;
}

// building polygons for layer bondpad_metal2
// with angle !=90
angle bondpad_metal2 -ltgt 0 90 L26398;

// segment length check for L26398 <1.8 or >3.2 
rule BONDPAD.B.1B_2 {
    caption BONDPAD.B.1B: Bondpad Metal2 beveled segments must be >= 1.8 um and <= 3.2 um;
    edge_length -not L26398 -ge 1.8 -le 3.2;
}

// building polygons for layer bondpad_metal3
// with angle !=90
angle bondpad_metal3 -ltgt 0 90 L9117;

// segment length check for L9117 <1.8 or >3.2 
rule BONDPAD.B.1B_3 {
    caption BONDPAD.B.1B: Bondpad Metal3 beveled segments must be >= 1.8 um and <= 3.2 um;
    edge_length -not L9117 -ge 1.8 -le 3.2;
}

// building polygons for layer bondpad_metal4
// with angle !=90
angle bondpad_metal4 -ltgt 0 90 L91836;

// segment length check for L91836 <1.8 or >3.2 
rule BONDPAD.B.1B_4 {
    caption BONDPAD.B.1B: Bondpad Metal4 beveled segments must be >= 1.8 um and <= 3.2 um;
    edge_length -not L91836 -ge 1.8 -le 3.2;
}

// building polygons for layer bondpad_metal5
// with angle !=90
angle bondpad_metal5 -ltgt 0 90 L74555;

// segment length check for L74555 <1.8 or >3.2 
rule BONDPAD.B.1B_5 {
    caption BONDPAD.B.1B: Bondpad Metal5 beveled segments must be >= 1.8 um and <= 3.2 um;
    edge_length -not L74555 -ge 1.8 -le 3.2;
}

// building polygons for layer bondpad_metal6
// with angle !=90
angle bondpad_metal6 -ltgt 0 90 L57274;

// segment length check for L57274 <1.8 or >3.2 
rule BONDPAD.B.1B_6 {
    caption BONDPAD.B.1B: Bondpad Metal6 beveled segments must be >= 1.8 um and <= 3.2 um;
    edge_length -not L57274 -ge 1.8 -le 3.2;
}

// building polygons for layer bondpad_metal7
// with angle !=90
angle bondpad_metal7 -ltgt 0 90 L39993;

// segment length check for L39993 <1.8 or >3.2 
rule BONDPAD.B.1B_7 {
    caption BONDPAD.B.1B: Bondpad Metal7 beveled segments must be >= 1.8 um and <= 3.2 um;
    edge_length -not L39993 -ge 1.8 -le 3.2;
}

// building polygons for layer bondpad_metal8
// with angle !=90
angle bondpad_metal8 -ltgt 0 90 L22712;

// segment length check for L22712 <1.8 or >3.2 
rule BONDPAD.B.1B_8 {
    caption BONDPAD.B.1B: Bondpad Metal8 beveled segments must be >= 1.8 um and <= 3.2 um;
    edge_length -not L22712 -ge 1.8 -le 3.2;
}

// building polygons for layer bondpad_metal9
// with angle !=90
angle bondpad_metal9 -ltgt 0 90 L5431;

// segment length check for L5431 <1.8 or >3.2 
rule BONDPAD.B.1B_9 {
    caption BONDPAD.B.1B: Bondpad Metal9 beveled segments must be >= 1.8 um and <= 3.2 um;
    edge_length -not L5431 -ge 1.8 -le 3.2;
}

// building polygons for layer bondpad_metal10
// with angle !=90
angle bondpad_metal10 -ltgt 0 90 L35077;

// segment length check for L35077 <1.8 or >3.2 
rule BONDPAD.B.1B_10 {
    caption BONDPAD.B.1B: Bondpad Metal10 beveled segments must be >= 1.8 um and <= 3.2 um;
    edge_length -not L35077 -ge 1.8 -le 3.2;
}

// building polygons for layer bondpad_metal11
// with angle !=90
angle bondpad_metal11 -ltgt 0 90 L52358;

// segment length check for L52358 <1.8 or >3.2 
rule BONDPAD.B.1B_11 {
    caption BONDPAD.B.1B: Bondpad Metal11 beveled segments must be >= 1.8 um and <= 3.2 um;
    edge_length -not L52358 -ge 1.8 -le 3.2;
}

// building polygons for layer Via1
// inside layer bondpad_metal1
and Via1 bondpad_metal1 L87123;

// spacing check for L87123 <0.22 
rule BONDPAD.SP.3 {
    caption BONDPAD.SP.3: Bondpad Via1 to Bondpad Via1 spacing must be >= 0.22 um;
    exte L87123 L87123 -lt 0.22 -output region -singular -abut lt 90;
}

// building polygons for layer Via2
// inside layer bondpad_metal2
and Via2 bondpad_metal2 L21299;

// spacing check for L21299 <0.22 
rule BONDPAD.SP.3_2 {
    caption BONDPAD.SP.3: Bondpad Via2 to Bondpad Via2 spacing must be >= 0.22 um;
    exte L21299 L21299 -lt 0.22 -output region -singular -abut lt 90;
}

// building polygons for layer Via3
// inside layer bondpad_metal3
and Via3 bondpad_metal3 L55475;

// spacing check for L55475 <0.22 
rule BONDPAD.SP.3_3 {
    caption BONDPAD.SP.3: Bondpad Via3 to Bondpad Via3 spacing must be >= 0.22 um;
    exte L55475 L55475 -lt 0.22 -output region -singular -abut lt 90;
}

// building polygons for layer Via4
// inside layer bondpad_metal4
and Via4 bondpad_metal4 L77645;

// spacing check for L77645 <0.22 
rule BONDPAD.SP.3_4 {
    caption BONDPAD.SP.3: Bondpad Via4 to Bondpad Via4 spacing must be >= 0.22 um;
    exte L77645 L77645 -lt 0.22 -output region -singular -abut lt 90;
}

// building polygons for layer Via5
// inside layer bondpad_metal5
and Via5 bondpad_metal5 L43469;

// spacing check for L43469 <0.22 
rule BONDPAD.SP.3_5 {
    caption BONDPAD.SP.3: Bondpad Via5 to Bondpad Via5 spacing must be >= 0.22 um;
    exte L43469 L43469 -lt 0.22 -output region -singular -abut lt 90;
}

// building polygons for layer Via6
// inside layer bondpad_metal6
and Via6 bondpad_metal6 L9293;

// spacing check for L9293 <0.22 
rule BONDPAD.SP.3_6 {
    caption BONDPAD.SP.3: Bondpad Via6 to Bondpad Via6 spacing must be >= 0.22 um;
    exte L9293 L9293 -lt 0.22 -output region -singular -abut lt 90;
}

// building polygons for layer Via7
// inside layer bondpad_metal7
and Via7 bondpad_metal7 L75117;

// spacing check for L75117 <0.22 
rule BONDPAD.SP.4 {
    caption BONDPAD.SP.4: Bondpad Via7 to Bondpad Via7 spacing must be >= 0.22 um;
    exte L75117 L75117 -lt 0.22 -output region -singular -abut lt 90;
}

// building polygons for layer Via8
// inside layer bondpad_metal8
and Via8 bondpad_metal8 L40941;

// spacing check for L40941 <0.22 
rule BONDPAD.SP.4_2 {
    caption BONDPAD.SP.4: Bondpad Via8 to Bondpad Via8 spacing must be >= 0.22 um;
    exte L40941 L40941 -lt 0.22 -output region -singular -abut lt 90;
}

// building polygons for layer Via9
// inside layer bondpad_metal9
and Via9 bondpad_metal9 L93235;

// spacing check for L93235 <0.54 
rule BONDPAD.SP.4_3 {
    caption BONDPAD.SP.4: Bondpad Via9 to Bondpad Via9 spacing must be >= 0.54 um;
    exte L93235 L93235 -lt 0.54 -output region -singular -abut lt 90;
}

// building polygons for layer Via10
// inside layer bondpad_metal10
and Via10 bondpad_metal10 L88219;

// spacing check for L88219 <0.54 
rule BONDPAD.SP.4_4 {
    caption BONDPAD.SP.4: Bondpad Via10 to Bondpad Via10 spacing must be >= 0.54 um;
    exte L88219 L88219 -lt 0.54 -output region -singular -abut lt 90;
}



// enclose check for Via1 inside bondpad_metal1 <0.05 
rule BONDPAD.E.2 {
    caption BONDPAD.E.2: Bondpad Metal1 to Via1 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via1 bondpad_metal1 L91026;
    not L91026 bondpad_metal1;
    enc Via1 bondpad_metal1 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via2 inside bondpad_metal2 <0.05 
rule BONDPAD.E.2_2 {
    caption BONDPAD.E.2: Bondpad Metal2 to Via2 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via2 bondpad_metal2 L25201;
    not L25201 bondpad_metal2;
    enc Via2 bondpad_metal2 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via3 inside bondpad_metal3 <0.05 
rule BONDPAD.E.2_3 {
    caption BONDPAD.E.2: Bondpad Metal3 to Via3 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via3 bondpad_metal3 L59377;
    not L59377 bondpad_metal3;
    enc Via3 bondpad_metal3 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via4 inside bondpad_metal4 <0.05 
rule BONDPAD.E.2_4 {
    caption BONDPAD.E.2: Bondpad Metal4 to Via4 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via4 bondpad_metal4 L73743;
    not L73743 bondpad_metal4;
    enc Via4 bondpad_metal4 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via5 inside bondpad_metal5 <0.05 
rule BONDPAD.E.2_5 {
    caption BONDPAD.E.2: Bondpad Metal5 to Via5 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via5 bondpad_metal5 L39567;
    not L39567 bondpad_metal5;
    enc Via5 bondpad_metal5 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via6 inside bondpad_metal6 <0.05 
rule BONDPAD.E.2_6 {
    caption BONDPAD.E.2: Bondpad Metal6 to Via6 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via6 bondpad_metal6 L5391;
    not L5391 bondpad_metal6;
    enc Via6 bondpad_metal6 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via7 inside bondpad_metal7 <0.05 
rule BONDPAD.E.3 {
    caption BONDPAD.E.3: Bondpad Metal7 to Via7 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via7 bondpad_metal7 L71215;
    not L71215 bondpad_metal7;
    enc Via7 bondpad_metal7 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via8 inside bondpad_metal8 <0.05 
rule BONDPAD.E.3_2 {
    caption BONDPAD.E.3: Bondpad Metal8 to Via8 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via8 bondpad_metal8 L62961;
    not L62961 bondpad_metal8;
    enc Via8 bondpad_metal8 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via9 inside bondpad_metal9 <0.09 
rule BONDPAD.E.3_3 {
    caption BONDPAD.E.3: Bondpad Metal9 to Via9 enclosure must be >= 0.09 um;
// output shapes that intersect
    select -cut Via9 bondpad_metal9 L97137;
    not L97137 bondpad_metal9;
    enc Via9 bondpad_metal9 -lt 0.09 -output region -singular -abut lt 90;
}



// enclose check for Via10 inside bondpad_metal10 <0.09 
rule BONDPAD.E.3_4 {
    caption BONDPAD.E.3: Bondpad Metal9 to Via10 enclosure must be >= 0.09 um;
// output shapes that intersect
    select -cut Via10 bondpad_metal10 L75427;
    not L75427 bondpad_metal10;
    enc Via10 bondpad_metal10 -lt 0.09 -output region -singular -abut lt 90;
}



// enclose check for Via1 inside bondpad_metal2 <0.05 
rule BONDPAD.E.2_7 {
    caption BONDPAD.E.2: Bondpad Metal2 to Via1 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via1 bondpad_metal2 L91024;
    not L91024 bondpad_metal2;
    enc Via1 bondpad_metal2 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via2 inside bondpad_metal3 <0.05 
rule BONDPAD.E.2_8 {
    caption BONDPAD.E.2: Bondpad Metal3 to Via2 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via2 bondpad_metal3 L25200;
    not L25200 bondpad_metal3;
    enc Via2 bondpad_metal3 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via3 inside bondpad_metal4 <0.05 
rule BONDPAD.E.2_9 {
    caption BONDPAD.E.2: Bondpad Metal4 to Via3 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via3 bondpad_metal4 L59376;
    not L59376 bondpad_metal4;
    enc Via3 bondpad_metal4 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via4 inside bondpad_metal5 <0.05 
rule BONDPAD.E.2_10 {
    caption BONDPAD.E.2: Bondpad Metal5 to Via4 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via4 bondpad_metal5 L73744;
    not L73744 bondpad_metal5;
    enc Via4 bondpad_metal5 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via5 inside bondpad_metal6 <0.05 
rule BONDPAD.E.2_11 {
    caption BONDPAD.E.2: Bondpad Metal6 to Via5 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via5 bondpad_metal6 L39568;
    not L39568 bondpad_metal6;
    enc Via5 bondpad_metal6 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via6 inside bondpad_metal7 <0.05 
rule BONDPAD.E.2_12 {
    caption BONDPAD.E.2: Bondpad Metal7 to Via6 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via6 bondpad_metal7 L5392;
    not L5392 bondpad_metal7;
    enc Via6 bondpad_metal7 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via7 inside bondpad_metal8 <0.05 
rule BONDPAD.E.3_5 {
    caption BONDPAD.E.3: Bondpad Metal8 to Via7 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via7 bondpad_metal8 L71216;
    not L71216 bondpad_metal8;
    enc Via7 bondpad_metal8 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via8 inside bondpad_metal9 <0.05 
rule BONDPAD.E.3_6 {
    caption BONDPAD.E.3: Bondpad Metal9 to Via8 enclosure must be >= 0.05 um;
// output shapes that intersect
    select -cut Via8 bondpad_metal9 L62960;
    not L62960 bondpad_metal9;
    enc Via8 bondpad_metal9 -lt 0.05 -output region -singular -abut lt 90;
}



// enclose check for Via9 inside bondpad_metal10 <0.09 
rule BONDPAD.E.3_7 {
    caption BONDPAD.E.3: Bondpad Metal10 to Via9 enclosure must be >= 0.09 um;
// output shapes that intersect
    select -cut Via9 bondpad_metal10 L25033;
    not L25033 bondpad_metal10;
    enc Via9 bondpad_metal10 -lt 0.09 -output region -singular -abut lt 90;
}



// enclose check for Via10 inside bondpad_metal11 <0.09 
rule BONDPAD.E.3_8 {
    caption BONDPAD.E.3: Bondpad Metal11 to Via10 enclosure must be >= 0.09 um;
// output shapes that intersect
    select -cut Via10 bondpad_metal11 L75426;
    not L75426 bondpad_metal11;
    enc Via10 bondpad_metal11 -lt 0.09 -output region -singular -abut lt 90;
}


// data on layer rule_BONDPAD_R_1_via1 is always an error

rule BONDPAD.R.1 {
    caption BONDPAD.R.1: Minimum Bondpad Via1 inside Metal1 to Metal2 crossing must be >= 16.0;
    copy rule_BONDPAD_R_1_via1;
}


// data on layer rule_BONDPAD_R_1_via2 is always an error

rule BONDPAD.R.1_2 {
    caption BONDPAD.R.1: Minimum Bondpad Via2 inside Metal2 to Metal3 crossing must be >= 16.0;
    copy rule_BONDPAD_R_1_via2;
}


// data on layer rule_BONDPAD_R_1_via3 is always an error

rule BONDPAD.R.1_3 {
    caption BONDPAD.R.1: Minimum Bondpad Via3 inside Metal3 to Metal4 crossing must be >= 16.0;
    copy rule_BONDPAD_R_1_via3;
}


// data on layer rule_BONDPAD_R_1_via4 is always an error

rule BONDPAD.R.1_4 {
    caption BONDPAD.R.1: Minimum Bondpad Via4 inside Metal4 to Metal5 crossing must be >= 16.0;
    copy rule_BONDPAD_R_1_via4;
}


// data on layer rule_BONDPAD_R_1_via5 is always an error

rule BONDPAD.R.1_5 {
    caption BONDPAD.R.1: Minimum Bondpad Via5 inside Metal5 to Metal6 crossing must be >= 16.0;
    copy rule_BONDPAD_R_1_via5;
}


// data on layer rule_BONDPAD_R_1_via6 is always an error

rule BONDPAD.R.1_6 {
    caption BONDPAD.R.1: Minimum Bondpad Via6 inside Metal6 to Metal7 crossing must be >= 16.0;
    copy rule_BONDPAD_R_1_via6;
}


// data on layer rule_BONDPAD_R_2_via7 is always an error

rule BONDPAD.R.1_7 {
    caption BONDPAD.R.1: Minimum Bondpad Via7 inside Metal7 to Metal8 crossing must be >= 16.0;
    copy rule_BONDPAD_R_2_via7;
}


// data on layer rule_BONDPAD_R_2_via8 is always an error

rule BONDPAD.R.1_8 {
    caption BONDPAD.R.1: Minimum Bondpad Via8 inside Metal8 to Metal9 crossing must be >= 16.0;
    copy rule_BONDPAD_R_2_via8;
}


// data on layer rule_BONDPAD_R_2_via9 is always an error

rule BONDPAD.R.2 {
    caption BONDPAD.R.2: Minimum Bondpad Via9 inside Metal9 to Metal10 crossing must be >= 4.0;
    copy rule_BONDPAD_R_2_via9;
}


// data on layer rule_BONDPAD_R_2_via10 is always an error

rule BONDPAD.R.2_2 {
    caption BONDPAD.R.2: Minimum Bondpad Via10 inside Metal10 to Metal11 crossing must be >= 4.0;
    copy rule_BONDPAD_R_2_via10;
}


// data on layer rule_BONDPAD_SP_5_metal1 is always an error

rule BONDPAD.SP.5 {
    caption BONDPAD.SP.5: Bondpad Metal1 slot to Bondpad Metal1 slot spacing must be == 1.50;
    copy rule_BONDPAD_SP_5_metal1;
}


// data on layer rule_BONDPAD_SP_5_metal2 is always an error

rule BONDPAD.SP.5_2 {
    caption BONDPAD.SP.5: Bondpad Metal2 slot to Bondpad Metal2 slot spacing must be == 1.50;
    copy rule_BONDPAD_SP_5_metal2;
}


// data on layer rule_BONDPAD_SP_5_metal3 is always an error

rule BONDPAD.SP.5_3 {
    caption BONDPAD.SP.5: Bondpad Metal3 slot to Bondpad Metal3 slot spacing must be == 1.50;
    copy rule_BONDPAD_SP_5_metal3;
}


// data on layer rule_BONDPAD_SP_5_metal4 is always an error

rule BONDPAD.SP.5_4 {
    caption BONDPAD.SP.5: Bondpad Metal4 slot to Bondpad Metal4 slot spacing must be == 1.50;
    copy rule_BONDPAD_SP_5_metal4;
}


// data on layer rule_BONDPAD_SP_5_metal5 is always an error

rule BONDPAD.SP.5_5 {
    caption BONDPAD.SP.5: Bondpad Metal5 slot to Bondpad Metal5 slot spacing must be == 1.50;
    copy rule_BONDPAD_SP_5_metal5;
}


// data on layer rule_BONDPAD_SP_5_metal6 is always an error

rule BONDPAD.SP.5_6 {
    caption BONDPAD.SP.5: Bondpad Metal6 slot to Bondpad Metal6 slot spacing must be == 1.50;
    copy rule_BONDPAD_SP_5_metal6;
}


// data on layer rule_BONDPAD_SP_5_metal7 is always an error

rule BONDPAD.SP.5_7 {
    caption BONDPAD.SP.5: Bondpad Metal7 slot to Bondpad Metal7 slot spacing must be == 1.50;
    copy rule_BONDPAD_SP_5_metal7;
}


// data on layer rule_BONDPAD_SP_5_metal8 is always an error

rule BONDPAD.SP.5_8 {
    caption BONDPAD.SP.5: Bondpad Metal8 slot to Bondpad Metal8 slot spacing must be == 1.50;
    copy rule_BONDPAD_SP_5_metal8;
}


// data on layer rule_BONDPAD_SP_5_metal9 is always an error

rule BONDPAD.SP.5_9 {
    caption BONDPAD.SP.5: Bondpad Metal9 slot to Bondpad Metal9 slot spacing must be == 1.50;
    copy rule_BONDPAD_SP_5_metal9;
}


// data on layer rule_BONDPAD_SP_5_metal10 is always an error

rule BONDPAD.SP.5_10 {
    caption BONDPAD.SP.5: Bondpad Metal10 slot to Bondpad Metal10 slot spacing must be == 1.50;
    copy rule_BONDPAD_SP_5_metal10;
}


// data on layer rule_BONDPAD_W_4_metal1 is always an error

rule BONDPAD.W.4 {
    caption BONDPAD.W.4: Bondpad Metal1 slot width must be == 1.00;
    copy rule_BONDPAD_W_4_metal1;
}


// data on layer rule_BONDPAD_W_4_metal2 is always an error

rule BONDPAD.W.4_2 {
    caption BONDPAD.W.4: Bondpad Metal2 slot width must be == 1.00;
    copy rule_BONDPAD_W_4_metal2;
}


// data on layer rule_BONDPAD_W_4_metal3 is always an error

rule BONDPAD.W.4_3 {
    caption BONDPAD.W.4: Bondpad Metal3 slot width must be == 1.00;
    copy rule_BONDPAD_W_4_metal3;
}


// data on layer rule_BONDPAD_W_4_metal4 is always an error

rule BONDPAD.W.4_4 {
    caption BONDPAD.W.4: Bondpad Metal4 slot width must be == 1.00;
    copy rule_BONDPAD_W_4_metal4;
}


// data on layer rule_BONDPAD_W_4_metal5 is always an error

rule BONDPAD.W.4_5 {
    caption BONDPAD.W.4: Bondpad Metal5 slot width must be == 1.00;
    copy rule_BONDPAD_W_4_metal5;
}


// data on layer rule_BONDPAD_W_4_metal6 is always an error

rule BONDPAD.W.4_6 {
    caption BONDPAD.W.4: Bondpad Metal6 slot width must be == 1.00;
    copy rule_BONDPAD_W_4_metal6;
}


// data on layer rule_BONDPAD_W_4_metal7 is always an error

rule BONDPAD.W.4_7 {
    caption BONDPAD.W.4: Bondpad Metal7 slot width must be == 1.00;
    copy rule_BONDPAD_W_4_metal7;
}


// data on layer rule_BONDPAD_W_4_metal8 is always an error

rule BONDPAD.W.4_8 {
    caption BONDPAD.W.4: Bondpad Metal8 slot width must be == 1.00;
    copy rule_BONDPAD_W_4_metal8;
}


// data on layer rule_BONDPAD_W_4_metal9 is always an error

rule BONDPAD.W.4_9 {
    caption BONDPAD.W.4: Bondpad Metal9 slot width must be == 1.00;
    copy rule_BONDPAD_W_4_metal9;
}


// data on layer rule_BONDPAD_W_4_metal10 is always an error

rule BONDPAD.W.4_10 {
    caption BONDPAD.W.4: Bondpad Metal10 slot width must be == 1.00;
    copy rule_BONDPAD_W_4_metal10;
}


// data on layer rule_BONDPAD_W_5_metal1 is always an error

rule BONDPAD.W.5 {
    caption BONDPAD.W.5: Bondpad Metal1 outside Metal1 ring width must be == 5.00;
    copy rule_BONDPAD_W_5_metal1;
}


// data on layer rule_BONDPAD_W_5_metal2 is always an error

rule BONDPAD.W.5_2 {
    caption BONDPAD.W.5: Bondpad Metal2 outside Metal2 ring width must be == 5.00;
    copy rule_BONDPAD_W_5_metal2;
}


// data on layer rule_BONDPAD_W_5_metal3 is always an error

rule BONDPAD.W.5_3 {
    caption BONDPAD.W.5: Bondpad Metal3 outside Metal3 ring width must be == 5.00;
    copy rule_BONDPAD_W_5_metal3;
}


// data on layer rule_BONDPAD_W_5_metal4 is always an error

rule BONDPAD.W.5_4 {
    caption BONDPAD.W.5: Bondpad Metal4 outside Metal4 ring width must be == 5.00;
    copy rule_BONDPAD_W_5_metal4;
}


// data on layer rule_BONDPAD_W_5_metal5 is always an error

rule BONDPAD.W.5_5 {
    caption BONDPAD.W.5: Bondpad Metal5 outside Metal5 ring width must be == 5.00;
    copy rule_BONDPAD_W_5_metal5;
}


// data on layer rule_BONDPAD_W_5_metal6 is always an error

rule BONDPAD.W.5_6 {
    caption BONDPAD.W.5: Bondpad Metal6 outside Metal6 ring width must be == 5.00;
    copy rule_BONDPAD_W_5_metal6;
}


// data on layer rule_BONDPAD_W_5_metal7 is always an error

rule BONDPAD.W.5_7 {
    caption BONDPAD.W.5: Bondpad Metal7 outside Metal7 ring width must be == 5.00;
    copy rule_BONDPAD_W_5_metal7;
}


// data on layer rule_BONDPAD_W_5_metal8 is always an error

rule BONDPAD.W.5_8 {
    caption BONDPAD.W.5: Bondpad Metal8 outside Metal8 ring width must be == 5.00;
    copy rule_BONDPAD_W_5_metal8;
}


// data on layer rule_BONDPAD_W_5_metal9 is always an error

rule BONDPAD.W.5_9 {
    caption BONDPAD.W.5: Bondpad Metal9 outside Metal9 ring width must be == 5.00;
    copy rule_BONDPAD_W_5_metal9;
}


// data on layer rule_BONDPAD_W_5_metal10 is always an error

rule BONDPAD.W.5_10 {
    caption BONDPAD.W.5: Bondpad Metal10 outside Metal10 ring width must be == 5.00;
    copy rule_BONDPAD_W_5_metal10;
}


// width check for bondpad_metal1_slot_on_edge <1.00 or >3.50 
rule BONDPAD.SP.6 {
    caption BONDPAD.SP.6: Bondpad Metal1 to Bondpad Metal1 spacing across first slot must be >= 1.00 um and <= 3.50 um;
    inte bondpad_metal1_slot_on_edge bondpad_metal1_slot_on_edge -lt 1.00 -output region -singular -abut lt 90;
// for check without upperlimit use sizing
    size bondpad_metal1_slot_on_edge -by -1.75 L41647;
    size L41647 -by 1.75;
}


// width check for bondpad_metal2_slot_on_edge <1.00 or >3.50 
rule BONDPAD.SP.6_2 {
    caption BONDPAD.SP.6: Bondpad Metal2 to Bondpad Metal2 spacing across first slot must be >= 1.00 um and <= 3.50 um;
    inte bondpad_metal2_slot_on_edge bondpad_metal2_slot_on_edge -lt 1.00 -output region -singular -abut lt 90;
// for check without upperlimit use sizing
    size bondpad_metal2_slot_on_edge -by -1.75 L34894;
    size L34894 -by 1.75;
}


// width check for bondpad_metal3_slot_on_edge <1.00 or >3.50 
rule BONDPAD.SP.6_3 {
    caption BONDPAD.SP.6: Bondpad Metal3 to Bondpad Metal3 spacing across first slot must be >= 1.00 um and <= 3.50 um;
    inte bondpad_metal3_slot_on_edge bondpad_metal3_slot_on_edge -lt 1.00 -output region -singular -abut lt 90;
// for check without upperlimit use sizing
    size bondpad_metal3_slot_on_edge -by -1.75 L28141;
    size L28141 -by 1.75;
}


// width check for bondpad_metal4_slot_on_edge <1.00 or >3.50 
rule BONDPAD.SP.6_4 {
    caption BONDPAD.SP.6: Bondpad Metal4 to Bondpad Metal4 spacing across first slot must be >= 1.00 um and <= 3.50 um;
    inte bondpad_metal4_slot_on_edge bondpad_metal4_slot_on_edge -lt 1.00 -output region -singular -abut lt 90;
// for check without upperlimit use sizing
    size bondpad_metal4_slot_on_edge -by -1.75 L21388;
    size L21388 -by 1.75;
}


// width check for bondpad_metal5_slot_on_edge <1.00 or >3.50 
rule BONDPAD.SP.6_5 {
    caption BONDPAD.SP.6: Bondpad Metal5 to Bondpad Metal5 spacing across first slot must be >= 1.00 um and <= 3.50 um;
    inte bondpad_metal5_slot_on_edge bondpad_metal5_slot_on_edge -lt 1.00 -output region -singular -abut lt 90;
// for check without upperlimit use sizing
    size bondpad_metal5_slot_on_edge -by -1.75 L14635;
    size L14635 -by 1.75;
}


// width check for bondpad_metal6_slot_on_edge <1.00 or >3.50 
rule BONDPAD.SP.6_6 {
    caption BONDPAD.SP.6: Bondpad Metal6 to Bondpad Metal6 spacing across first slot must be >= 1.00 um and <= 3.50 um;
    inte bondpad_metal6_slot_on_edge bondpad_metal6_slot_on_edge -lt 1.00 -output region -singular -abut lt 90;
// for check without upperlimit use sizing
    size bondpad_metal6_slot_on_edge -by -1.75 L7882;
    size L7882 -by 1.75;
}


// width check for bondpad_metal7_slot_on_edge <1.00 or >3.50 
rule BONDPAD.SP.6_7 {
    caption BONDPAD.SP.6: Bondpad Metal7 to Bondpad Metal7 spacing across first slot must be >= 1.00 um and <= 3.50 um;
    inte bondpad_metal7_slot_on_edge bondpad_metal7_slot_on_edge -lt 1.00 -output region -singular -abut lt 90;
// for check without upperlimit use sizing
    size bondpad_metal7_slot_on_edge -by -1.75 L1129;
    size L1129 -by 1.75;
}


// width check for bondpad_metal8_slot_on_edge <1.00 or >3.50 
rule BONDPAD.SP.6_8 {
    caption BONDPAD.SP.6: Bondpad Metal8 to Bondpad Metal8 spacing across first slot must be >= 1.00 um and <= 3.50 um;
    inte bondpad_metal8_slot_on_edge bondpad_metal8_slot_on_edge -lt 1.00 -output region -singular -abut lt 90;
// for check without upperlimit use sizing
    size bondpad_metal8_slot_on_edge -by -1.75 L94385;
    size L94385 -by 1.75;
}


// width check for bondpad_metal9_slot_on_edge <1.00 or >3.50 
rule BONDPAD.SP.6_9 {
    caption BONDPAD.SP.6: Bondpad Metal9 to Bondpad Metal9 spacing across first slot must be >= 1.00 um and <= 3.50 um;
    inte bondpad_metal9_slot_on_edge bondpad_metal9_slot_on_edge -lt 1.00 -output region -singular -abut lt 90;
// for check without upperlimit use sizing
    size bondpad_metal9_slot_on_edge -by -1.75 L87623;
    size L87623 -by 1.75;
}


// width check for bondpad_metal10_slot_on_edge <1.00 or >3.50 
rule BONDPAD.SP.6_10 {
    caption BONDPAD.SP.6: Bondpad Metal10 to Bondpad Metal10 spacing across first slot must be >= 1.00 um and <= 3.50 um;
    inte bondpad_metal10_slot_on_edge bondpad_metal10_slot_on_edge -lt 1.00 -output region -singular -abut lt 90;
// for check without upperlimit use sizing
    size bondpad_metal10_slot_on_edge -by -1.75 L96079;
    size L96079 -by 1.75;
}


// spacing check for bondpad_via1_array <1.1 
rule BONDPAD.SP.7 {
    caption BONDPAD.SP.7: Bondpad Via1 array to Bondpad Via1 array spacing must be >= 1.1 um;
    exte bondpad_via1_array bondpad_via1_array -lt 1.1 -output region -singular -abut lt 90;
}


// spacing check for bondpad_via2_array <1.1 
rule BONDPAD.SP.7_2 {
    caption BONDPAD.SP.7: Bondpad Via2 array to Bondpad Via2 array spacing must be >= 1.1 um;
    exte bondpad_via2_array bondpad_via2_array -lt 1.1 -output region -singular -abut lt 90;
}


// spacing check for bondpad_via3_array <1.1 
rule BONDPAD.SP.7_3 {
    caption BONDPAD.SP.7: Bondpad Via3 array to Bondpad Via3 array spacing must be >= 1.1 um;
    exte bondpad_via3_array bondpad_via3_array -lt 1.1 -output region -singular -abut lt 90;
}


// spacing check for bondpad_via4_array <1.1 
rule BONDPAD.SP.7_4 {
    caption BONDPAD.SP.7: Bondpad Via4 array to Bondpad Via4 array spacing must be >= 1.1 um;
    exte bondpad_via4_array bondpad_via4_array -lt 1.1 -output region -singular -abut lt 90;
}


// spacing check for bondpad_via5_array <1.1 
rule BONDPAD.SP.7_5 {
    caption BONDPAD.SP.7: Bondpad Via5 array to Bondpad Via5 array spacing must be >= 1.1 um;
    exte bondpad_via5_array bondpad_via5_array -lt 1.1 -output region -singular -abut lt 90;
}


// spacing check for bondpad_via6_array <1.1 
rule BONDPAD.SP.7_6 {
    caption BONDPAD.SP.7: Bondpad Via6 array to Bondpad Via6 array spacing must be >= 1.1 um;
    exte bondpad_via6_array bondpad_via6_array -lt 1.1 -output region -singular -abut lt 90;
}


// spacing check for bondpad_via7_array <1.1 
rule BONDPAD.SP.7_7 {
    caption BONDPAD.SP.7: Bondpad Via7 array to Bondpad Via7 array spacing must be >= 1.1 um;
    exte bondpad_via7_array bondpad_via7_array -lt 1.1 -output region -singular -abut lt 90;
}


// spacing check for bondpad_via8_array <1.1 
rule BONDPAD.SP.7_8 {
    caption BONDPAD.SP.7: Bondpad Via8 array to Bondpad Via8 array spacing must be >= 1.1 um;
    exte bondpad_via8_array bondpad_via8_array -lt 1.1 -output region -singular -abut lt 90;
}


// spacing check for bondpad_via9_array <1.1 
rule BONDPAD.SP.7_9 {
    caption BONDPAD.SP.7: Bondpad Via9 array to Bondpad Via9 array spacing must be >= 1.1 um;
    exte bondpad_via9_array bondpad_via9_array -lt 1.1 -output region -singular -abut lt 90;
}


// spacing check for bondpad_via10_array <1.1 
rule BONDPAD.SP.7_10 {
    caption BONDPAD.SP.7: Bondpad Via10 array to Bondpad Via10 array spacing must be >= 1.1 um;
    exte bondpad_via10_array bondpad_via10_array -lt 1.1 -output region -singular -abut lt 90;
}

#ifndef SUGGESTED_CHECK

// building polygons for layer oxide_in_res
// inside layer resdum_sz
    edge_boolean -inside oxide_in_res resdum_sz L84129;

// width check for L84129 <0.1 
    rule OXIDER.W.1.1 {
        caption OXIDER.W.1.1: Minimum Active Resistor width >= 0.1 um;
        inte L84129 L84129 -lt 0.1 -output region -abut lt 90;
    }

// building polygons for layer poly_in_res
// inside layer resdum_sz
    edge_boolean -inside poly_in_res resdum_sz L11022;

// width check for L11022 <0.1 
    rule POLYR.W.1.1 {
        caption POLYR.W.1.1: Minimum Poly resistor width >= 0.1 um;
        inte L11022 L11022 -lt 0.1 -output region -abut lt 90;
    }

#endif

#ifdef CHECK_DFM

// building polygons for layer Oxide
// inside layer Nzvt
// L62764 = and Nzvt Oxide


// enclose check for L62764 inside Poly <0.12  overlapOK
    rule NZVT.E.1.DFM {
        caption NZVT.E.1.DFM: Minimum N+ Poly gate end cap to Native Active Area enclosure for DFM >= 0.12 um;
        enc L62764 Poly -lt 0.12 -output region -singular -abut lt 90;
    }

// building polygons for layer Poly
// inside layer Oxide
// L19486 = edge_boolean -inside Poly Oxide

// spacing check for L19486 <0.08 
    rule POLY.SP.2.DFM {
        caption POLY.SP.2.DFM: Minimum Poly gate space for DFM >= 0.08 um;
        exte L19486 L19486 -lt 0.08 -output region -abut lt 90;
    }

// building polygons for layer Oxide
// inside layer Nimp
// nactive = and Nimp Oxide


// enclose check for nactive inside Poly <0.12  overlapOK
    rule POLY.E.1.DFM {
        caption POLY.E.1.DFM: Minimum N-channel gate extension beyond Active Area for  DFM >= 0.12 um;
        enc nactive Poly -lt 0.12 -output region -singular -abut lt 90;
    }

// building polygons for layer Oxide
// inside layer Pimp
// pactive = and Oxide Pimp


// enclose check for pactive inside Poly <0.12  overlapOK
    rule POLY.E.2.DFM {
        caption POLY.E.2.DFM: Minimum P-channel gate extension beyond Active Area for DFM >= 0.12 um;
        enc pactive Poly -lt 0.12 -output region -singular -abut lt 90;
    }

// building polygons for layer Cont
// inside layer Oxide
// L32388 = and Cont Oxide

// building polygons for layer Poly
// inside layer Oxide
// L19486 = edge_boolean -inside Poly Oxide

// spacing check for L32388 and L19486 <0.07 
    rule CONT.SE.1.DFM {
        caption CONT.SE.1.DFM: Minimum Contact on Active Area to gate spacing for DFM >= 0.07 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
        edge_expand L32388 -inside_by 0.001 L20279;
        edge_expand L19486 -inside_by 0.001 L24869;
        and L20279 L24869;
        exte L32388 L19486 -lt 0.07 -output region -abut lt 90
    }

// building polygons for layer Cont
// inside layers Oxide Oxide_thk
// L24975 = and Oxide Oxide_thk
// L78798 = and Cont L24975

// building polygons for layer Poly
// inside layers Oxide Oxide_thk
// L24975 = and Oxide Oxide_thk
// L87956 = edge_boolean -inside Poly L24975

// spacing check for L78798 and L87956 <0.08 
    rule CONT.SE.2.DFM {
        caption CONT.SE.2.DFM: Minimum Contact on 1.8V Active Area to gate spacing for DFM >= 0.08 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
        edge_expand L78798 -inside_by 0.001 L33582;
        edge_expand L87956 -inside_by 0.001 L42958;
        and L33582 L42958;
        exte L78798 L87956 -lt 0.08 -output region -abut lt 90
    }

// building polygons for layer Cont
// inside layer Poly
// cont_poly = and Cont Poly

// building polygons for layer Oxide
// inside layer Poly
// L60508 = edge_boolean -inside Oxide Poly

// spacing check for cont_poly and L60508 <0.08 
    rule CONT.SE.3.DFM {
        caption CONT.SE.3.DFM: Minimum gate Contact on Active Area spacing for DFM >= 0.08 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
        edge_expand cont_poly -inside_by 0.001 L39383;
        edge_expand L60508 -inside_by 0.001 L23902;
        and L39383 L23902;
        exte cont_poly L60508 -lt 0.08 -output region -abut lt 90
    }

// building polygons for layer Cont
// inside layer Poly
// cont_poly = and Cont Poly

// building polygons for layer Oxide
// inside layers Oxide_thk Poly
// L99140 = and Oxide_thk Poly
// L85777 = edge_boolean -inside Oxide L99140

// spacing check for cont_poly and L85777 <0.09 
    rule CONT.SE.4.DFM {
        caption CONT.SE.4.DFM: Minimum 1.8V gate Contact on Active Area spacing for DFM >= 0.09 um;
// output parts of shapes that intersect
// create 0.001 wide shapes from edges to check for intersects
        edge_expand cont_poly -inside_by 0.001 L39384;
        edge_expand L85777 -inside_by 0.001 L26515;
        and L39384 L26515;
        exte cont_poly L85777 -lt 0.09 -output region -abut lt 90
    }

#endif

#ifdef SUGGESTED_CHECK

// building polygons for layer oxide_in_res
// inside layer resdum_sz
    edge_boolean -inside oxide_in_res resdum_sz L84130;

// width check for L84130 <0.8 
    rule OXIDER.W.1.2 {
        caption OXIDER.W.1.2: Minimum suggested Active Resistor width >= 0.8 um;
        inte L84130 L84130 -lt 0.8 -output region -abut lt 90;
    }

// building polygons for layer resdum_sz
// inside layer oxide_in_res
    edge_boolean -inside resdum_sz oxide_in_res L2571;

// width check for L2571 <4.0 
    rule OXIDER.L.1 {
        caption OXIDER.L.1: Minimum suggested Active Resistor length >= 4.0 um;
        inte L2571 L2571 -lt 4.0 -output region -abut lt 90;
    }

// building polygons for layer poly_in_res
// inside layer resdum_sz
    edge_boolean -inside poly_in_res resdum_sz L11023;

// width check for L11023 <0.8 
    rule POLYR.W.1.2 {
        caption POLYR.W.1.2: Minimum suggested Poly resistor width >= 0.8 um;
        inte L11023 L11023 -lt 0.8 -output region -abut lt 90;
    }

// building polygons for layer resdum_sz
// inside layer poly_in_res
    edge_boolean -inside resdum_sz poly_in_res L62894;

// width check for L62894 <4.0 
    rule POLYR.L.1 {
        caption POLYR.L.1: Minimum suggested Poly resistor length >= 4.0 um;
        inte L62894 L62894 -lt 4.0 -output region -abut lt 90;
    }

#endif

#ifdef CHECK_DENSITY

    rule OXIDE.D.1 {
        caption OXIDE.D.1: Oxide full chip density must be > 30% < 80%;
        density Oxide -lege 0.30 0.80;
    }

    rule OXIDE.D.2 {
        caption OXIDE.D.2: Oxide local (300x300) density must be > 25% < 75%;
        density Oxide -lege 0.25 .75 -window 300.0 -step 150.0;
    }

    rule POLY.D.1 {
        caption POLY.D.1: Poly density must be <= 50%;
        density Poly -gt 0.5;
    }

    rule METAL1.D.1 {
        caption METAL1.D.1: Metal1 density must be >= 20% <= 65%;
        density metal1_conn -ltgt 0.20 0.65 -window 120.0 -step 60.0;
    }

    rule METAL2.D.1 {
        caption METAL2.D.1: Metal2 density must be >= 20% <= 65%;
        density metal2_conn -ltgt 0.20 0.65 -window 120.0 -step 60.0;
    }

    rule METAL3.D.1 {
        caption METAL3.D.1: Metal3 density must be >= 20% <= 65%;
        density metal3_conn -ltgt 0.20 0.65 -window 120.0 -step 60.0;
    }

    rule METAL4.D.1 {
        caption METAL4.D.1: Metal4 density must be >= 20% <= 65%;
        density metal4_conn -ltgt 0.20 0.65 -window 120.0 -step 60.0;
    }

    rule METAL5.D.1 {
        caption METAL5.D.1: Metal5 density must be >= 20% <= 65%;
        density metal5_conn -ltgt 0.20 0.65 -window 120.0 -step 60.0;
    }

    rule METAL6.D.1 {
        caption METAL6.D.1: Metal6 density must be >= 20% <= 65%;
        density metal6_conn -ltgt 0.20 0.65 -window 120.0 -step 60.0;
    }

    rule METAL7.D.1 {
        caption METAL7.D.1: Metal7 density must be >= 20% <= 65%;
        density metal7_conn -ltgt 0.20 0.65 -window 120.0 -step 60.0;
    }

    rule METAL8.D.1 {
        caption METAL8.D.1: Metal8 density must be >= 20% <= 65%;
        density metal8_conn -ltgt 0.20 0.65 -window 120.0 -step 60.0;
    }

    rule METAL9.D.1 {
        caption METAL9.D.1: Metal9 density must be >= 20% <= 65%;
        density metal9_conn -ltgt 0.20 0.65 -window 120.0 -step 60.0;
    }

    rule METAL10.D.1 {
        caption METAL10.D.1: Metal10 density must be >= 20% <= 65%;
        density metal10_conn -ltgt 0.20 0.65 -window 120.0 -step 60.0;
    }

    rule METAL11.D.1 {
        caption METAL11.D.1: Metal11 density must be >= 20% <= 65%;
        density metal11_conn -ltgt 0.20 0.65 -window 120.0 -step 60.0;
    }

    rule METAL1.D.2 {
        caption METAL1.D.2: Metal1 density must be <= 60%;
        density metal1_conn -gt 0.60 -window 600.0 -step 300.0;
    }

    rule METAL2.D.2 {
        caption METAL2.D.2: Metal2 density must be <= 60%;
        density metal2_conn -gt 0.60 -window 600.0 -step 300.0;
    }

    rule METAL3.D.2 {
        caption METAL3.D.2: Metal3 density must be <= 60%;
        density metal3_conn -gt 0.60 -window 600.0 -step 300.0;
    }

    rule METAL4.D.2 {
        caption METAL4.D.2: Metal4 density must be <= 60%;
        density metal4_conn -gt 0.60 -window 600.0 -step 300.0;
    }

    rule METAL5.D.2 {
        caption METAL5.D.2: Metal5 density must be <= 60%;
        density metal5_conn -gt 0.60 -window 600.0 -step 300.0;
    }

    rule METAL6.D.2 {
        caption METAL6.D.2: Metal6 density must be <= 60%;
        density metal6_conn -gt 0.60 -window 600.0 -step 300.0;
    }

    rule METAL7.D.2 {
        caption METAL7.D.2: Metal7 density must be <= 60%;
        density metal7_conn -gt 0.60 -window 600.0 -step 300.0;
    }

    rule METAL8.D.2 {
        caption METAL8.D.2: Metal8 density must be <= 60%;
        density metal8_conn -gt 0.60 -window 600.0 -step 300.0;
    }

    rule METAL9.D.2 {
        caption METAL9.D.2: Metal9 density must be <= 60%;
        density metal9_conn -gt 0.60 -window 600.0 -step 300.0;
    }

    rule METAL10.D.2 {
        caption METAL10.D.2: Metal10 density must be <= 60%;
        density metal10_conn -gt 0.60 -window 600.0 -step 300.0;
    }

    rule METAL11.D.2 {
        caption METAL11.D.2: Metal11 density must be <= 60%;
        density metal11_conn -gt 0.60 -window 600.0 -step 300.0;
    }

#endif

#ifdef CHECK_POLY_ANT_1

    copy poly_on_field poly_on_fieldant0;
    copy poly_tap poly_tapant0;
    copy Poly Polyant0;
    copy gate gateant0;

    connect poly_on_fieldant0 Polyant0 -by poly_tapant0;
    connect gateant0 Polyant0;

    rule ANT.1 {
        caption ANT.1: Field Poly area to gate area ratio must be <= 275.0;
        antenna poly_on_fieldant0 gateant0 -gt 275.0 
        "[(area(poly_on_fieldant0)/area(gateant0))]";
    }

#endif

#ifdef CHECK_POLY_ANT_2

    copy poly_on_field poly_on_fieldant1;
    copy poly_tap poly_tapant1;
    copy Poly Polyant1;
    copy gate gateant1;

    connect poly_on_fieldant1 Polyant1 -by poly_tapant1;
    connect gateant1 Polyant1;

    rule ANT.2 {
        caption ANT.2: Field Poly perimeter to gate area ratio must be <= 550.0;
        antenna poly_on_fieldant1 gateant1 -gt 550.0 
        "[(perimeter(poly_on_fieldant1)/area(gateant1))]";
    }

#endif

#ifdef CHECK_CONT_ANT_3

    copy cont_antenna cont_antennaant2;
    copy cont_poly cont_polyant2;
    copy Poly Polyant2;
    copy gate gateant2;

    connect cont_antennaant2 Polyant2 -by cont_polyant2;
    connect gateant2 Polyant2;

    rule ANT.3 {
        caption ANT.3: Poly Contact area to gate area ratio must be <= 15.0;
        antenna cont_antennaant2 gateant2 -gt 15.0 
        "[(area(cont_antennaant2)/area(gateant2))]";
    }

#endif

#ifdef CHECK_METAL1_ANT_4

    copy metal1_wo_diode metal1_wo_diodeant3;
    copy cont_poly cont_polyant3;
    copy Poly Polyant3;
    copy gate gateant3;

    connect metal1_wo_diodeant3 Polyant3 -by cont_polyant3;
    connect gateant3 Polyant3;

    rule ANT.4.M1 {
        caption ANT.4.M1: Metal1 area to gate area ratio must be <= 475.0;
        antenna metal1_wo_diodeant3 gateant3 -gt 475.0 
        "[(area(metal1_wo_diodeant3)/area(gateant3))]";
    }

#endif

#ifdef CHECK_METAL2_ANT_4

    copy metal2_conn metal2_connant4;
    copy Via1 Via1ant4;
    copy metal1_wo_diode metal1_wo_diodeant4;
    copy cont_poly cont_polyant4;
    copy Poly Polyant4;
    copy gate gateant4;

    connect metal2_connant4 metal1_wo_diodeant4 -by Via1ant4;
    connect metal1_wo_diodeant4 Polyant4 -by cont_polyant4;
    connect gateant4 Polyant4;

    rule ANT.4.M2 {
        caption ANT.4.M2: Metal2 area to gate area ratio must be <= 475.0;
        antenna metal2_connant4 gateant4 -gt 475.0 
        "[(area(metal2_connant4)/area(gateant4))]";
    }

#endif

#ifdef CHECK_METAL3_ANT_4

    copy metal3_conn metal3_connant5;
    copy Via2 Via2ant5;
    copy metal2_conn metal2_connant5;
    copy Via1 Via1ant5;
    copy metal1_wo_diode metal1_wo_diodeant5;
    copy cont_poly cont_polyant5;
    copy Poly Polyant5;
    copy gate gateant5;

    connect metal3_connant5 metal2_connant5 -by Via2ant5;
    connect metal2_connant5 metal1_wo_diodeant5 -by Via1ant5;
    connect metal1_wo_diodeant5 Polyant5 -by cont_polyant5;
    connect gateant5 Polyant5;

    rule ANT.4.M3 {
        caption ANT.4.M3: Metal3 area to gate area ratio must be <= 475.0;
        antenna metal3_connant5 gateant5 -gt 475.0 
        "[(area(metal3_connant5)/area(gateant5))]";
    }

#endif

#ifdef CHECK_METAL4_ANT_4

    copy metal4_conn metal4_connant6;
    copy Via3 Via3ant6;
    copy metal3_conn metal3_connant6;
    copy Via2 Via2ant6;
    copy metal2_conn metal2_connant6;
    copy Via1 Via1ant6;
    copy metal1_wo_diode metal1_wo_diodeant6;
    copy cont_poly cont_polyant6;
    copy Poly Polyant6;
    copy gate gateant6;

    connect metal4_connant6 metal3_connant6 -by Via3ant6;
    connect metal3_connant6 metal2_connant6 -by Via2ant6;
    connect metal2_connant6 metal1_wo_diodeant6 -by Via1ant6;
    connect metal1_wo_diodeant6 Polyant6 -by cont_polyant6;
    connect gateant6 Polyant6;

    rule ANT.4.M4 {
        caption ANT.4.M4: Metal4 area to gate area ratio must be <= 475.0;
        antenna metal4_connant6 gateant6 -gt 475.0 
        "[(area(metal4_connant6)/area(gateant6))]";
    }

#endif

#ifdef CHECK_METAL5_ANT_4

    copy metal5_conn metal5_connant7;
    copy Via4 Via4ant7;
    copy metal4_conn metal4_connant7;
    copy Via3 Via3ant7;
    copy metal3_conn metal3_connant7;
    copy Via2 Via2ant7;
    copy metal2_conn metal2_connant7;
    copy Via1 Via1ant7;
    copy metal1_wo_diode metal1_wo_diodeant7;
    copy cont_poly cont_polyant7;
    copy Poly Polyant7;
    copy gate gateant7;

    connect metal5_connant7 metal4_connant7 -by Via4ant7;
    connect metal4_connant7 metal3_connant7 -by Via3ant7;
    connect metal3_connant7 metal2_connant7 -by Via2ant7;
    connect metal2_connant7 metal1_wo_diodeant7 -by Via1ant7;
    connect metal1_wo_diodeant7 Polyant7 -by cont_polyant7;
    connect gateant7 Polyant7;

    rule ANT.4.M5 {
        caption ANT.4.M5: Metal5 area to gate area ratio must be <= 475.0;
        antenna metal5_connant7 gateant7 -gt 475.0 
        "[(area(metal5_connant7)/area(gateant7))]";
    }

#endif

#ifdef CHECK_METAL6_ANT_4

    copy metal6_conn metal6_connant8;
    copy Via5 Via5ant8;
    copy metal5_conn metal5_connant8;
    copy Via4 Via4ant8;
    copy metal4_conn metal4_connant8;
    copy Via3 Via3ant8;
    copy metal3_conn metal3_connant8;
    copy Via2 Via2ant8;
    copy metal2_conn metal2_connant8;
    copy Via1 Via1ant8;
    copy metal1_wo_diode metal1_wo_diodeant8;
    copy cont_poly cont_polyant8;
    copy Poly Polyant8;
    copy gate gateant8;

    connect metal6_connant8 metal5_connant8 -by Via5ant8;
    connect metal5_connant8 metal4_connant8 -by Via4ant8;
    connect metal4_connant8 metal3_connant8 -by Via3ant8;
    connect metal3_connant8 metal2_connant8 -by Via2ant8;
    connect metal2_connant8 metal1_wo_diodeant8 -by Via1ant8;
    connect metal1_wo_diodeant8 Polyant8 -by cont_polyant8;
    connect gateant8 Polyant8;

    rule ANT.4.M6 {
        caption ANT.4.M6: Metal6 area to gate area ratio must be <= 475.0;
        antenna metal6_connant8 gateant8 -gt 475.0 
        "[(area(metal6_connant8)/area(gateant8))]";
    }

#endif

#ifdef CHECK_METAL7_ANT_4

    copy metal7_conn metal7_connant9;
    copy Via6 Via6ant9;
    copy metal6_conn metal6_connant9;
    copy Via5 Via5ant9;
    copy metal5_conn metal5_connant9;
    copy Via4 Via4ant9;
    copy metal4_conn metal4_connant9;
    copy Via3 Via3ant9;
    copy metal3_conn metal3_connant9;
    copy Via2 Via2ant9;
    copy metal2_conn metal2_connant9;
    copy Via1 Via1ant9;
    copy metal1_wo_diode metal1_wo_diodeant9;
    copy cont_poly cont_polyant9;
    copy Poly Polyant9;
    copy gate gateant9;

    connect metal7_connant9 metal6_connant9 -by Via6ant9;
    connect metal6_connant9 metal5_connant9 -by Via5ant9;
    connect metal5_connant9 metal4_connant9 -by Via4ant9;
    connect metal4_connant9 metal3_connant9 -by Via3ant9;
    connect metal3_connant9 metal2_connant9 -by Via2ant9;
    connect metal2_connant9 metal1_wo_diodeant9 -by Via1ant9;
    connect metal1_wo_diodeant9 Polyant9 -by cont_polyant9;
    connect gateant9 Polyant9;

    rule ANT.4.M7 {
        caption ANT.4.M7: Metal7 area to gate area ratio must be <= 475.0;
        antenna metal7_connant9 gateant9 -gt 475.0 
        "[(area(metal7_connant9)/area(gateant9))]";
    }

#endif

#ifdef CHECK_METAL8_ANT_4

    copy metal8_conn metal8_connant10;
    copy Via7 Via7ant10;
    copy metal7_conn metal7_connant10;
    copy Via6 Via6ant10;
    copy metal6_conn metal6_connant10;
    copy Via5 Via5ant10;
    copy metal5_conn metal5_connant10;
    copy Via4 Via4ant10;
    copy metal4_conn metal4_connant10;
    copy Via3 Via3ant10;
    copy metal3_conn metal3_connant10;
    copy Via2 Via2ant10;
    copy metal2_conn metal2_connant10;
    copy Via1 Via1ant10;
    copy metal1_wo_diode metal1_wo_diodeant10;
    copy cont_poly cont_polyant10;
    copy Poly Polyant10;
    copy gate gateant10;

    connect metal8_connant10 metal7_connant10 -by Via7ant10;
    connect metal7_connant10 metal6_connant10 -by Via6ant10;
    connect metal6_connant10 metal5_connant10 -by Via5ant10;
    connect metal5_connant10 metal4_connant10 -by Via4ant10;
    connect metal4_connant10 metal3_connant10 -by Via3ant10;
    connect metal3_connant10 metal2_connant10 -by Via2ant10;
    connect metal2_connant10 metal1_wo_diodeant10 -by Via1ant10;
    connect metal1_wo_diodeant10 Polyant10 -by cont_polyant10;
    connect gateant10 Polyant10;

    rule ANT.4.M8 {
        caption ANT.4.M8: Metal8 area to gate area ratio must be <= 475.0;
        antenna metal8_connant10 gateant10 -gt 475.0 
        "[(area(metal8_connant10)/area(gateant10))]";
    }

#endif

#ifdef CHECK_METAL9_ANT_4

    copy metal9_conn metal9_connant11;
    copy Via8 Via8ant11;
    copy metal8_conn metal8_connant11;
    copy Via7 Via7ant11;
    copy metal7_conn metal7_connant11;
    copy Via6 Via6ant11;
    copy metal6_conn metal6_connant11;
    copy Via5 Via5ant11;
    copy metal5_conn metal5_connant11;
    copy Via4 Via4ant11;
    copy metal4_conn metal4_connant11;
    copy Via3 Via3ant11;
    copy metal3_conn metal3_connant11;
    copy Via2 Via2ant11;
    copy metal2_conn metal2_connant11;
    copy Via1 Via1ant11;
    copy metal1_wo_diode metal1_wo_diodeant11;
    copy cont_poly cont_polyant11;
    copy Poly Polyant11;
    copy gate gateant11;

    connect metal9_connant11 metal8_connant11 -by Via8ant11;
    connect metal8_connant11 metal7_connant11 -by Via7ant11;
    connect metal7_connant11 metal6_connant11 -by Via6ant11;
    connect metal6_connant11 metal5_connant11 -by Via5ant11;
    connect metal5_connant11 metal4_connant11 -by Via4ant11;
    connect metal4_connant11 metal3_connant11 -by Via3ant11;
    connect metal3_connant11 metal2_connant11 -by Via2ant11;
    connect metal2_connant11 metal1_wo_diodeant11 -by Via1ant11;
    connect metal1_wo_diodeant11 Polyant11 -by cont_polyant11;
    connect gateant11 Polyant11;

    rule ANT.4.M9 {
        caption ANT.4.M9: Metal9 area to gate area ratio must be <= 475.0;
        antenna metal9_connant11 gateant11 -gt 475.0 
        "[(area(metal9_connant11)/area(gateant11))]";
    }

#endif

#ifdef CHECK_METAL10_ANT_4

    copy metal10_conn metal10_connant12;
    copy Via9 Via9ant12;
    copy metal9_conn metal9_connant12;
    copy Via8 Via8ant12;
    copy metal8_conn metal8_connant12;
    copy Via7 Via7ant12;
    copy metal7_conn metal7_connant12;
    copy Via6 Via6ant12;
    copy metal6_conn metal6_connant12;
    copy Via5 Via5ant12;
    copy metal5_conn metal5_connant12;
    copy Via4 Via4ant12;
    copy metal4_conn metal4_connant12;
    copy Via3 Via3ant12;
    copy metal3_conn metal3_connant12;
    copy Via2 Via2ant12;
    copy metal2_conn metal2_connant12;
    copy Via1 Via1ant12;
    copy metal1_wo_diode metal1_wo_diodeant12;
    copy cont_poly cont_polyant12;
    copy Poly Polyant12;
    copy gate gateant12;

    connect metal10_connant12 metal9_connant12 -by Via9ant12;
    connect metal9_connant12 metal8_connant12 -by Via8ant12;
    connect metal8_connant12 metal7_connant12 -by Via7ant12;
    connect metal7_connant12 metal6_connant12 -by Via6ant12;
    connect metal6_connant12 metal5_connant12 -by Via5ant12;
    connect metal5_connant12 metal4_connant12 -by Via4ant12;
    connect metal4_connant12 metal3_connant12 -by Via3ant12;
    connect metal3_connant12 metal2_connant12 -by Via2ant12;
    connect metal2_connant12 metal1_wo_diodeant12 -by Via1ant12;
    connect metal1_wo_diodeant12 Polyant12 -by cont_polyant12;
    connect gateant12 Polyant12;

    rule ANT.4.M10 {
        caption ANT.4.M10: Metal10 area to gate area ratio must be <= 475.0;
        antenna metal10_connant12 gateant12 -gt 475.0 
        "[(area(metal10_connant12)/area(gateant12))]";
    }

#endif

#ifdef CHECK_METAL11_ANT_4

    copy metal11_conn metal11_connant13;
    copy Via10 Via10ant13;
    copy metal10_conn metal10_connant13;
    copy Via9 Via9ant13;
    copy metal9_conn metal9_connant13;
    copy Via8 Via8ant13;
    copy metal8_conn metal8_connant13;
    copy Via7 Via7ant13;
    copy metal7_conn metal7_connant13;
    copy Via6 Via6ant13;
    copy metal6_conn metal6_connant13;
    copy Via5 Via5ant13;
    copy metal5_conn metal5_connant13;
    copy Via4 Via4ant13;
    copy metal4_conn metal4_connant13;
    copy Via3 Via3ant13;
    copy metal3_conn metal3_connant13;
    copy Via2 Via2ant13;
    copy metal2_conn metal2_connant13;
    copy Via1 Via1ant13;
    copy metal1_wo_diode metal1_wo_diodeant13;
    copy cont_poly cont_polyant13;
    copy Poly Polyant13;
    copy gate gateant13;

    connect metal11_connant13 metal10_connant13 -by Via10ant13;
    connect metal10_connant13 metal9_connant13 -by Via9ant13;
    connect metal9_connant13 metal8_connant13 -by Via8ant13;
    connect metal8_connant13 metal7_connant13 -by Via7ant13;
    connect metal7_connant13 metal6_connant13 -by Via6ant13;
    connect metal6_connant13 metal5_connant13 -by Via5ant13;
    connect metal5_connant13 metal4_connant13 -by Via4ant13;
    connect metal4_connant13 metal3_connant13 -by Via3ant13;
    connect metal3_connant13 metal2_connant13 -by Via2ant13;
    connect metal2_connant13 metal1_wo_diodeant13 -by Via1ant13;
    connect metal1_wo_diodeant13 Polyant13 -by cont_polyant13;
    connect gateant13 Polyant13;

    rule ANT.4.M11 {
        caption ANT.4.M11: Metal11 area to gate area ratio must be <= 475.0;
        antenna metal11_connant13 gateant13 -gt 475.0 
        "[(area(metal11_connant13)/area(gateant13))]";
    }

#endif

#ifdef CHECK_VIA1_ANT_5

    copy metal2_conn metal2_connant14;
    copy Via1 Via1ant14;
    copy metal1_wo_diode metal1_wo_diodeant14;
    copy cont_poly cont_polyant14;
    copy Poly Polyant14;
    copy gate gateant14;

    connect metal2_connant14 metal1_wo_diodeant14 -by Via1ant14;
    connect metal1_wo_diodeant14 Polyant14 -by cont_polyant14;
    connect gateant14 Polyant14;

    rule ANT.5.V1 {
        caption ANT.5.V1: Via1 area to gate area ratio must be <= 25.0;
        antenna metal2_connant14 Via1ant14 gateant14 -gt 25.0 
        "[(area(Via1ant14)/area(gateant14))]";
    }

#endif

#ifdef CHECK_VIA2_ANT_5

    copy metal3_conn metal3_connant15;
    copy Via2 Via2ant15;
    copy metal2_conn metal2_connant15;
    copy Via1 Via1ant15;
    copy metal1_wo_diode metal1_wo_diodeant15;
    copy cont_poly cont_polyant15;
    copy Poly Polyant15;
    copy gate gateant15;

    connect metal3_connant15 metal2_connant15 -by Via2ant15;
    connect metal2_connant15 metal1_wo_diodeant15 -by Via1ant15;
    connect metal1_wo_diodeant15 Polyant15 -by cont_polyant15;
    connect gateant15 Polyant15;

    rule ANT.5.V2 {
        caption ANT.5.V2: Via2 area to gate area ratio must be <= 25.0;
        antenna metal3_connant15 Via2ant15 gateant15 -gt 25.0 
        "[(area(Via2ant15)/area(gateant15))]";
    }

#endif

#ifdef CHECK_VIA3_ANT_5

    copy metal4_conn metal4_connant16;
    copy Via3 Via3ant16;
    copy metal3_conn metal3_connant16;
    copy Via2 Via2ant16;
    copy metal2_conn metal2_connant16;
    copy Via1 Via1ant16;
    copy metal1_wo_diode metal1_wo_diodeant16;
    copy cont_poly cont_polyant16;
    copy Poly Polyant16;
    copy gate gateant16;

    connect metal4_connant16 metal3_connant16 -by Via3ant16;
    connect metal3_connant16 metal2_connant16 -by Via2ant16;
    connect metal2_connant16 metal1_wo_diodeant16 -by Via1ant16;
    connect metal1_wo_diodeant16 Polyant16 -by cont_polyant16;
    connect gateant16 Polyant16;

    rule ANT.5.V3 {
        caption ANT.5.V3: Via3 area to gate area ratio must be <= 25.0;
        antenna metal4_connant16 Via3ant16 gateant16 -gt 25.0 
        "[(area(Via3ant16)/area(gateant16))]";
    }

#endif

#ifdef CHECK_VIA4_ANT_5

    copy metal5_conn metal5_connant17;
    copy Via4 Via4ant17;
    copy metal4_conn metal4_connant17;
    copy Via3 Via3ant17;
    copy metal3_conn metal3_connant17;
    copy Via2 Via2ant17;
    copy metal2_conn metal2_connant17;
    copy Via1 Via1ant17;
    copy metal1_wo_diode metal1_wo_diodeant17;
    copy cont_poly cont_polyant17;
    copy Poly Polyant17;
    copy gate gateant17;

    connect metal5_connant17 metal4_connant17 -by Via4ant17;
    connect metal4_connant17 metal3_connant17 -by Via3ant17;
    connect metal3_connant17 metal2_connant17 -by Via2ant17;
    connect metal2_connant17 metal1_wo_diodeant17 -by Via1ant17;
    connect metal1_wo_diodeant17 Polyant17 -by cont_polyant17;
    connect gateant17 Polyant17;

    rule ANT.5.V4 {
        caption ANT.5.V4: Via4 area to gate area ratio must be <= 25.0;
        antenna metal5_connant17 Via4ant17 gateant17 -gt 25.0 
        "[(area(Via4ant17)/area(gateant17))]";
    }

#endif

#ifdef CHECK_VIA5_ANT_5

    copy metal6_conn metal6_connant18;
    copy Via5 Via5ant18;
    copy metal5_conn metal5_connant18;
    copy Via4 Via4ant18;
    copy metal4_conn metal4_connant18;
    copy Via3 Via3ant18;
    copy metal3_conn metal3_connant18;
    copy Via2 Via2ant18;
    copy metal2_conn metal2_connant18;
    copy Via1 Via1ant18;
    copy metal1_wo_diode metal1_wo_diodeant18;
    copy cont_poly cont_polyant18;
    copy Poly Polyant18;
    copy gate gateant18;

    connect metal6_connant18 metal5_connant18 -by Via5ant18;
    connect metal5_connant18 metal4_connant18 -by Via4ant18;
    connect metal4_connant18 metal3_connant18 -by Via3ant18;
    connect metal3_connant18 metal2_connant18 -by Via2ant18;
    connect metal2_connant18 metal1_wo_diodeant18 -by Via1ant18;
    connect metal1_wo_diodeant18 Polyant18 -by cont_polyant18;
    connect gateant18 Polyant18;

    rule ANT.5.V5 {
        caption ANT.5.V5: Via5 area to gate area ratio must be <= 25.0;
        antenna metal6_connant18 Via5ant18 gateant18 -gt 25.0 
        "[(area(Via5ant18)/area(gateant18))]";
    }

#endif

#ifdef CHECK_VIA6_ANT_5

    copy metal7_conn metal7_connant19;
    copy Via6 Via6ant19;
    copy metal6_conn metal6_connant19;
    copy Via5 Via5ant19;
    copy metal5_conn metal5_connant19;
    copy Via4 Via4ant19;
    copy metal4_conn metal4_connant19;
    copy Via3 Via3ant19;
    copy metal3_conn metal3_connant19;
    copy Via2 Via2ant19;
    copy metal2_conn metal2_connant19;
    copy Via1 Via1ant19;
    copy metal1_wo_diode metal1_wo_diodeant19;
    copy cont_poly cont_polyant19;
    copy Poly Polyant19;
    copy gate gateant19;

    connect metal7_connant19 metal6_connant19 -by Via6ant19;
    connect metal6_connant19 metal5_connant19 -by Via5ant19;
    connect metal5_connant19 metal4_connant19 -by Via4ant19;
    connect metal4_connant19 metal3_connant19 -by Via3ant19;
    connect metal3_connant19 metal2_connant19 -by Via2ant19;
    connect metal2_connant19 metal1_wo_diodeant19 -by Via1ant19;
    connect metal1_wo_diodeant19 Polyant19 -by cont_polyant19;
    connect gateant19 Polyant19;

    rule ANT.5.V6 {
        caption ANT.5.V6: Via6 area to gate area ratio must be <= 25.0;
        antenna metal7_connant19 Via6ant19 gateant19 -gt 25.0 
        "[(area(Via6ant19)/area(gateant19))]";
    }

#endif

#ifdef CHECK_VIA7_ANT_5

    copy metal8_conn metal8_connant20;
    copy Via7 Via7ant20;
    copy metal7_conn metal7_connant20;
    copy Via6 Via6ant20;
    copy metal6_conn metal6_connant20;
    copy Via5 Via5ant20;
    copy metal5_conn metal5_connant20;
    copy Via4 Via4ant20;
    copy metal4_conn metal4_connant20;
    copy Via3 Via3ant20;
    copy metal3_conn metal3_connant20;
    copy Via2 Via2ant20;
    copy metal2_conn metal2_connant20;
    copy Via1 Via1ant20;
    copy metal1_wo_diode metal1_wo_diodeant20;
    copy cont_poly cont_polyant20;
    copy Poly Polyant20;
    copy gate gateant20;

    connect metal8_connant20 metal7_connant20 -by Via7ant20;
    connect metal7_connant20 metal6_connant20 -by Via6ant20;
    connect metal6_connant20 metal5_connant20 -by Via5ant20;
    connect metal5_connant20 metal4_connant20 -by Via4ant20;
    connect metal4_connant20 metal3_connant20 -by Via3ant20;
    connect metal3_connant20 metal2_connant20 -by Via2ant20;
    connect metal2_connant20 metal1_wo_diodeant20 -by Via1ant20;
    connect metal1_wo_diodeant20 Polyant20 -by cont_polyant20;
    connect gateant20 Polyant20;

    rule ANT.5.V7 {
        caption ANT.5.V7: Via7 area to gate area ratio must be <= 25.0;
        antenna metal8_connant20 Via7ant20 gateant20 -gt 25.0 
        "[(area(Via7ant20)/area(gateant20))]";
    }

#endif

#ifdef CHECK_VIA8_ANT_5

    copy metal9_conn metal9_connant21;
    copy Via8 Via8ant21;
    copy metal8_conn metal8_connant21;
    copy Via7 Via7ant21;
    copy metal7_conn metal7_connant21;
    copy Via6 Via6ant21;
    copy metal6_conn metal6_connant21;
    copy Via5 Via5ant21;
    copy metal5_conn metal5_connant21;
    copy Via4 Via4ant21;
    copy metal4_conn metal4_connant21;
    copy Via3 Via3ant21;
    copy metal3_conn metal3_connant21;
    copy Via2 Via2ant21;
    copy metal2_conn metal2_connant21;
    copy Via1 Via1ant21;
    copy metal1_wo_diode metal1_wo_diodeant21;
    copy cont_poly cont_polyant21;
    copy Poly Polyant21;
    copy gate gateant21;

    connect metal9_connant21 metal8_connant21 -by Via8ant21;
    connect metal8_connant21 metal7_connant21 -by Via7ant21;
    connect metal7_connant21 metal6_connant21 -by Via6ant21;
    connect metal6_connant21 metal5_connant21 -by Via5ant21;
    connect metal5_connant21 metal4_connant21 -by Via4ant21;
    connect metal4_connant21 metal3_connant21 -by Via3ant21;
    connect metal3_connant21 metal2_connant21 -by Via2ant21;
    connect metal2_connant21 metal1_wo_diodeant21 -by Via1ant21;
    connect metal1_wo_diodeant21 Polyant21 -by cont_polyant21;
    connect gateant21 Polyant21;

    rule ANT.5.V8 {
        caption ANT.5.V8: Via8 area to gate area ratio must be <= 25.0;
        antenna metal9_connant21 Via8ant21 gateant21 -gt 25.0 
        "[(area(Via8ant21)/area(gateant21))]";
    }

#endif

#ifdef CHECK_VIA9_ANT_5

    copy metal10_conn metal10_connant22;
    copy Via9 Via9ant22;
    copy metal9_conn metal9_connant22;
    copy Via8 Via8ant22;
    copy metal8_conn metal8_connant22;
    copy Via7 Via7ant22;
    copy metal7_conn metal7_connant22;
    copy Via6 Via6ant22;
    copy metal6_conn metal6_connant22;
    copy Via5 Via5ant22;
    copy metal5_conn metal5_connant22;
    copy Via4 Via4ant22;
    copy metal4_conn metal4_connant22;
    copy Via3 Via3ant22;
    copy metal3_conn metal3_connant22;
    copy Via2 Via2ant22;
    copy metal2_conn metal2_connant22;
    copy Via1 Via1ant22;
    copy metal1_wo_diode metal1_wo_diodeant22;
    copy cont_poly cont_polyant22;
    copy Poly Polyant22;
    copy gate gateant22;

    connect metal10_connant22 metal9_connant22 -by Via9ant22;
    connect metal9_connant22 metal8_connant22 -by Via8ant22;
    connect metal8_connant22 metal7_connant22 -by Via7ant22;
    connect metal7_connant22 metal6_connant22 -by Via6ant22;
    connect metal6_connant22 metal5_connant22 -by Via5ant22;
    connect metal5_connant22 metal4_connant22 -by Via4ant22;
    connect metal4_connant22 metal3_connant22 -by Via3ant22;
    connect metal3_connant22 metal2_connant22 -by Via2ant22;
    connect metal2_connant22 metal1_wo_diodeant22 -by Via1ant22;
    connect metal1_wo_diodeant22 Polyant22 -by cont_polyant22;
    connect gateant22 Polyant22;

    rule ANT.5.V9 {
        caption ANT.5.V9: Via9 area to gate area ratio must be <= 25.0;
        antenna metal10_connant22 Via9ant22 gateant22 -gt 25.0 
        "[(area(Via9ant22)/area(gateant22))]";
    }

#endif

#ifdef CHECK_VIA10_ANT_5

    copy metal11_conn metal11_connant23;
    copy Via10 Via10ant23;
    copy metal10_conn metal10_connant23;
    copy Via9 Via9ant23;
    copy metal9_conn metal9_connant23;
    copy Via8 Via8ant23;
    copy metal8_conn metal8_connant23;
    copy Via7 Via7ant23;
    copy metal7_conn metal7_connant23;
    copy Via6 Via6ant23;
    copy metal6_conn metal6_connant23;
    copy Via5 Via5ant23;
    copy metal5_conn metal5_connant23;
    copy Via4 Via4ant23;
    copy metal4_conn metal4_connant23;
    copy Via3 Via3ant23;
    copy metal3_conn metal3_connant23;
    copy Via2 Via2ant23;
    copy metal2_conn metal2_connant23;
    copy Via1 Via1ant23;
    copy metal1_wo_diode metal1_wo_diodeant23;
    copy cont_poly cont_polyant23;
    copy Poly Polyant23;
    copy gate gateant23;

    connect metal11_connant23 metal10_connant23 -by Via10ant23;
    connect metal10_connant23 metal9_connant23 -by Via9ant23;
    connect metal9_connant23 metal8_connant23 -by Via8ant23;
    connect metal8_connant23 metal7_connant23 -by Via7ant23;
    connect metal7_connant23 metal6_connant23 -by Via6ant23;
    connect metal6_connant23 metal5_connant23 -by Via5ant23;
    connect metal5_connant23 metal4_connant23 -by Via4ant23;
    connect metal4_connant23 metal3_connant23 -by Via3ant23;
    connect metal3_connant23 metal2_connant23 -by Via2ant23;
    connect metal2_connant23 metal1_wo_diodeant23 -by Via1ant23;
    connect metal1_wo_diodeant23 Polyant23 -by cont_polyant23;
    connect gateant23 Polyant23;

    rule ANT.5.V10 {
        caption ANT.5.V10: Via10 area to gate area ratio must be <= 25.0;
        antenna metal11_connant23 Via10ant23 Via1ant23 gateant23 -gt 25.0 
        "[(area(Via10ant23)/area(gateant23))]";
    }

#endif

#ifdef CHECK_METAL11_ANT_6

    copy metal11_conn metal11_connant24;
    copy Via10 Via10ant24;
    copy metal10_conn metal10_connant24;
    copy Via9 Via9ant24;
    copy metal9_conn metal9_connant24;
    copy Via8 Via8ant24;
    copy metal8_conn metal8_connant24;
    copy Via7 Via7ant24;
    copy metal7_conn metal7_connant24;
    copy Via6 Via6ant24;
    copy metal6_conn metal6_connant24;
    copy Via5 Via5ant24;
    copy metal5_conn metal5_connant24;
    copy Via4 Via4ant24;
    copy metal4_conn metal4_connant24;
    copy Via3 Via3ant24;
    copy metal3_conn metal3_connant24;
    copy Via2 Via2ant24;
    copy metal2_conn metal2_connant24;
    copy Via1 Via1ant24;
    copy metal1_wo_diode metal1_wo_diodeant24;
    copy cont_poly cont_polyant24;
    copy Poly Polyant24;
    copy gate gateant24;

    connect metal11_connant24 metal10_connant24 -by Via10ant24;
    connect metal10_connant24 metal9_connant24 -by Via9ant24;
    connect metal9_connant24 metal8_connant24 -by Via8ant24;
    connect metal8_connant24 metal7_connant24 -by Via7ant24;
    connect metal7_connant24 metal6_connant24 -by Via6ant24;
    connect metal6_connant24 metal5_connant24 -by Via5ant24;
    connect metal5_connant24 metal4_connant24 -by Via4ant24;
    connect metal4_connant24 metal3_connant24 -by Via3ant24;
    connect metal3_connant24 metal2_connant24 -by Via2ant24;
    connect metal2_connant24 metal1_wo_diodeant24 -by Via1ant24;
    connect metal1_wo_diodeant24 Polyant24 -by cont_polyant24;
    connect gateant24 Polyant24;

    rule ANT.6.M1_11 {
        caption ANT.6.M1_11: Cumulative Metal1 through Metal11 area to gate area ratio must be <= 1200.0;
        antenna metal11_connant24 metal10_connant24 metal9_connant24 metal8_connant24 metal7_connant24 metal6_connant24 metal5_connant24 metal4_connant24 metal3_connant24 metal2_connant24 metal1_wo_diodeant24 gateant24 -gt 1200.0 
        "[((area(metal11_connant24)+area(metal10_connant24)+area(metal9_connant24)+area(metal8_connant24)+area(metal7_connant24)+area(metal6_connant24)+area(metal5_connant24)+area(metal4_connant24)+area(metal3_connant24)+area(metal2_connant24)+area(metal1_wo_diodeant24))/area(gateant24))]";
    }

#endif

#ifdef CHECK_METAL10_ANT_7

    copy metal10_conn metal10_connant25;
    copy Via9 Via9ant25;
    copy metal9_conn metal9_connant25;
    copy Via8 Via8ant25;
    copy metal8_conn metal8_connant25;
    copy Via7 Via7ant25;
    copy metal7_conn metal7_connant25;
    copy Via6 Via6ant25;
    copy metal6_conn metal6_connant25;
    copy Via5 Via5ant25;
    copy metal5_conn metal5_connant25;
    copy Via4 Via4ant25;
    copy metal4_conn metal4_connant25;
    copy Via3 Via3ant25;
    copy metal3_conn metal3_connant25;
    copy Via2 Via2ant25;
    copy metal2_conn metal2_connant25;
    copy Via1 Via1ant25;
    copy metal1_with_diode metal1_with_diodeant25;
    copy cont_poly cont_polyant25;
    copy Poly Polyant25;
    copy cont_diode cont_diodeant25;
    copy diff_diode diff_diodeant25;
    copy gate gateant25;

    connect metal10_connant25 metal9_connant25 -by Via9ant25;
    connect metal9_connant25 metal8_connant25 -by Via8ant25;
    connect metal8_connant25 metal7_connant25 -by Via7ant25;
    connect metal7_connant25 metal6_connant25 -by Via6ant25;
    connect metal6_connant25 metal5_connant25 -by Via5ant25;
    connect metal5_connant25 metal4_connant25 -by Via4ant25;
    connect metal4_connant25 metal3_connant25 -by Via3ant25;
    connect metal3_connant25 metal2_connant25 -by Via2ant25;
    connect metal2_connant25 metal1_with_diodeant25 -by Via1ant25;
    connect metal1_with_diodeant25 Polyant25 -by cont_polyant25;
    connect metal1_with_diodeant25 diff_diodeant25 -by cont_diodeant25;
    connect gateant25 Polyant25;

    rule ANT.7.M1_10 {
        caption ANT.7.M1_10: Cumulative Metal1 through Metal10 area to gate area ratio must be <= 45000 + (diode area * 500);
        antenna metal10_connant25 metal9_connant25 metal8_connant25 metal7_connant25 metal6_connant25 metal5_connant25 metal4_connant25 metal3_connant25 metal2_connant25 metal1_with_diodeant25 gateant25 diff_diodeant25 -gt 0.0 
        "[(((area(metal1_with_diodeant25)+area(metal2_connant25)+area(metal3_connant25)+area(metal4_connant25)+area(metal5_connant25)+area(metal6_connant25)+area(metal7_connant25)+area(metal8_connant25)+area(metal9_connant25)+area(metal10_connant25))/area(gateant25))-((area(diff_diodeant25)*500.0)+45000.0))]";
    }

#endif

#ifdef CHECK_METAL11_ANT_7

    copy metal11_conn metal11_connant26;
    copy Via10 Via10ant26;
    copy metal10_conn metal10_connant26;
    copy Via9 Via9ant26;
    copy metal9_conn metal9_connant26;
    copy Via8 Via8ant26;
    copy metal8_conn metal8_connant26;
    copy Via7 Via7ant26;
    copy metal7_conn metal7_connant26;
    copy Via6 Via6ant26;
    copy metal6_conn metal6_connant26;
    copy Via5 Via5ant26;
    copy metal5_conn metal5_connant26;
    copy Via4 Via4ant26;
    copy metal4_conn metal4_connant26;
    copy Via3 Via3ant26;
    copy metal3_conn metal3_connant26;
    copy Via2 Via2ant26;
    copy metal2_conn metal2_connant26;
    copy Via1 Via1ant26;
    copy metal1_with_diode metal1_with_diodeant26;
    copy cont_poly cont_polyant26;
    copy Poly Polyant26;
    copy cont_diode cont_diodeant26;
    copy diff_diode diff_diodeant26;
    copy gate gateant26;

    connect metal11_connant26 metal10_connant26 -by Via10ant26;
    connect metal10_connant26 metal9_connant26 -by Via9ant26;
    connect metal9_connant26 metal8_connant26 -by Via8ant26;
    connect metal8_connant26 metal7_connant26 -by Via7ant26;
    connect metal7_connant26 metal6_connant26 -by Via6ant26;
    connect metal6_connant26 metal5_connant26 -by Via5ant26;
    connect metal5_connant26 metal4_connant26 -by Via4ant26;
    connect metal4_connant26 metal3_connant26 -by Via3ant26;
    connect metal3_connant26 metal2_connant26 -by Via2ant26;
    connect metal2_connant26 metal1_with_diodeant26 -by Via1ant26;
    connect metal1_with_diodeant26 Polyant26 -by cont_polyant26;
    connect metal1_with_diodeant26 diff_diodeant26 -by cont_diodeant26;
    connect gateant26 Polyant26;

    rule ANT.7.M1_11 {
        caption ANT.7.M1_11: Cumulative Metal1 through Metal11 area to gate area ratio must be <= 55000 + (diode area * 7500);
        antenna metal11_connant26 metal10_connant26 metal9_connant26 metal8_connant26 metal7_connant26 metal6_connant26 metal5_connant26 metal4_connant26 metal3_connant26 metal2_connant26 metal1_with_diodeant26 gateant26 diff_diodeant26 -gt 0.0 
        "[((area(metal1_with_diodeant26)+area(metal2_connant26)+area(metal3_connant26)+area(metal4_connant26)+area(metal5_connant26)+area(metal6_connant26)+area(metal7_connant26)+area(metal8_connant26)+area(metal9_connant26)+area(metal10_connant26)+area(metal11_connant26)/area(gateant26))-((area(diff_diodeant26)*7500.0)+55000.0))]";
    }

#endif

#ifdef CHECK_VIA1_ANT_8

    copy metal2_conn metal2_connant27;
    copy Via1 Via1ant27;
    copy metal1_with_diode metal1_with_diodeant27;
    copy cont_poly cont_polyant27;
    copy Poly Polyant27;
    copy cont_diode cont_diodeant27;
    copy diff_diode diff_diodeant27;
    copy gate gateant27;

    connect metal2_connant27 metal1_with_diodeant27 -by Via1ant27;
    connect metal1_with_diodeant27 Polyant27 -by cont_polyant27;
    connect metal1_with_diodeant27 diff_diodeant27 -by cont_diodeant27;
    connect gateant27 Polyant27;

    rule ANT.8.V1_1 {
        caption ANT.8.V1_1: Via1 area to gate area ratio must be <= 1000 + (diode area * 250);
        antenna metal2_connant27 Via1ant27 gateant27 diff_diodeant27 -gt 0.0 
        "[((area(Via1ant27)/area(gateant27))-((area(diff_diodeant27)*250.0)+1000.0))]";
    }

#endif

#ifdef CHECK_VIA2_ANT_8

    copy metal3_conn metal3_connant28;
    copy Via2 Via2ant28;
    copy metal2_conn metal2_connant28;
    copy Via1 Via1ant28;
    copy metal1_with_diode metal1_with_diodeant28;
    copy cont_poly cont_polyant28;
    copy Poly Polyant28;
    copy cont_diode cont_diodeant28;
    copy diff_diode diff_diodeant28;
    copy gate gateant28;

    connect metal3_connant28 metal2_connant28 -by Via2ant28;
    connect metal2_connant28 metal1_with_diodeant28 -by Via1ant28;
    connect metal1_with_diodeant28 Polyant28 -by cont_polyant28;
    connect metal1_with_diodeant28 diff_diodeant28 -by cont_diodeant28;
    connect gateant28 Polyant28;

    rule ANT.8.V1_2 {
        caption ANT.8.V1_2: Cumulative Via1 through Via2 area to gate area ratio must be <= 1000 + (diode area * 250);
        antenna metal3_connant28 Via2ant28 Via1ant28 gateant28 diff_diodeant28 -gt 0.0 
        "[(((area(Via1ant28)+area(Via2ant28))/area(gateant28))-((area(diff_diodeant28)*250.0)+1000.0))]";
    }

#endif

#ifdef CHECK_VIA3_ANT_8

    copy metal4_conn metal4_connant29;
    copy Via3 Via3ant29;
    copy metal3_conn metal3_connant29;
    copy Via2 Via2ant29;
    copy metal2_conn metal2_connant29;
    copy Via1 Via1ant29;
    copy metal1_with_diode metal1_with_diodeant29;
    copy cont_poly cont_polyant29;
    copy Poly Polyant29;
    copy cont_diode cont_diodeant29;
    copy diff_diode diff_diodeant29;
    copy gate gateant29;

    connect metal4_connant29 metal3_connant29 -by Via3ant29;
    connect metal3_connant29 metal2_connant29 -by Via2ant29;
    connect metal2_connant29 metal1_with_diodeant29 -by Via1ant29;
    connect metal1_with_diodeant29 Polyant29 -by cont_polyant29;
    connect metal1_with_diodeant29 diff_diodeant29 -by cont_diodeant29;
    connect gateant29 Polyant29;

    rule ANT.8.V1_3 {
        caption ANT.8.V1_3: Cumulative Via1 through Via3 area to gate area ratio must be <= 1000 + (diode area * 250);
        antenna metal4_connant29 Via3ant29 Via2ant29 Via1ant29 gateant29 diff_diodeant29 -gt 0.0 
        "[(((area(Via1ant29)+area(Via2ant29)+area(Via3ant29))/area(gateant29))-((area(diff_diodeant29)*250.0)+1000.0))]";
    }

#endif

#ifdef CHECK_VIA4_ANT_8

    copy metal5_conn metal5_connant30;
    copy Via4 Via4ant30;
    copy metal4_conn metal4_connant30;
    copy Via3 Via3ant30;
    copy metal3_conn metal3_connant30;
    copy Via2 Via2ant30;
    copy metal2_conn metal2_connant30;
    copy Via1 Via1ant30;
    copy metal1_with_diode metal1_with_diodeant30;
    copy cont_poly cont_polyant30;
    copy Poly Polyant30;
    copy cont_diode cont_diodeant30;
    copy diff_diode diff_diodeant30;
    copy gate gateant30;

    connect metal5_connant30 metal4_connant30 -by Via4ant30;
    connect metal4_connant30 metal3_connant30 -by Via3ant30;
    connect metal3_connant30 metal2_connant30 -by Via2ant30;
    connect metal2_connant30 metal1_with_diodeant30 -by Via1ant30;
    connect metal1_with_diodeant30 Polyant30 -by cont_polyant30;
    connect metal1_with_diodeant30 diff_diodeant30 -by cont_diodeant30;
    connect gateant30 Polyant30;

    rule ANT.8.V1_4 {
        caption ANT.8.V1_4: Cumulative Via1 through Via4 area to gate area ratio must be <= 1000 + (diode area * 250);
        antenna metal5_connant30 Via4ant30 Via3ant30 Via2ant30 Via1ant30 gateant30 diff_diodeant30 -gt 0.0 
        "[(((area(Via1ant30)+area(Via2ant30)+area(Via3ant30)+area(Via4ant30))/area(gateant30))-((area(diff_diodeant30)*250.0)+1000.0))]";
    }

#endif

#ifdef CHECK_VIA5_ANT_8

    copy metal6_conn metal6_connant31;
    copy Via5 Via5ant31;
    copy metal5_conn metal5_connant31;
    copy Via4 Via4ant31;
    copy metal4_conn metal4_connant31;
    copy Via3 Via3ant31;
    copy metal3_conn metal3_connant31;
    copy Via2 Via2ant31;
    copy metal2_conn metal2_connant31;
    copy Via1 Via1ant31;
    copy metal1_with_diode metal1_with_diodeant31;
    copy cont_poly cont_polyant31;
    copy Poly Polyant31;
    copy cont_diode cont_diodeant31;
    copy diff_diode diff_diodeant31;
    copy gate gateant31;

    connect metal6_connant31 metal5_connant31 -by Via5ant31;
    connect metal5_connant31 metal4_connant31 -by Via4ant31;
    connect metal4_connant31 metal3_connant31 -by Via3ant31;
    connect metal3_connant31 metal2_connant31 -by Via2ant31;
    connect metal2_connant31 metal1_with_diodeant31 -by Via1ant31;
    connect metal1_with_diodeant31 Polyant31 -by cont_polyant31;
    connect metal1_with_diodeant31 diff_diodeant31 -by cont_diodeant31;
    connect gateant31 Polyant31;

    rule ANT.8.V1_5 {
        caption ANT.8.V1_5: Cumulative Via1 through Via5 area to gate area ratio must be <= 1000 + (diode area * 250);
        antenna metal6_connant31 Via5ant31 Via4ant31 Via3ant31 Via2ant31 Via1ant31 gateant31 diff_diodeant31 -gt 0.0 
        "[(((area(Via1ant31)+area(Via2ant31)+area(Via3ant31)+area(Via4ant31)+area(Via5ant31))/area(gateant31))-((area(diff_diodeant31)*250.0)+1000.0))]";
    }

#endif

#ifdef CHECK_VIA6_ANT_8

    copy metal7_conn metal7_connant32;
    copy Via6 Via6ant32;
    copy metal6_conn metal6_connant32;
    copy Via5 Via5ant32;
    copy metal5_conn metal5_connant32;
    copy Via4 Via4ant32;
    copy metal4_conn metal4_connant32;
    copy Via3 Via3ant32;
    copy metal3_conn metal3_connant32;
    copy Via2 Via2ant32;
    copy metal2_conn metal2_connant32;
    copy Via1 Via1ant32;
    copy metal1_with_diode metal1_with_diodeant32;
    copy cont_poly cont_polyant32;
    copy Poly Polyant32;
    copy cont_diode cont_diodeant32;
    copy diff_diode diff_diodeant32;
    copy gate gateant32;

    connect metal7_connant32 metal6_connant32 -by Via6ant32;
    connect metal6_connant32 metal5_connant32 -by Via5ant32;
    connect metal5_connant32 metal4_connant32 -by Via4ant32;
    connect metal4_connant32 metal3_connant32 -by Via3ant32;
    connect metal3_connant32 metal2_connant32 -by Via2ant32;
    connect metal2_connant32 metal1_with_diodeant32 -by Via1ant32;
    connect metal1_with_diodeant32 Polyant32 -by cont_polyant32;
    connect metal1_with_diodeant32 diff_diodeant32 -by cont_diodeant32;
    connect gateant32 Polyant32;

    rule ANT.8.V1_6 {
        caption ANT.8.V1_6: Cumulative Via1 through Via6 area to gate area ratio must be <= 1000 + (diode area * 250);
        antenna metal7_connant32 Via6ant32 Via5ant32 Via4ant32 Via3ant32 Via2ant32 Via1ant32 gateant32 diff_diodeant32 -gt 0.0 
        "[(((area(Via1ant32)+area(Via2ant32)+area(Via3ant32)+area(Via4ant32)+area(Via5ant32)+area(Via6ant32))/area(gateant32))-((area(diff_diodeant32)*250.0)+1000.0))]";
    }

#endif

#ifdef CHECK_VIA7_ANT_8

    copy metal8_conn metal8_connant33;
    copy Via7 Via7ant33;
    copy metal7_conn metal7_connant33;
    copy Via6 Via6ant33;
    copy metal6_conn metal6_connant33;
    copy Via5 Via5ant33;
    copy metal5_conn metal5_connant33;
    copy Via4 Via4ant33;
    copy metal4_conn metal4_connant33;
    copy Via3 Via3ant33;
    copy metal3_conn metal3_connant33;
    copy Via2 Via2ant33;
    copy metal2_conn metal2_connant33;
    copy Via1 Via1ant33;
    copy metal1_with_diode metal1_with_diodeant33;
    copy cont_poly cont_polyant33;
    copy Poly Polyant33;
    copy cont_diode cont_diodeant33;
    copy diff_diode diff_diodeant33;
    copy gate gateant33;

    connect metal8_connant33 metal7_connant33 -by Via7ant33;
    connect metal7_connant33 metal6_connant33 -by Via6ant33;
    connect metal6_connant33 metal5_connant33 -by Via5ant33;
    connect metal5_connant33 metal4_connant33 -by Via4ant33;
    connect metal4_connant33 metal3_connant33 -by Via3ant33;
    connect metal3_connant33 metal2_connant33 -by Via2ant33;
    connect metal2_connant33 metal1_with_diodeant33 -by Via1ant33;
    connect metal1_with_diodeant33 Polyant33 -by cont_polyant33;
    connect metal1_with_diodeant33 diff_diodeant33 -by cont_diodeant33;
    connect gateant33 Polyant33;

    rule ANT.8.V1_7 {
        caption ANT.8.V1_7: Cumulative Via1 through Via7 area to gate area ratio must be <= 1000 + (diode area * 250);
        antenna metal8_connant33 Via7ant33 Via6ant33 Via5ant33 Via4ant33 Via3ant33 Via2ant33 Via1ant33 gateant33 diff_diodeant33 -gt 0.0 
        "[(((area(Via1ant33)+area(Via2ant33)+area(Via3ant33)+area(Via4ant33)+area(Via5ant33)+area(Via6ant33)+area(Via7ant33))/area(gateant33))-((area(diff_diodeant33)*250.0)+1000.0))]";
    }

#endif

#ifdef CHECK_VIA8_ANT_8

    copy metal9_conn metal9_connant34;
    copy Via8 Via8ant34;
    copy metal8_conn metal8_connant34;
    copy Via7 Via7ant34;
    copy metal7_conn metal7_connant34;
    copy Via6 Via6ant34;
    copy metal6_conn metal6_connant34;
    copy Via5 Via5ant34;
    copy metal5_conn metal5_connant34;
    copy Via4 Via4ant34;
    copy metal4_conn metal4_connant34;
    copy Via3 Via3ant34;
    copy metal3_conn metal3_connant34;
    copy Via2 Via2ant34;
    copy metal2_conn metal2_connant34;
    copy Via1 Via1ant34;
    copy metal1_with_diode metal1_with_diodeant34;
    copy cont_poly cont_polyant34;
    copy Poly Polyant34;
    copy cont_diode cont_diodeant34;
    copy diff_diode diff_diodeant34;
    copy gate gateant34;

    connect metal9_connant34 metal8_connant34 -by Via8ant34;
    connect metal8_connant34 metal7_connant34 -by Via7ant34;
    connect metal7_connant34 metal6_connant34 -by Via6ant34;
    connect metal6_connant34 metal5_connant34 -by Via5ant34;
    connect metal5_connant34 metal4_connant34 -by Via4ant34;
    connect metal4_connant34 metal3_connant34 -by Via3ant34;
    connect metal3_connant34 metal2_connant34 -by Via2ant34;
    connect metal2_connant34 metal1_with_diodeant34 -by Via1ant34;
    connect metal1_with_diodeant34 Polyant34 -by cont_polyant34;
    connect metal1_with_diodeant34 diff_diodeant34 -by cont_diodeant34;
    connect gateant34 Polyant34;

    rule ANT.8.V1_8 {
        caption ANT.8.V1_8: Cumulative Via1 through Via8 area to gate area ratio must be <= 1000 + (diode area * 250);
        antenna metal9_connant34 Via8ant34 Via7ant34 Via6ant34 Via5ant34 Via4ant34 Via3ant34 Via2ant34 Via1ant34 gateant34 diff_diodeant34 -gt 0.0 
        "[(((area(Via1ant34)+area(Via2ant34)+area(Via3ant34)+area(Via4ant34)+area(Via5ant34)+area(Via6ant34)+area(Via7ant34)+area(Via8ant34))/area(gateant34))-((area(diff_diodeant34)*250.0)+1000.0))]";
    }

#endif

#ifdef CHECK_VIA9_ANT_8

    copy metal10_conn metal10_connant35;
    copy Via9 Via9ant35;
    copy metal9_conn metal9_connant35;
    copy Via8 Via8ant35;
    copy metal8_conn metal8_connant35;
    copy Via7 Via7ant35;
    copy metal7_conn metal7_connant35;
    copy Via6 Via6ant35;
    copy metal6_conn metal6_connant35;
    copy Via5 Via5ant35;
    copy metal5_conn metal5_connant35;
    copy Via4 Via4ant35;
    copy metal4_conn metal4_connant35;
    copy Via3 Via3ant35;
    copy metal3_conn metal3_connant35;
    copy Via2 Via2ant35;
    copy metal2_conn metal2_connant35;
    copy Via1 Via1ant35;
    copy metal1_with_diode metal1_with_diodeant35;
    copy cont_poly cont_polyant35;
    copy Poly Polyant35;
    copy cont_diode cont_diodeant35;
    copy diff_diode diff_diodeant35;
    copy gate gateant35;

    connect metal10_connant35 metal9_connant35 -by Via9ant35;
    connect metal9_connant35 metal8_connant35 -by Via8ant35;
    connect metal8_connant35 metal7_connant35 -by Via7ant35;
    connect metal7_connant35 metal6_connant35 -by Via6ant35;
    connect metal6_connant35 metal5_connant35 -by Via5ant35;
    connect metal5_connant35 metal4_connant35 -by Via4ant35;
    connect metal4_connant35 metal3_connant35 -by Via3ant35;
    connect metal3_connant35 metal2_connant35 -by Via2ant35;
    connect metal2_connant35 metal1_with_diodeant35 -by Via1ant35;
    connect metal1_with_diodeant35 Polyant35 -by cont_polyant35;
    connect metal1_with_diodeant35 diff_diodeant35 -by cont_diodeant35;
    connect gateant35 Polyant35;

    rule ANT.8.V1_9 {
        caption ANT.8.V1_9: Cumulative Via1 through Via9 area to gate area ratio must be <= 1000 + (diode area * 250);
        antenna metal10_connant35 Via9ant35 Via8ant35 Via7ant35 Via6ant35 Via5ant35 Via4ant35 Via3ant35 Via2ant35 Via1ant35 gateant35 diff_diodeant35 -gt 0.0 
        "[(((area(Via1ant35)+area(Via2ant35)+area(Via3ant35)+area(Via4ant35)+area(Via5ant35)+area(Via6ant35)+area(Via7ant35)+area(Via8ant35)+area(Via9ant35))/area(gateant35))-((area(diff_diodeant35)*250.0)+1000.0))]";
    }

#endif

#ifdef CHECK_VIA10_ANT_8

    copy metal11_conn metal11_connant36;
    copy Via10 Via10ant36;
    copy metal10_conn metal10_connant36;
    copy Via9 Via9ant36;
    copy metal9_conn metal9_connant36;
    copy Via8 Via8ant36;
    copy metal8_conn metal8_connant36;
    copy Via7 Via7ant36;
    copy metal7_conn metal7_connant36;
    copy Via6 Via6ant36;
    copy metal6_conn metal6_connant36;
    copy Via5 Via5ant36;
    copy metal5_conn metal5_connant36;
    copy Via4 Via4ant36;
    copy metal4_conn metal4_connant36;
    copy Via3 Via3ant36;
    copy metal3_conn metal3_connant36;
    copy Via2 Via2ant36;
    copy metal2_conn metal2_connant36;
    copy Via1 Via1ant36;
    copy metal1_with_diode metal1_with_diodeant36;
    copy cont_poly cont_polyant36;
    copy Poly Polyant36;
    copy cont_diode cont_diodeant36;
    copy diff_diode diff_diodeant36;
    copy gate gateant36;

    connect metal11_connant36 metal10_connant36 -by Via10ant36;
    connect metal10_connant36 metal9_connant36 -by Via9ant36;
    connect metal9_connant36 metal8_connant36 -by Via8ant36;
    connect metal8_connant36 metal7_connant36 -by Via7ant36;
    connect metal7_connant36 metal6_connant36 -by Via6ant36;
    connect metal6_connant36 metal5_connant36 -by Via5ant36;
    connect metal5_connant36 metal4_connant36 -by Via4ant36;
    connect metal4_connant36 metal3_connant36 -by Via3ant36;
    connect metal3_connant36 metal2_connant36 -by Via2ant36;
    connect metal2_connant36 metal1_with_diodeant36 -by Via1ant36;
    connect metal1_with_diodeant36 Polyant36 -by cont_polyant36;
    connect metal1_with_diodeant36 diff_diodeant36 -by cont_diodeant36;
    connect gateant36 Polyant36;

    rule ANT.8.V1_10 {
        caption ANT.8.V1_10: Cumulative Via1 through Via10 area to gate area ratio must be <= 1000 + (diode area * 250);
        antenna metal11_connant36 Via10ant36 Via9ant36 Via8ant36 Via7ant36 Via6ant36 Via5ant36 Via4ant36 Via3ant36 Via2ant36 Via1ant36 gateant36 diff_diodeant36 -gt 0.0 
        "[(((area(Via1ant36)+area(Via2ant36)+area(Via3ant36)+area(Via4ant36)+area(Via5ant36)+area(Via6ant36)+area(Via7ant36)+area(Via8ant36)+area(Via9ant36)+area(Via10ant36))/area(gateant36))-((area(diff_diodeant36)*250.0)+1000.0))]";
    }

#endif

